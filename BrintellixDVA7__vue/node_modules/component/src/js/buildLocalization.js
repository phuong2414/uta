import { loadJSON } from 'loader';
import { template } from 'utils';
import Cache from 'cache';

const cache = new Cache();

module.exports = getLocalizationByConstructor;

function getLocalizationByConstructor(constructor, outsideLang) {
  const defaultLang = 'en';
  const lang = outsideLang || defaultLang;
  // TODO: works only if localizationTemplate and name were added to the prototype during component registration

  return getLocalization(constructor, lang, defaultLang)
    .then(localization => extendLocalizationByScheme(localization.defaults, constructor.prototype.defaults, lang)
      .then(() => localization));
}

function getLocalization(constructor, lang, defaultLang) {
  const localizationPath = getLocalizationPath(constructor, lang);

  return loadLocalizationData(localizationPath)
    .then((localization) => {
      if (isLocalization(localization)) {
        return localization;
      } else if (lang !== defaultLang) {
        const defaultLocalizationPath = getLocalizationPath(constructor, defaultLang);
        return loadLocalizationData(defaultLocalizationPath);
      }
      return Promise.resolve({});
    });
}


function getLocalizationPath(constructor, lang) {
  return template(constructor.prototype.localizationTemplate, { name: constructor.prototype.name, lang });
}

function loadLocalizationData(path) {
  const loadFromCache = true;
  const reviver = null;

  if(!cache.isCache(path)){
    cache.set(path, loadJSON(path, reviver, loadFromCache));
  }
  
  return cache.get(path)
    .then(data => Object.assign({}, data));
}

function isLocalization(localization) {
  return localization && Object.keys(localization).length;
}

// if property described in scheme has 'base' defined, it's localization is extended with localization from 'base'
function extendLocalizationByScheme(localization, scheme, lang) {
  const localizationPromises = [];

  for (const prop in scheme) {
    let propertyDescriptor = scheme[prop],
      localizationLoadingPromise;

    if (propertyDescriptor.sealed) {
      continue;
    }

    if (propertyDescriptor.base) {
      localizationLoadingPromise = getLocalizationByConstructor(propertyDescriptor.base, lang)
				.then(subLocalization => localization[prop].defaults = subLocalization.defaults);
    } else if (propertyDescriptor.scheme) {
      localizationLoadingPromise = extendLocalizationByScheme(localization[prop].defaults, propertyDescriptor.scheme, lang);
    } else {
      continue;
    }
    localizationPromises.push(localizationLoadingPromise);
  }

  return Promise.all(localizationPromises);
}
