import {Component} from 'component'
import IScroll from 'iscroll'
import dispatcher from 'dispatcher'
import {events} from 'touch'

export class Iscroller extends Component {
  constructor (element) {
    super(...arguments)
    element.style.opacity = 0
    this.refresh('stopPropagationSwipe')

    this.activateElement = (event) => {
      this.scroller.scrollToElement(event.target, 0)
    }

    this.deactivateElement = () => {
      this.scroller.x = this.xBeforeEditing
      this.scroller.y = this.yBeforeEditing
      this.refresh()
    }
  }

  addCheckOnElementListener () {
    document.addEventListener(events.move, event => {
      if (!checkOnElement(event.target, this.element)) {
        this.scroller.initiated = 0
      }
    }, false)
  }

  ready () {
    this.init();

    var intervalHandler

    dispatcher.subscribeAction(action => {
      if (action.type === dispatcher.ActionType.EDIT_PRESENTATION) {
        this.isEditing = true
        this.xBeforeEditing = this.scroller.x
        this.yBeforeEditing = this.scroller.y
        if (!intervalHandler) {
          clearInterval(intervalHandler)
        }
        intervalHandler = setInterval(() => {
          this.scroller.refresh()
        }, 1000)
      }
      if (action.type === dispatcher.ActionType.VIEW_PRESENTATION) {
        this.isEditing = false
        clearInterval(intervalHandler)
      }
    })
  }

  init() {
    this.scroller = new IScroll(this.element, this)
    this.scrollToElement(this.scrollToSelector, 0)
    this.scroller.on('beforeScrollStart', () => {
      this.scrollToSelector = ''
    })

    this.observe()
    this.element.style.removeProperty('opacity')
    this.addCheckOnElementListener()

    setTimeout(() => {
      this.scroller.refresh()
    });
  }

  get defaults () {
    return {
      'fade-scrollbars': {
        value: false,
        type: Boolean,
        refresh: true,
        optional: true
      },
      'scrollbars': {
        value: true,
        values: [true, false, 'custom'],
        type: String,
        refresh: true
      },
      'scroll-x': {
        value: true,
        type: Boolean,
        refresh: true
      },
      'scroll-y': {
        value: true,
        type: Boolean,
        refresh: true
      },
      'start-x': {
        value: 0,
        type: Number,
        refresh: true,
        optional: true,
        units: 'px'
      },
      'start-y': {
        value: 0,
        type: Number,
        refresh: true,
        optional: true,
        units: 'px'
      },
      'mouse-wheel': {
        value: true,
        type: Boolean,
        refresh: true
      },
      'mouse-wheel-speed': {
        value: 20,
        type: Number,
        refresh: true,
        optional: true,
        units: 'px'
      },
      'interactive-scrollbars': {
        value: true,
        type: Boolean,
        refresh: true,
        optional: true
      },
      'momentum': {
        value: true,
        type: Boolean,
        refresh: true
      },
      'use-transition': {
        value: true,
        type: Boolean,
        refresh: true,
        optional: true
      },
      'bounce': {
        value: true,
        type: Boolean,
        refresh: true
      },
      'bounce-easing': {
        value: '',
        values: ['quadratic', 'circular', 'back', 'bounce', 'elastic', ''],
        type: String,
        refresh: true,
        optional: true
      },
      'bounce-time': {
        value: 600,
        type: Number,
        refresh: true,
        optional: true,
        units: 'ms'
      },
      'scroll-to-selector': {
        value: '',
        type: String,
        refresh: true,
        optional: true
      },
      'snap': {
        value: '',
        type: String,
        refresh: true,
        optional: true
      },
      'stop-propagation-swipe': {
        value: 'all',
        values: ['all', 'horizontal', 'vertical', ''],
        type: String,
        refresh: true,
        optional: true
      },
      'preventDefault': {
        value: true,
        type: Boolean,
        refresh: false,
        optional: true
      },
      'bindToWrapper': {
        value: true,
        type: Boolean,
        refresh: false,
        optional: true
      }
    }
  }

  template () {
    return require('../template.html')
  };

  refresh (property) {
    switch (property) {
      case 'scrollToSelector':
        this.scrollToElement(this.scrollToSelector)
        break
      case 'stopPropagationSwipe':
        this.unlockSwipeEvents('all')
        this.lockSwipeEvents(this.stopPropagationSwipe)
        break
      default:
        let x = this.scroller.x;
        let y = this.scroller.y;

        this.scroller.destroy()
        this.scroller = new IScroll(this.element, this)

        if (property === 'scrollX' || property === 'scrollY') {
          this.scrollToElement(this.scrollToSelector, 0)
        } else if (property !== 'startX' && property !== 'startY') {
          this.scroller.scrollTo(x, y)
        }

        this.scroller.refresh()
    }
  }

  _toggleEvents (eventsType, actionType) {
    const events = {
      horizontal: ['left', 'right'],
      vertical: ['up', 'down']
    }
    events.all = events.horizontal.concat(events.vertical)

    eventsType && events[eventsType].forEach(side => {
      this.element[actionType + 'EventListener']('swipe' + side, stopSwipeEvent)
    })
  }

  lockSwipeEvents (type) {
    this._toggleEvents(type, 'add')
  }

  unlockSwipeEvents (type) {
    this._toggleEvents(type, 'remove')
  }

  observe () {
    new window.MutationObserver(() => {
      this.scroller.refresh()
    }).observe(this.element.getElementsByClassName('scroller')[0], {childList: true, subtree: true})
  }

  scrollToElement (selector, time = this.isEditing ? 0 : 200, offsetX = true, offsetY = true) {
    if (selector) {
      let element = getDOMElement(this.element, selector)
      this.element.contains(element) && this.scroller.scrollToElement(element, time, offsetX, offsetY)
    }
  }
}

function stopSwipeEvent (event) {
  event.stopPropagation()
}

function getDOMElement (parentElement, selector) {
  return parentElement.querySelector(selector)
}

function checkOnElement (target, element) {
  const isTrulyThisElement = true
  if (target === element) {
    return isTrulyThisElement
  } else if (~[document, document.body, null].indexOf(target)) {
    return !isTrulyThisElement
  }
  return checkOnElement(target.parentNode, element)
}
