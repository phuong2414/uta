import {Component} from "component";
import * as utils from "utils";
import * as touch from "touch";
import * as nav from "nav";

export class TabGroup extends Component {
	constructor(element, model){
		super(...arguments);

		this.tabElements = [];

		nav.onenter(() => {
			if(this.firstHidden && this.defaultIndex === 0) {
				this.index = this.defaultIndex + 1;
			} else {
				this.index = this.defaultIndex;
			}
		});

		this.observe(this.element, {childList: true, subtree: true}, this.reInitTabs.bind(this));
	}

	ready(){
		setTimeout(()=>{
			//fix co-collection
			this.refreshComponent({ element: this.element, searchElem: 'co-collection'});
			//fix scroller on the first tab
			this.initScrollersRefresh();
		}, 100);
		this.iscrolls = this.element.querySelectorAll('co-iscroll');
	}

	refreshComponent(option){
		utils.toArray(option.nodeList || option.element.querySelectorAll(option.searchElem)).forEach((elem) =>{
			elem.model ? elem.model.refresh() : false
		})
	}

	initScrollersRefresh(){
		this.refreshScrollers();
		this.initScrollersRefresh = function(){};
	}

	refreshScrollers(){
		this.refreshComponent({ nodeList: this.iscrolls});
	}

	template(){
		return require('../template.html');
	}

	activate(activatedElement){
		let activatedTab, activetedElementInTabGroupContext;

		activetedElementInTabGroupContext = this.getActivetedElementInTabGroupContext(activatedElement);

		activatedTab = this.tabElements.find((tabElement) =>{
			return tabElement.tabs.contains(activetedElementInTabGroupContext) || tabElement.button.contains(activetedElementInTabGroupContext);
		});

		if(activatedTab){
			this.index = activatedTab.index;
		}
	}

	getActivetedElementInTabGroupContext(activatedElement){
		var activetedElementInTabGroupContext;

		if(activatedElement.tagName === 'CO-COLLECTION-ITEM' || activatedElement.parentElement.tagName === 'CO-COLLECTION-ITEM'){
			activetedElementInTabGroupContext = this.tabElements.find((tabElement) =>{
				return activatedElement.contains(tabElement.tabs) || activatedElement.contains(tabElement.button);
			});
		}

		return (activetedElementInTabGroupContext && activetedElementInTabGroupContext.button) || activatedElement;
	}

	getTabsWithContent(){
		let collectionItems = this.element.querySelectorAll(".tabs > co-collection > co-collection-item");
		return collectionItems.length ? collectionItems : this.element.querySelectorAll(".tabs > *");
	}

	getNodeTabElements(){
		return {
			navButtons: this.element.querySelectorAll("co-menu co-option"),
			tabsWithContent: this.getTabsWithContent()
		};
	}

	getCollection(objWithNodeElements){
		return [].slice.call(objWithNodeElements.navButtons).map((element, index) =>{
			return {
				button: element,
				tabs: objWithNodeElements.tabsWithContent[index],
				index: index
			};
		})
	}

	hideFirstTab(tabIndex = 0){
		if(this.tabElements[tabIndex] && this.firstHidden){
			this.element.classList.add("hidden-first");
		}else{
			this.element.classList.remove("hidden-first");
		}
	}

	openTab(tab){
		tab.button.model.selected = true;
		tab.tabs.classList.add("active");
		tab.tabs.classList.add("active-tab");
		utils.dispatchEvent(this.element, "tabenter", {detail: {tabIndex: tab.index}});
	}

	closeTab(tab){
		tab.button.model.selected = false;
		tab.tabs.classList.remove("active");
		tab.tabs.classList.remove("active-tab");
		utils.dispatchEvent(this.element, "tableave", {detail: {tabIndex: tab.index}});
	}

	isTabActive(tab){
		return tab === this.activeTab;
	}

	selectTab(index){
		let tab = this.tabElements[index] || this.activeTab;

		if(this.activeTab){
			this.closeTab(this.activeTab);
		}
		this.openTab(tab);
		this.activeTab = tab;

	}

	setTabIndex(tab){
		if(!this.isTabActive(tab)){
			this.index = this.tabElements.indexOf(tab);
		}else{
			this.showHiddenTab(tab);
		}

	}

	showHiddenTab(tab){
		if(this.firstHidden){
			tab.button.model.unselect();
			this.index = 0;
		}
	}

	removeLitenersForTabNavigationButtons(tabElements){
		tabElements.forEach((tab) =>{
			tab.button.removeEventListener("tap", tab.listen);
		});
	}

	addLitenersForTabNavigationButtons(tabElements){
		tabElements.forEach((tab, ind) =>{
			if(tab.tabs){
				tabElements[ind]["listen"] = this.setTabIndex.bind(this, tab);
				tab.button.addEventListener("tap", tabElements[ind]["listen"]);
				this.closeTab(tab);
			}
		});
	}

	reInitTabs(){
		let nodeTabElements = this.getNodeTabElements();

		this.removeLitenersForTabNavigationButtons(this.tabElements);
		this.tabElements = this.getCollection(nodeTabElements);
		this.addLitenersForTabNavigationButtons(this.tabElements);

		if(this.tabElements && this.tabElements.length > 0 && this.tabElements[this.index] && this.tabElements[this.index].button){
			this.tabElements[this.index].button.model.select();
		}else if(this.tabElements.length > 0){
			this.index = this.tabElements.length - 1;
		}

		this.selectTab(this.index);
		this.setOrientation();
		this.hideFirstTab();
		this.changeZIndexReverse();
		this.ready();
	}

	observe(nodeTarget, config, callback){
		let observer = new MutationObserver((el) =>{
			setTimeout(() =>{
				callback();
			}, 0);
		});
		observer.observe(nodeTarget, config);
		setTimeout(() =>{
			this.reInitTabs();
		}, 105);
	}

	setOrientation(){
		let isVertical = (this.orientation === "vertical");
		this.element.classList[isVertical ? "add" : "remove"]("vertical");
	}

	refresh(attrName){
		switch(attrName){
			case "orientation":
				this.setOrientation();
				break;
			case "index":
				if(this.index < 0){
					this.index = 0;
				}
				this.selectTab(this.index);
				break;
			case "firstHidden":
				this.hideFirstTab(this.index);
				break;
		}
		this.refreshScrollers();
	}

	changeZIndexReverse(){
		var length = this.tabElements.length;

		this.tabElements.forEach((tab, ind) =>{
			tab.button.style.zIndex = length - ind;
		})
	}

	get defaults(){
		return {
			"orientation": {
				type: String,
				value: "horizontal",
				values: ["horizontal", "vertical"],
				refresh: true
			},
			"index": {
				value: 0,
				type: Number,
				refresh: true
			},
			"first-hidden": {
				type: Boolean,
				value: false,
				refresh: true
			},
			"menuModel": {
				type: Object,
				sealed: true,
				refresh: true,
				value: {}
			},
			"defaultIndex": {
                value: 0,
                type: Number,
				optional: true,
                refresh: true
			},
		}
	}
}


