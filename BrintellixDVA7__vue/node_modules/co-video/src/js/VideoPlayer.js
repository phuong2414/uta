import nav from 'nav';
import rivets from 'rivets';
import utils from 'utils';
import touch from 'touch';
import settings from 'settings';
import dispatcher from 'dispatcher';
import {Component} from 'component';

rivets.formatters.coVideoTimeToString = time => {
    time = Math.floor(time);
    return zeroPrefix(Math.floor(time / 60)) + ':' + zeroPrefix(time % 60);
};

rivets.formatters.coVideoFormatSrc = src => {
    return /\/common\//.test(src) ? settings.media + src : src;
};

function preventDefault(event) {
    event.preventDefault();
}

function stopPropagation(event) {
    event.stopPropagation();
}

function zeroPrefix(value) {
    return value < 10 ? ('0' + value) : value;
}

function addAttribute(element) {
    element.setAttribute("sealed", "");

    if (element.children.length > 0) {
        [].slice.call(element.children).forEach((element) => {
            addAttribute(element);
        });
    }
}

function isNotPlayback(currentTime, savedCurrentTime) {
    return Math.abs(Math.floor(currentTime) - Math.floor(savedCurrentTime)) === 1;
}

export class VideoPlayer extends Component {
    constructor(element, model) {
        super(...arguments);

        this.zoom = document.querySelector("co-pinch-to-zoom") || '';
        this.playing = false;
        this.player = element;
        this.currentTime = 0;
        this.duration = 0;
        this.lastTap = 0;
        this.isFullScreen = false;
        this.isInitialState = true;
        this.video = this.player.getElementsByTagName('video')[0];
        this.video.muted = this.muted;

        this.updateHideControlsStatus();

        dispatcher.subscribeAction(action => {
            if (action.type === dispatcher.ActionType.EDIT_PRESENTATION) {
                this.playing = false;
                setTimeout(() => {
                    this.playing = false; //fix autoplay on start edit mode
                }, 500)
                if (this.isFullScreen) {
                    this.exitFullScreen();
                    this.isFullScreen = false;
                }
            }
        });


        setInterval(() => {
            if (this.playing && Math.ceil(this.video.currentTime) !== Math.ceil(this.time)) {
                this.timeUpdate(); // not always dispatch event 'timeupdate' //TODO - ?
            }
        }, 500); // fix bug

        nav.onenter(() => {
            if (this.playOnSlideenter) {
                if (this.fullScreenOnPlaying) {
                    this.enterFullScreen();
                    this.isFullScreen = true;
                }
                setTimeout(() => {
                    this.playing = false;
                    this.playing = true;
                }, 0);
            }
        });

        nav.onleave(() => {
            this.playing = false;
        });
    }

    ready() {
        setTimeout(() => {
            const sliderElement = this.element.querySelector("co-slider");

            addAttribute(sliderElement);

            this.video = this.player.querySelector('video');
            this.progressBar = this.player.querySelector('.progress-bar');

            if (this.preventVideoControls) {
                this.video.addEventListener(touch.events.move, preventDefault);
            }

            ['play', 'timeupdate', 'ended', 'durationchange'].forEach(event => {
                this.video.addEventListener(event, this);
            });

            ['left', 'right'].forEach(side => {
                this.progressBar.addEventListener(`swipe${side}`, event => event.stopPropagation());
            });
            this.progressBar.addEventListener('focus', this.rewindStart.bind(this));
            this.progressBar.addEventListener('blur', this.rewindEnd.bind(this));
            this.updateLoopStatus();
        }, 0);
    }

    rewind(event, scope) {
        Math.trunc = Math.trunc || function (x) {
            if (isNaN(x)) {
                return NaN;
            }
            if (x > 0) {
                return Math.floor(x);
            }
            return Math.ceil(x);
        };
        scope.currentTime = Math.trunc(event.target.model.value);
        if (Math.trunc(scope.video.currentTime) !== Math.trunc(scope.currentTime)) {
            scope.video.currentTime = scope.currentTime;
        }
    }

    rewindStart() {
        this.isPaused = this.video.paused;
        this.playing = false;
    }

    rewindEnd() {
        if (!this.isPaused) {
            this.playing = true;
        }
    }

    addBlockSwipeVideo(element) {
        ['left', 'right'].forEach(side => {
            element.addEventListener(`swipe${side}`, stopPropagation);
        });
    }

    removeBlockSwipeVideo(element) {
        ['left', 'right'].forEach(side => {
            element.removeEventListener(`swipe${side}`, stopPropagation);
        });
    }

    handleEvent(event) {
        switch (event.type) {
            case 'play':
                this.video.parentElement.classList.remove('init');
                this.video.addEventListener('click', preventDefault);
                break;
            case 'timeupdate':
                this.timeUpdate();
                break;
            case 'ended':
                this.playing = false;
                break;
            case 'durationchange':
                this.duration = Math.round(this.pauseVideoAfterSuchTime) || this.video.duration;
                break;
        }
    }

    timeUpdate() {
        this.duration = Math.round(this.pauseVideoAfterSuchTime) || this.video.duration;
        if (this.pauseVideoAfterSuchTime) {
            if (this.currentTime === Math.round(this.pauseVideoAfterSuchTime)) {
                this.video.pause();
            }
        }
        this.trackPlayProgress();
    }

    playPause(event, scope) {

        event.stopPropagation();
        if (scope.video.ended || scope.currentTime === scope.pauseVideoAfterSuchTime) {
            scope.currentTime = 0;
            scope.video.currentTime = 0;
        }
        if (!scope.playing && !scope.isFullScreen && scope.fullScreenOnPlaying) {
            scope.enterFullScreen();
            scope.isFullScreen = true;
        }
        scope.showControls = scope.showControls !== 'hide-always' ? (scope.playing || !scope.src) : 'hide-always';
        scope.playing = !scope.playing;

        utils.dispatchEvent(scope.element, 'playpause');
    }

    toggleFullScreen(event, scope) {
        const isPlay = scope.playing;
        
        if (event.type !== "touchend") {
            event.stopPropagation();
        }

        function makeFullScreen() {
            scope.isFullScreen = !scope.isFullScreen;
            if (isPlay) {//for showing a controlls after change mode
                scope.playing = false;
            }
            scope[scope.isFullScreen ? 'enterFullScreen' : 'exitFullScreen'].call(scope);
            if (isPlay) {
                setTimeout(() => { //for showing a controlls after change mode
                    scope.playing = true;
                }, 0);
            }
            scope.progressBar.model.refresh();

            utils.dispatchEvent(scope.element, 'togglefullscreen')
        }

        if (event.target === scope.video && event.type != "dblclick") {
            let currentTime = new Date().getTime();
            let tapLength = currentTime - scope.lastTap;
            if (tapLength >= 500 && tapLength > 0) {
                // single-tap
            } else {
                // double-tap
                if (scope.zoom) {
                    scope.zoom.model.pzoom.zoomFactor = 1;
                    scope.zoom.model.pzoom.offset.x = 0;
                    scope.zoom.model.pzoom.offset.y = 0;
                    scope.zoom.model.pzoom.update();
                }
                makeFullScreen();
                event.preventDefault();
            }
            scope.lastTap = currentTime;
        } else {
            makeFullScreen()
        }
    }

    enterFullScreen() {
        this.saveStateElement = {
            parent: this.element.parentElement,
            next: this.element.nextSibling
        };
        this.saveStateElement.parent.removeChild(this.element);
        document.body.appendChild(this.element);
        this.element.classList.add('full-screen');

        if (this.checkIfClmIsIrep()) {
            this.element.classList.add('clm-irep');
        }

        this.addBlockSwipeVideo(this.element)
    }

    exitFullScreen() {
        document.body.removeChild(this.element);
        this.saveStateElement.parent.insertBefore(this.element, this.saveStateElement.next);
        this.element.classList.remove('full-screen');
        this.saveStateElement = null;
        this.removeBlockSwipeVideo(this.element)
    }

    trackPlayProgress() {
        this.currentTime = this.video.currentTime;
        this.time = this.currentTime;
        this.updateTimeOfPlaying();
    }

    updateTimeOfPlaying() {
        if (Math.floor(this.currentTime) !== this.savedCurrentTime) {
            if (!isNaN(this.savedCurrentTime) && isNotPlayback(this.currentTime, this.savedCurrentTime)) {
                this.playingDuration++;
            }
            this.savedCurrentTime = Math.floor(this.currentTime);
        }
    }

    refresh(property) {
        switch (property) {
            case 'pauseVideoAfterSuchTime':
                this.timeUpdate();
                break;
            case 'showControls':
                this.updateHideControlsStatus();
                break;
            case 'time':
                if (this.currentTime !== this.time) {
                    this.currentTime = this.video.currentTime = this.time;
                }
                break;
            case 'loop':
                this.updateLoopStatus();
                break;
            case 'muted':
                this.video.muted = this.muted;
                break;
            default:
                this.playing = false;
                this.currentTime = 0;
                this.duration = 0;
        }
    }

    updateLoopStatus() {
        this.video.loop = this.loop;
    }

    updateHideControlsStatus() {
        this.hideControls = this.showControls === 'hide-always';
    }

    checkIfClmIsIrep() {
        return settings._env.currentClm === 'irep';
    }

    get defaults() {
        return {
            playOnSlideenter: {
                type: Boolean,
                value: false
            },
            playing: {
                type: Boolean,
                value: false,
                sealed: true
            },
            time: {
                type: Number,
                value: 0,
                refresh: true,
                sealed: true
            },
            src: {
                type: "File",
                value: '',
                fileTypes: ['video'],
                refresh: true
            },
            poster: {
                type: "File",
                value: '',
                fileTypes: ['image']
            },
            showControls: {
                value: true,
                values: [true, 'hide-always'],
                type: String,
                refresh: true
            },
            loop: {
                value: false,
                type: Boolean,
                refresh: true
            },
            fullScreenOnPlaying: {
                value: false,
                type: Boolean
            },
            playingDuration: {
                type: Number,
                value: 0,
                sealed: true
            },
            pauseVideoAfterSuchTime: {
                type: Number,
                value: 0
            },
            muted: {
                type: Boolean,
                value: false,
                refresh: true
            },
            preventVideoControls: {
                type: Boolean,
                value: true,
            }
        }
    }

    template() {
        return require('../template.html');
    }
}
