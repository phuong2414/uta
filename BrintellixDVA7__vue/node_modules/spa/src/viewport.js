var utils = require('utils')
var Observer = utils.Observer
var structure = require('structure')
var spaSettings = require('spa-ctl')
var settings = require('settings')
var validate = require('validate-nav').validate
var prefixer = require('prefixer')
var touch = require('touch')
var touchCount = +spaSettings.navTouchCount || 1
var path = require('path')
var slideDir = settings.slides
var presentationIndentifier = require('presentation-identifier')
var storageStructureKey = presentationIndentifier + 'Structure'

var HORIZONTAL_DIRECTION = 'horizontal'
var VERTICAL_DIRECTION = 'vertical'

var DIRECTIONS = {
  'horizontal': ['left', 'right'],
  'vertical': ['up', 'down']
}

var ANIMATION_NEXT = 'next'
var ANIMATION_PREV = 'prev'
var ANIMATION_DIRECTIONS = {
  'horizontal': {
    prev: 'left',
    next: 'right'
  },
  'vertical': {
    prev: 'up',
    next: 'down'
  }
}

var EVENT_DIRECTION_MAP = {
  'swipeup': 'down',
  'swipedown': 'up',
  'swipeleft': 'right',
  'swiperight': 'left'
}

var NEXT = 1
var PREV = -1


var STEP = {
  'up': PREV,
  'down': NEXT,
  'left': PREV,
  'right': NEXT
}

var HORIZONTAL_EVENTS = ['swipeleft', 'swiperight']
var VERTICAL_EVENTS = ['swipeup', 'swipedown']

var REVERSE_DIRECTIONS = {
  right: 'left',
  left: 'right',
  up:'down',
  down: 'up'
}

function createFrames (ctx) {
  return ['current', 'next'].reduce(function (frames, frame) {
    var wrapper = document.createElement('div')
    var iframe = document.createElement('iframe')

    wrapper.className = 'slide ' + frame

    wrapper.appendChild(iframe)
    ctx.element.appendChild(wrapper)

    frames[frame] = {
      element: wrapper,
      iframe: iframe
    }

    return frames
  }, {})
}

function ViewPort (element, options) {
  var chapter
  var slide
  var that = this

  this.element = element
  this.canGoto = true
  this.viewport = document.getElementById('viewport')

  utils.mixin(this, options || {})

  Observer.call(this)

  Object.defineProperties(this, {
    'chapter': {
      set: function (value) {
        chapter = value
        that.slides = structure.chapters[chapter].content
        that.publish('chapterchange')
      },
      get: function () {
        return chapter
      }
    },
    'slide': {
      set: function (value) {
        slide = value
        that.index = that.slides.indexOf(slide)
        that.publish('slidechange', slide)
      },
      get: function () {
        return slide
      }
    }
  })

  this.frames = createFrames(this)

  // for navigator

  this.currentFrame = this.frames.current

  this.slideDirection = this.getDirection(settings.slide)
  this.chapterDirection = this.getDirection(settings.chapter)

  this.slideSwipeEvents = this.getActualSwipeEvents(this.slideDirection)
  this.chapterSwipeEvents = this.getActualSwipeEvents(this.chapterDirection)

  this.handlersMap = this.buildHandlersMap()
}

ViewPort.prototype = Object.create(Observer.prototype)
ViewPort.prototype.isPointerEvent = touch.isPointerEvent
ViewPort.prototype.isTouch = touch.isTouch

ViewPort.prototype.buildHandlersMap = function () {
  if (this.slideDirection === this.chapterDirection) {
    return this.setHandlersMap(this.slideSwipeEvents)
  }

  var slideHandlersMap = this.setHandlersMap(this.slideSwipeEvents)
  var chapterHandlersMap = this.setHandlersMap(this.chapterSwipeEvents)

  return utils.mixin(slideHandlersMap, chapterHandlersMap)
}

ViewPort.prototype.getDirection = function (node) {
  if (node && Boolean(node.direction)) {
    return node.direction
  }

  return HORIZONTAL_DIRECTION
}

ViewPort.prototype.getActualSwipeEvents = function (direction) {
  if (direction === HORIZONTAL_DIRECTION) {
    return HORIZONTAL_EVENTS
  } else if (direction === VERTICAL_DIRECTION) {
    return VERTICAL_EVENTS
  }
}

ViewPort.prototype.start = function (options) {
  sessionStorage.removeItem(storageStructureKey)
  validate(options)
  utils.mixin(this, options, ['chapter', 'slide'])
  this.loadFrame('current', this.slide, function () {
    this.currentFrame.iframe.contentDocument.addEventListener('slidedataloaded', this.enter.bind(this))
  }.bind(this))
}

ViewPort.prototype.enter = function () {
  this.slideReady()
  this.dispatchSlideEvent('slideenter', this.frames.current)
  this.addListeners(this.handlersMap)
}
ViewPort.prototype.exit = function () {
  this.dispatchSlideEvent('slideleave', this.frames.next)
  this.removeListeners(this.handlersMap)
}

ViewPort.prototype.change = function () {
  this.exit()
  this.enter()
  this.unloadPrevFrame();
}

ViewPort.prototype.dispatchSlideEnterToCurrentSlide = function () {
  this.dispatchSlideEvent('slideenter', this.frames.current)
}

ViewPort.prototype.dispatchSlideLeaveForCurrentSlide = function () {
  this.dispatchSlideEvent('slideleave', this.frames.current)
}

ViewPort.prototype.dispatchSlideEvent = function (event, frame) {
  var details = {detail: {slide: frame.element}}

  if (frame.iframe.id) {
    utils.dispatchEvent(frame.iframe.contentDocument, event, details)
    // TODO: describe this implicitness
    utils.dispatchEvent(document, event, details)
  }
}

ViewPort.prototype.loadFrame = function (frame, slide, onload) {
  var template

  frame = this.frames[frame].iframe
  onload = onload.bind(this)

  // TODO: maybe we should unload frame
  if (frame.id !== slide) {
    template = structure.slides[slide].template

    utils.once(frame, 'load', onload)

    frame.src = path.join(slideDir, template)
    frame.id = slide
  } else {
    this.swapFrames()
  }
}

ViewPort.prototype.goto = function (options) {
  validate(options)
  if ((this.chapter !== options.chapter || this.slide !== options.slide) && this.canGoto) {
    this.canGoto = false
    this.setAnimation(options)
    this.actualGoto(options)
  }
}

ViewPort.prototype.setAnimation = function(options){
  options.animation = !options.noTransition;

  if(options.animation){
    options.direction = this.getAnimationDirection(options);
  }
}

ViewPort.prototype.getAnimationDirection = function(options){
  var currSlide = this.slides.indexOf(this.slide)
  var targetSlide = this.slides.indexOf(options.slide)
  var chapters = structure.storyboard
  var currChapter = chapters.indexOf(this.chapter)
  var targetChapter = chapters.indexOf(options.chapter)
  var targetDirections

  if(isCurrChapter(this.chapter, options.chapter)){
    targetDirections = ANIMATION_DIRECTIONS[this.slideDirection]
    return targetDirections[targetSlide - currSlide < 0 ? ANIMATION_PREV : ANIMATION_NEXT]
  } else {
    targetDirections = ANIMATION_DIRECTIONS[this.chapterDirection]
    return targetDirections[targetChapter - currChapter < 0 ? ANIMATION_PREV : ANIMATION_NEXT]
  }
}

function isCurrChapter(current, target){
  return current === target;
}

ViewPort.prototype.actualGoto = function (options) {
  var eventOptions = {
    detail: {
      chapter: options.chapter,
      slide: options.slide
    }
  }

  this.setNavDirection(options)

  utils.dispatchEvent(this.currentFrame.iframe.contentDocument, 'willgoto', eventOptions)
  utils.dispatchEvent(document, 'willgoto', eventOptions)

  this.currentFrame = this.frames.next
  utils.mixin(this, options, ['chapter', 'slide', 'animation', 'direction'])
  this.removeListeners(this.handlersMap)
  this.prepareNextFrame()
  // TODO: it would be nice place for promises
  this.loadFrame('next', this.slide, function () {
    if (isProdClm()) {
      this.swapFrames()
    } else {
      this.onSlideDataLoaded()
    }
  }.bind(this))
}

ViewPort.prototype.onSlideDataLoaded = function() {
  this.currentFrame.iframe.contentDocument.addEventListener('slidedataloaded', function () {
    this.swapFrames()
  }.bind(this))
}

ViewPort.prototype.slideReady = function () {
  var mainSlideArticle = this.currentFrame.iframe.contentDocument.querySelector('article.slide')

  mainSlideArticle.classList.add('ready')
}

ViewPort.prototype.prepareNextFrame = function () {
  var next = this.frames.next.element

  next.classList.remove('prev')
  next.classList.remove('next')

  next.classList.add('no-trans')
  next.classList.add(STEP[this.direction] < 0 ? 'prev' : 'next')
}

ViewPort.prototype.unloadPrevFrame = function () {
  var iframe = this.frames.next.iframe;
  iframe.src = isiPlanner() ? 'data:text/html,' : '';
  iframe.id = '';
  this.canGoto = false;
  var unload = function() {
    this.canGoto = true;
  }.bind(this);

  utils.once(iframe.contentWindow, 'unload', unload)
}

ViewPort.prototype.swapFrames = function (options) {
  this.defineTransition()
  this.swapClasses()
  this.swapObjects()
  this.onSwapEnd()
}

ViewPort.prototype.defineTransition = function () {
  var method = this.animation ? 'remove' : 'add'

  this.frames.next.element.classList[method]('no-trans')
  this.frames.current.element.classList[method]('no-trans')
}

ViewPort.prototype.swapClasses = function () {
  var current = this.frames.current.element
  var next = this.frames.next.element

  current.classList.remove('current')

  this.removeEnterClass(current);

  next.classList.add('current')

  next.classList.add(this.generateEnterClass(REVERSE_DIRECTIONS[this.direction]))

  current.classList.add(STEP[this.direction] < 0 ? 'next' : 'prev')
  next.classList.remove(STEP[this.direction] < 0 ? 'prev' : 'next')
}

ViewPort.prototype.removeEnterClass = function (el) {
  Object.keys(STEP)
    .forEach(function(direction) {
      var enterClass = this.generateEnterClass(direction);

      if(el.classList.contains(enterClass)){
        el.classList.remove(enterClass);
      }
    }, this);
}

ViewPort.prototype.generateEnterClass = function (direction) {
  var way = 'enter';
  return direction + '-' + way;
}

ViewPort.prototype.swapObjects = function () {
  var temp = this.frames.current
  this.frames.current = this.frames.next
  this.frames.next = temp
}

ViewPort.prototype.onSwapEnd = function () {
  var change = this.change.bind(this)
  var current = this.frames.current.element

  if (this.animation) {
    window.getComputedStyle(current)[prefixer.getSupportedProperty('transitionDuration')] // true hack \m/
    utils.once(current, prefixer.events.animationend, change)
  } else {
    setTimeout(change, 0)
  }
}

ViewPort.prototype.setNavDirection = function (options) {
  if (!options.animation) {
    this.viewport.classList.remove(this.slideDirection)
    this.viewport.classList.remove(this.chapterDirection)
  } else if (!this.viewport.classList.contains(this.chapterDirection)) {
    this.viewport.classList.add(this.slideDirection)
  } else {
    this.setSwipeDirection(this.getSlideTransitionDirection(options))
  }
}

ViewPort.prototype.goToSibling = function (direction) {
  var isCorrectDirection = this.isCorrectDirection(direction)
  var sibling = this.getNextSibling(direction)
  var defaultOptions = {animation: true, direction: direction}

  if (sibling && this.canGoto && isCorrectDirection) {
    this.setSwipeDirection(this.getSlideTransitionDirection(sibling))
    this.canGoto = false
    this.actualGoto(utils.mixin(sibling, defaultOptions))
  } else {
    this.addListeners(this.handlersMap)
  }
}

ViewPort.prototype.isCorrectDirection = function (direction) {
  return this.isSlideDirection(direction) || this.isChapterDirection(direction)
}

ViewPort.prototype.isSlideDirection = function (direction) {
  return checkDirection(this.slideDirection, direction)
}

ViewPort.prototype.isChapterDirection = function (direction) {
  return checkDirection(this.chapterDirection, direction)
}

function checkDirection (type, direction) {
  return utils.contains(DIRECTIONS[type], direction)
}

ViewPort.prototype.getSlideTransitionDirection = function (sibling) {
  if (sibling.chapter === this.chapter) {
    return this.slideDirection
  }

  return this.chapterDirection
}

ViewPort.prototype.getNextSibling = function (direction) {
  var localSibling = this.getLocalSibling(direction)
  var isChapterFlow = this.isChapterFlow(direction)
  var isSlideFlow = this.isSlideDirection(direction)
  var crossChapterSibling = this.getCrossChapterSibling(direction, isChapterFlow)

  if (isChapterFlow) {
    return crossChapterSibling
  }

  if (localSibling) {
    return localSibling
  }

  if (isSlideFlow) {
    return crossChapterSibling
  }
}

ViewPort.prototype.isChapterFlow = function (direction) {
  return this.slideDirection !== this.chapterDirection && this.isChapterDirection(direction)
}

ViewPort.prototype.setSwipeDirection = function (direction) {
  var adverseDirection = this.getAdverseDirection(direction)

  if (this.slideDirection !== this.chapterDirection) {
    this.viewport.classList.remove(adverseDirection)
    this.viewport.classList.add(direction)
  } else {
    this.viewport.classList.add(direction)
  }
}

ViewPort.prototype.getAdverseDirection = function (direction) {
  if (direction === this.slideDirection) {
    return this.chapterDirection
  }

  return this.slideDirection
}

ViewPort.prototype.isChapterSwipe = function (eventName) {
  return !utils.contains(this.slideSwipeEvents, eventName) && utils.contains(this.chapterSwipeEvents, eventName)
}

ViewPort.prototype.getLocalSibling = function (direction) {
  var siblingSlide = this.slides[this.index + STEP[direction]]

  return siblingSlide ? {chapter: this.chapter, slide: siblingSlide} : null
}

ViewPort.prototype.getCrossChapterSibling = function (direction, isThroughChapters) {
  return this.isCrossChapterSwipe(isThroughChapters) ? this.getCrossChapterSlide(direction, isThroughChapters) : null
}

ViewPort.prototype.isCrossSiblingExists = function (isThroughChapters) {
  return !(this.slideDirection !== this.chapterDirection && !isThroughChapters)
}

// TODO: must be refactored
ViewPort.prototype.getCrossChapterSlide = function (direction, isThroughChapters) {
  var chapter = this.getCrossChapter(direction)

  if (chapter) {
    return {
      chapter: chapter.id,
      slide: this.getCrossSlide(chapter, direction, isThroughChapters)
    }
  }
}

ViewPort.prototype.isCrossChapterSwipe = function (isThroughChapters) {
  return (settings.isCrossChapterSwipe && utils.contains(structure.storyboard, this.chapter)) &&
  (this.isCrossSiblingExists(isThroughChapters) && !this.isPopup)
}

ViewPort.prototype.getCrossChapter = function (direction, stepCount) {
  var targetChapterId
  var targetChapter
  var chapterIndex

  stepCount = stepCount || STEP[direction]
  chapterIndex = structure.storyboard.indexOf(this.chapter)
  targetChapterId = structure.storyboard[chapterIndex + stepCount]
  targetChapter = structure.chapters[targetChapterId]

  if (!targetChapter) {
    return null
  }

  if (!targetChapter.content.length) {
    stepCount += STEP[direction]
    return this.getCrossChapter(direction, stepCount)
  }

  return targetChapter
}

ViewPort.prototype.getCrossSlide = function (chapter, direction, isThroughChapters) {
  if (isThroughChapters) {
    return getFirstChapterSlide(chapter)
  }

  return STEP[direction] > 0 ? getFirstChapterSlide(chapter) : getLastChapterSlide(chapter)
}

function getFirstChapterSlide (chapter) {
  return chapter.content[0]
}

function getLastChapterSlide (chapter) {
  return chapter.content[chapter.content.length - 1]
}

function isInputElementsOnSlide () {
  // fix bug in .ipa offset the input element by swipe
  var inputTags = ['INPUT', 'TEXTAREA']
  return [].some.call(document.getElementsByTagName('iframe'), function (iframe) {
    return inputTags.some(function (tag) {
      return iframe.contentDocument.getElementsByTagName(tag).length
    })
  })
}

ViewPort.prototype.swipe = function (event) {
  var direction = this.getDirectionByEvent(event)
  if (this.isRequiredTouchesCount(event.detail.touchesCount)) {
    if (this.isTouch && isInputElementsOnSlide()) {
      setTimeout(function () {
        this.goToSibling(direction)
      }.bind(this), 100)
    } else {
      this.goToSibling(direction)
    }
  }
}

ViewPort.prototype.getDirectionByEvent = function (event) {
  return EVENT_DIRECTION_MAP[event.type]
}

ViewPort.prototype.setHandlersMap = function (events) {
  var handlers = this.getMapHandlers()

  return this.getMapEvents(events)
    .reduce(function (map, event, index) {
      map[event] = handlers[index]
      return map
    }, {})
}

ViewPort.prototype.getMapHandlers = function () {
  var handlers = [
    this.swipe.bind(this),
    this.swipe.bind(this)]

  return !isMitouchSPA() ? handlers : handlers.concat([
    this.startEventHandler.bind(this),
    this.endEventHandler.bind(this),
    this.tapHandler.bind(this)
  ])
}

ViewPort.prototype.getMapEvents = function (events) {
  return !isMitouchSPA() ? events : events.concat([touch.events.start, touch.events.end, 'tap'])
}

ViewPort.prototype.startEventHandler = function (event) {
  setTimeout(function () {
    redispatchEvent(createFakeElement(event.target), event)
  }, 0)
}

ViewPort.prototype.endEventHandler = function (event) {
  this.endEvent = event
}

ViewPort.prototype.tapHandler = function (event) {
  setTimeout(function () {
    redispatchEvent(createFakeElement(event.target), this.endEvent)
  }.bind(this), 0)
}

function isMitouchSPA () {
  return settings._env.currentClm === 'mitouch-spa'
}

function isiPlanner(){
  var userAgent = navigator.userAgent
  var isiPlannerBuild = settings._env.currentClm === 'iplanner'
  var isiPad = /iPad/i.test(userAgent)
  var isSafari = userAgent.match(/Safari/i) != null
  
  return isiPlannerBuild && isiPad && !isSafari;
}

function isProdClm () {
  return settings._env.currentClm !== 'dev';
}

function createFakeElement (baseElement) {
  var fakeElement = document.createElement(baseElement.nodeName)

  Object.keys(baseElement.dataset).forEach(function (key) {
    fakeElement.dataset[key] = baseElement.dataset[key]
  })

  fakeElement.style.display = 'none'

  return fakeElement
}

function redispatchEvent (element, event) {
  var newEvent;

  if (event.touches) {
    newEvent = createTouchEvent(event);
  } else {
    newEvent = createCustomEvent(event);
  }

  document.body.appendChild(element);

  utils.once(window, event.type, function (event) {
    if (event.target === element) {
      event.stopPropagation();
    }
  })

  element.dispatchEvent(newEvent);

  setTimeout(function () {
    document.body.removeChild(element);
  }, 400)
}

function createTouchEvent (event) {
  var touchEvent
  if (window.TouchEvent instanceof Function) {
    // iOs 10
    touchEvent = new window.TouchEvent(event.type, event)
  } else {
    // iOs 9
    touchEvent = initTouchEvent(event.type)
    touchEvent.touches = event.touches
    touchEvent.changedTouches = event.changedTouches
  }
  return touchEvent
}

function initTouchEvent (eventType) {
  var newEvent
  try {
    newEvent = document.createEvent('TouchEvent')
    newEvent.initTouchEvent(eventType, true, true)
  } catch (err) {
    try {
      newEvent = document.createEvent('UIEvent')
      newEvent.initUIEvent(eventType, true, true)
    } catch (err) {
      newEvent = document.createEvent('Event')
      newEvent.initEvent(eventType, true, true)
    }
  }
  return newEvent
}

function createCustomEvent (event) {
  var newEvent;
  var eventType = event.type;

  if(eventType === 'pointerdown'){
    eventType = 'mousedown';
  }else if(eventType === 'pointerup'){
    eventType = 'mouseup';
  }

  if (typeof window.CustomEvent === 'function'){
    newEvent = new window.CustomEvent(eventType, event);
  }else{
    newEvent = document.createEvent('CustomEvent');
    newEvent.initCustomEvent(eventType, true, true);
  }

  return utils.mixin(newEvent, {
    clientX: event.clientX,
    clientY: event.clientY,
    x: event.x,
    y: event.y,
    pageX: event.pageX,
    pageY: event.pageY,
    screenX: event.screenX,
    screenY: event.screenY,
  })
}

ViewPort.prototype.addListeners = function (handlersMap) {
  this._processListeners('add', handlersMap)
}

ViewPort.prototype.removeListeners = function (handlersMap) {
  this._processListeners('remove', handlersMap)
}

ViewPort.prototype._processListeners = function (action, handlersMap) {
  var doc = this.currentFrame.iframe.contentDocument
  var events = Object.keys(handlersMap)
  var method = action + 'EventListener'

  events.forEach(function (event) {
    // doc[method](event, handlersMap[event].bind(this)); // fix bug by double swipe on android - bind() return new function
    doc[method](event, handlersMap[event])
  }, this)
}

ViewPort.prototype.isRequiredTouchesCount = function (count) {
  return !this.isTouch || count === touchCount
}

exports.ViewPort = ViewPort
