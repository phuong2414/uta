import { isObject } from 'utils';
import { Component } from 'component';
import rivets from 'rivets';
import sightglass from 'sightglass';

function configureSightglass() {
	sightglass.adapters = rivets.adapters;
	sightglass.root = rivets.rootInterface;
}

export class Collection extends Component {
	constructor(element, model, parentScope) {
		super(...arguments);

		this.iterated = [];
		this.observers = [];
		configureSightglass();
	}

	static get block() {
		return true;
	}

	get defaults() {
		return {
			items: {
				value: [],
				type: Array,
				refresh: true,
				sealed: true
			},
			as: {
				value: "item",
				type: String,
				static: true
			}
		};
	}

	init() {
		if (this.isPrerenderedCollection()) {
			this.bindPrerenderedCollectionItems();
		} else {
			this.collectionItem = this.element.getElementsByTagName("co-collection-item")[0];
			this.element.removeChild(this.collectionItem);
			this.refresh();
		}
	}

	isPrerenderedCollection() {
		return this.element.hasAttribute('prerendered');
	}

	ready(view) {
		var localExtensions = {};

		rivets._.extensions.forEach(function (extensionName) {
			localExtensions[extensionName] = view[extensionName];
		});

		this.localExtensions = localExtensions;

		this.init();
	}

	insert(data, index) {
		this.checkPrerenderdMode()

		const scope = Object.create(this.parentScope);
		
				Object.defineProperty(scope, 'index', {
					enumerable: true,
					configurable: true,
					writable: true,
					value: index
				});
				scope[this.as] = data;
		
		scope.keypath = `${this.getKeypath((keypath) => `${keypath}.items`)}.${index}`;

		const template = cloneNode(this.collectionItem);

		setCollectionItemModel(template, data, scope.keypath);

		this.element.insertBefore(template, this.element.children[index]);

		this.items.splice(index, 0, data);

		this.iterated.splice(index, 0, rivets.bind(template, scope, this.localExtensions));

		this.updateIteratedIndexes();
	}


	remove(index) {
		this.checkPrerenderdMode()

		let elementToDelete = this.element.children[index];
		this.iterated.splice(index, 1);
		this.items.splice(index, 1);
		if (elementToDelete) {
			this.element.removeChild(elementToDelete);
		}

		this.updateIteratedIndexes();
	}

	checkPrerenderdMode() {
		if (this.isPrerenderedCollection()) {
			console.warn(this.element, 'Was prerendered while build and can not be chaned dynamically. Please set dynamic="true" attribute to enable runtime editing.')
			return
		}
	}

	updateIteratedIndexes() {
		this.items.forEach((item, index) => {
			if (this.iterated[index].models.index !== index) {
				this.iterated[index].models.index = index;
			}
		})
	}

	template() {
		return require('../template.html');
	}

	refresh() {
		this.buildCollectionElements();
		this.buildIteratedViews();
	}

	buildCollectionElements() {
		this.refreshObjectCollection();
	}

	buildIteratedViews() {
		let index = 0;
		if (this.iterated.length <= this.items.length && !this.isNormalChildrenCount() && this.collectionItem) {
			for (; index < this.items.length; index++) { //TODO: "for" loop for iterated through new Array(length)
				const model = this.items[index];
				const keypath = `${this.getKeypath((keypath) => `${keypath}.items`)}.${index}`;
				let data = this.buildCollectionItemModel(index, model);

				if (data.keypath) {
					data.keypath = `${data.keypath}.${this.removeAlias(keypath)}`;
				} else {
					data.keypath = keypath;
				}

				if (!defined(this.iterated[index])) {
					let template = cloneNode(this.collectionItem);

					this.buildObservations(this.parentScope, data);
					setCollectionItemModel(template, model, keypath);
					this.iterated.push(rivets.bind(template, data, this.localExtensions));

					this.element.appendChild(template);
				} else if (this.iterated[index].models[this.as] !== model) {
					this.buildObservations(this.parentScope, data);
					this.iterated[index].update(data);
				} else if (this.iterated[index].models.index !== index) {
					this.iterated[index].models.index = index;
				}
			};
		}
	}

	bindPrerenderedCollectionItems() {
		let index = 0;
		for (; index < this.items.length; index++) { //TODO: "for" loop for iterated through new Array(length)
			const model = this.items[index];
			let data = this.buildCollectionItemModel(index, model)

			this.buildObservations(this.parentScope, data);
			this.iterated.push(rivets.bind(this.element.children[index], data, this.localExtensions));
		};
	}

	buildCollectionItemModel(index, model) {
		let data = Object.create(this.parentScope);

		Object.defineProperty(data, 'index', {
			enumerable: true,
			configurable: true,
			writable: true,
			value: index
		});

		data[this.as] = model;
		data.iteratedAlias = this.as;
		return data
	}

	buildObservations(model, data) {
		const observers = Object.keys(model)
			.filter(key => !!this.getDescriptor(model, key).get)
			.filter(key => key !== this.as)
			.map(key => {
				return sightglass(model, key, () => {
					data[key] = model[key];
				});
			});

		if (this.observers[data.index]) {
			this.unobserve(data.index);
		}
		this.observers[data.index] = observers;
	}
	
	getDescriptor(object, key) {
		return Object.getOwnPropertyDescriptor(object, key) || {};
	}

	unobserve(index) {
		this.observers[index].forEach(observer => observer.unobserve());
	}

	removeAlias(keypath) {
		return keypath.split('.').slice(1).join('.');
	}

	refreshObjectCollection() {
		this.iterated
			.filter((iteratedItem, index) => this.items.indexOf(iteratedItem.models[this.as]) === -1)
			.map(iteratedItemToRemove => this.iterated.splice(this.iterated.indexOf(iteratedItemToRemove), 1)[0])
			.forEach(viewToRemove => {
				this.unobserve(viewToRemove.models.index);
				viewToRemove.unbind();
				this.element.removeChild(viewToRemove.els[0]);
			});
	}

	// deprecated
	refreshPrimitiveCollection() {
		let difference = new Array(this.iterated.length - this.items.length),
			index = 0, view;

		for (; index < difference.length; index++) {
			view = this.iterated.pop();
			view.unbind();
			this.element.removeChild(view.els[0]);
		}
	}

	getKeypath(keypathModifier = (keypath) => keypath) {
		const modelKeypath = this.getAttribute('model');
		const itemsKeypath = this.getAttribute("items");

		return modelKeypath ? keypathModifier(modelKeypath) : itemsKeypath;
	}

	isNormalChildrenCount() {
		return this.items.length === this.element.children.length;
	}

	getAttribute(attribute) {
		return this.element.getAttribute(attribute);
	}
}

function cloneNode(node) {
	return node.cloneNode(true);
}

function defined(value) {
	return value !== undefined && value !== null;
}

function isObjectCollection(collection) {
	return collection.every(collectionItem => isObject(collectionItem));
}

function setCollectionItemModel(template, model, keypath) {
	if (isObject(model)) {
		template.setAttribute('model', keypath);
	}
}