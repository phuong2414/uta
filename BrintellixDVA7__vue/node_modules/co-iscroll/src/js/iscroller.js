import {
	Component
} from "component";
import IScroll from "iscroll/build/iscroll-probe";
import dispatcher from "dispatcher";
import utils from "utils";
import {
	events
} from "touch";
import StateIterator from './StateIterator';
import nav from 'nav';

export class Iscroller extends Component {
	constructor(element) {
		super(...arguments);
		element.style.opacity = 0;
		this.indicators = [];

		this.activateElement = (event) => {
			this.scroller.scrollToElement(event.target, 0);
		};

		this.deactivateElement = () => {
			this.scroller.x = this.xBeforeEditing;
			this.scroller.y = this.yBeforeEditing;
			this.refresh();
		}
		this.init();
	}

	addCheckOnElementListener() {
		document.addEventListener(events.move, event => {
			if (!checkOnElement(event.target, this.element)) {
				this.scroller.initiated = 0;
			}
		}, false);
	}

	ready() {
		this.observe();
		let intervalHandler;

		dispatcher.subscribeAction(action => {
			if (action.type === dispatcher.ActionType.EDIT_PRESENTATION) {
				this.isEditing = true;
				this.xBeforeEditing = this.scroller.x;
				this.yBeforeEditing = this.scroller.y;

				if (!intervalHandler) {
					clearInterval(intervalHandler);
				}

				intervalHandler = setInterval(() => {

					let rect = this.element.getBoundingClientRect();

					if (this.prevRect && (rect.width !== this.prevRect.width || rect.height !== this.prevRect.height)) {
						this.scroller.refresh();

						utils.dispatchEvent(this.element, "resize-scroll");
					}
					this.prevRect = rect;
				}, 1000)
			}
			if (action.type === dispatcher.ActionType.VIEW_PRESENTATION) {
				this.isEditing = false;

				clearInterval(intervalHandler);
			}
		})

		nav.onready(()=>{
			this.init();
		});
	}

	init() {
		this.scroller = this.createScroller();
		this.scrollToElement(this.scrollToSelector, 0);
		this.scroller.on('beforeScrollStart', () => {
			this.scrollToSelector = '';
		});
		this.element.style.removeProperty('opacity');
		this.addCheckOnElementListener();
		this.refreshScroll();
		this.setWrapperScrollTop();
	}

	createScroller() {
		this.createIndicators();
		const options = Object.assign({},
			this, {
				scrollbars: false,
				probeType: 2,
			} // disable default scrollbars
		);

		return new IScroll(this.getElement('.scroll-wrapper'), options);
	}

	createIndicators() {
		if (this.scrollbars) {
			this.indicators = [{
					el: this.getElement('.iScrollVertical'),
					listenX: false,
				},
				{
					el: this.getElement('.iScrollHorizontal'),
					listenY: false,
				}
			]
		} else {
			this.indicators = [];
		}

		this.indicators.forEach(this.updateScrollbar, this);
	}

	updateScrollbar(scrollbar) {
		scrollbar.fade = this.fadeScrollbars;
		scrollbar.interactive = this.interactiveScrollbars;
		scrollbar.resize = !this.fixedSizeScrollbars;

		// clean styles
		if (!scrollbar.resize) {
			const indicatorStyle = scrollbar.el.children[0].style;

			indicatorStyle.width = "";
			indicatorStyle.height = "";
		}

		if (!scrollbar.fade) {
			scrollbar.el.style.opacity = "";
		}
	}

	showVerticalScrollbar() {
		return this.scrollbars && this.scrollY && this.scroller && this.scroller.hasVerticalScroll;
	}

	showHorizontalScrollbar() {
		return this.scrollbars && this.scrollX && this.scroller && this.scroller.hasHorizontalScroll;
	}

	activateScrollbar() {
		if (this.classList.contains('iScrollIndicator')) {
			this.prevStateActivateIndicator = this.style.display;
			this.style = `display: block;`;
		}

		this.closest('.iScrollScrollbar').style = 'visibility: visible;';
	}

	deactivateScrollbar() {
		if (this.classList.contains('iScrollIndicator')) {
			this.style = `display: ${this.prevStateActivateIndicator};`;
		}

		this.closest('.iScrollScrollbar').style = '';
	}

	get defaults() {
		return {
			'fade-scrollbars': {
				value: false,
				type: Boolean,
				refresh: true,
				optional: true,
			},
			'fixed-size-scrollbars': {
				value: false,
				type: Boolean,
				refresh: true,
				optional: true,
			},
			'scrollbars': {
				value: true,
				type: Boolean,
				refresh: true,
			},
			'scroll-x': {
				value: true,
				type: Boolean,
				refresh: true,
			},
			'scroll-y': {
				value: true,
				type: Boolean,
				refresh: true,
			},
			'start-x': {
				value: 0,
				type: Number,
				refresh: true,
				optional: true,
				units: 'px',
			},
			'start-y': {
				value: 0,
				type: Number,
				refresh: true,
				optional: true,
				units: 'px',
			},
			'mouse-wheel': {
				value: true,
				type: Boolean,
				refresh: true,
			},
			'mouse-wheel-speed': {
				value: 20,
				type: Number,
				refresh: true,
				optional: true,
				units: 'px',
			},
			'interactive-scrollbars': {
				value: true,
				type: Boolean,
				refresh: true,
				optional: true
			},
			'momentum': {
				value: true,
				type: Boolean,
				refresh: true,
			},
			'use-transition': {
				value: true,
				type: Boolean,
				refresh: true,
				optional: true,
			},
			'bounce': {
				value: true,
				type: Boolean,
				refresh: true,
			},
			'bounce-easing': {
				value: '',
				values: ['quadratic', 'circular', 'back', 'bounce', 'elastic', ''],
				type: String,
				refresh: true,
				optional: true,
			},
			'bounce-time': {
				value: 600,
				type: Number,
				refresh: true,
				optional: true,
				units: 'ms',
			},
			'scroll-to-selector': {
				value: '',
				type: String,
				refresh: true,
				optional: true,
			},
			'snap': {
				value: '',
				type: String,
				refresh: true,
				optional: true,
			},
			"snapThreshold": {
				value: 0.334, //default value in IScroll
				type: Boolean,
				refresh: true,
			},
			'stop-propagation-swipe': {
				value: 'all',
				values: ['all', 'horizontal', 'vertical', ''],
				type: String,
				refresh: true,
				optional: true,
			},
			'preventDefault': {
				value: true,
				type: Boolean,
				refresh: false,
				optional: true,
			},
			'bindToWrapper': {
				value: true,
				type: Boolean,
				refresh: false,
				optional: true,
			},
			'currentPosition': { //need to screenshoter states
				value: {
					x: 0,
					y: 0,
				},
				type: Object,
				sealed: true,
			}
		}
	}

	template() {
		return require('../template.html');
	};

	refresh(property) {
		switch (property) {
			case 'scrollToSelector':
				this.scrollToElement(this.scrollToSelector);
				break;
			case 'stopPropagationSwipe':
				this.unlockSwipeEvents('all');
				break;
			default:
				let x = this.scroller.x;
				let y = this.scroller.y;

				this.scroller.destroy();
				this.scroller = this.createScroller();
				this.scroller.on('scroll', () => {
					utils.dispatchEvent(this.element, 'scroll');
				});

				if (property === 'scrollX' || property === 'scrollY') {
					this.scrollToElement(this.scrollToSelector, 0);
				} else if (property !== 'startX' && property !== 'startY') {
					this.scroller.scrollTo(x, y);
				}

				this.scroller.refresh();
		}
	}

	setWrapperScrollTop() {
		const { scroller: { wrapper }} = this;
		
		setTimeout(() => {
			wrapper.scrollTop = 0;
		}, 220); // init time the inside components //different outlooks 

		setTimeout(() => {
			wrapper.scrollTop = 0;
		}, 1000);
	}

	_toggleEvents(eventsType, actionType) {
		const events = {
			'all': [],
		};

		if (this.scroller.hasHorizontalScroll) {
			events.all.push('left', 'right');
		}
		if (this.scroller.hasVerticalScroll) {
			events.all.push('up', 'down');
		}

		eventsType && events[eventsType].forEach(side => {
			this.element[actionType + 'EventListener']('swipe' + side, stopSwipeEvent);
		})
	}

	lockSwipeEvents(type) {
		this._toggleEvents(type, 'add');
	}

	unlockSwipeEvents(type) {
		this._toggleEvents(type, 'remove');
	}

	observe() {
		new window.MutationObserver(() => this.refreshScroll())
			.observe(this.getElement('.scroller'), {
				childList: true,
				subtree: true,
			});
	}

	refreshScroll() {
		this.scroller.refresh();
		this.refresh('stopPropagationSwipe');
	}

	scrollToElement(selector, time = this.isEditing ? 0 : 200, offsetX = true, offsetY = true) {
		if (selector) {
			let element = getDOMElement(this.element, selector);

			this.element.contains(element) && this.scroller.scrollToElement(element, time, offsetX, offsetY);
		}
	}

	getElement(selector) {
		return this.element.querySelector(selector);
	}

	scrollTo(x, y, time = 0, easing) {
		this.scroller.scrollTo(x, y, time, easing);
	}

	nextState() {
		if (!this.stateIterator) {
			this.stateIterator = new StateIterator(this.scroller);
		}

		return this.stateIterator.next()
			.then((state) => {
				if (!state.done) {
					const { x, y } = state.value;

					this.currentPosition = state.value;
					this.scrollTo(x, y);
				}
				return state;
			})
	}
}

function stopSwipeEvent(event) {
	event.stopPropagation();
}

function getDOMElement(parentElement, selector) {
	return parentElement.querySelector(selector);
}

function checkOnElement(target, element) {
	const isTrulyThisElement = true;

	if (target === element) {
		return isTrulyThisElement;
	} else if (~[document, document.body, null].indexOf(target)) {
		return !isTrulyThisElement;
	}

	return checkOnElement(target.parentNode, element);
}
