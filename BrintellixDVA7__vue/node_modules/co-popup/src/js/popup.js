import {dispatchEvent, mixin} from 'utils'
import nav from 'nav'
import coImage from 'co-image'
import coShower from 'co-shower'

export class Popup extends coShower.constructor {
	constructor() {
		super(...arguments)
		this.element.setAttribute('container', 'container')
		this.subscribeToEvents()
		this.setId()
		this.openPopupHandler = event => this.openPopup(event)
		this.closePopupHandler = event => this.closePopup(event)
	}

	hideHandler(event) {
		if (event.popupId !== this.id) {
			super.hideHandler(event)
		}
	}

	get defaults() {
		const copy = super.defaults;

		copy['showOnSlideEnter'].optional = false;
		copy['hide-on-outside-tap'].optional = false;
		copy['hide-on-outside-tap'].optional = false;
		copy['show-on'].sealed = true;
		copy['hide-on'].sealed = true;
		copy.visible.sealed = true;

		const order = [
			'id',
			'title',
			'show-close-button',
			'showOnSlideEnter',
			'lock-swipe-when-opened',
			'hide-on-outside-tap',
			'close-button-image',
			'was-opened',
			'close-on-willgoto',
			'visible',
			'show-on',
			'hide-on',
			'show-animation',
			'hide-animation',
			'screenshotStates'
		];

		return this.sortObjectByArray(mixin({
			id: {
				value: '',
				type: String,
				refresh: true,
				sealed: true
			},
			title: {
				value: 'Popup label',
				type: String
			},
			'show-close-button': {
				type: Boolean,
				value: true
			},
			'close-button-image': {
				value: {
					src: resolve('../../media/images/close-black.png')
				},
				scheme: coImage.constructor.prototype.defaults,
				base: coImage.constructor,
				type: Object
			},
			'was-opened': {
				value: false,
				sealed: true,
				type: Boolean
			},
			'close-on-willgoto': {
				type: Boolean,
				optional: true,
				value: true
			},
			screenshotStates: {
				type: String,
				value: 'on',
				values: ['on', 'once', 'off']
			}

		}, copy), order);
	}

	sortObjectByArray(obj, orderArr) {
		return orderArr.reduce((result, key) => {
			result[key] = obj[key];
			return result;
		}, {});
	}

	template() {
		return require('../template.html')
	}

	refresh(key) {
		if (key === 'id') {
			this.setId()
		}

		super.refresh(key)
	}

	subscribeToEvents() {
		this.element.addEventListener('open', event => this.openPopupHandler(event))

		this.element.addEventListener('show', () => {
			this.dispatchEvent(this.element, 'popupenter', {
				id: this.id
			})
		})

		this.element.addEventListener('hide', () => {
			this.dispatchEvent(this.element, 'popupleave', {
				id: this.id
			})
		})

		if (this.closeOnWillgoto) {
			nav.onleave(this.deactivate.bind(this));
			nav.onwillgoto(this.deactivate.bind(this));
		}

		nav.onenter(() => {
			if (this.showOnSlideEnter) {
				this.showPopup()
			} else {
				this.hidePopup()
			}
		})
	}

	openPopup(event) {
		if (this.lockSwipeWhenOpened) {
			nav.lock();
		}
		if (!this.isAnimate) {
			this.showPopup()
			this.stopPropagation(event)
		}
	}

	closePopup(event) {
		if (this.lockSwipeWhenOpened) {
			nav.unlock();
		}
		if (!this.isAnimate) {
			this.hidePopup()
			this.stopPropagation(event)
		}
	}

	showPopup() {
		this.setPopupVisible()
		this.trackWasOpened()
	}

	setPopupVisible() {
		this.visible = true
	}

	trackWasOpened() {
		this.wasOpened = true
	}

	hidePopup() {
		this.visible = false
	}

	activate() {
		if (this.timeout) {
			clearTimeout(this.timeout);
		}
		setTimeout(() => {
			this.setPopupVisible()
			this.showElement()
		}, 0);
	}

	deactivate() {
		this.timeout = setTimeout(() => {
			this.hidePopup()
			this.hideElement()
		}, 100);
	}

	setId() {
		if (!this.id) {
			this.id = this.element.id
		}

		if (this.id) {
			this.element.dataset.eid = this.id
		} else if (this.element.dataset.eid) {
			delete this.element.dataset.eid
		}
	}

	stopPropagation(event) {
		if (event) {
			event.stopPropagation()
		}
	}

	dispatchEvent(target, eventType, options) {
		dispatchEvent(target, eventType, {
			detail: options || {}
		})
	}
}

exports.Popup = Popup
