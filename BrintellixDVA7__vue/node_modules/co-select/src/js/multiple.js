exports.init = function () {
  if (this.optionsIndex.length > 0) {
    this._refresh('optionsIndex')
  }else {
    this._refresh('selectedValues')
  }
}

exports.optionsRefresh = function (selected, options, addedOption, removedOption, indexRemovedOption) {
  let indexAdded

  if (removedOption) {
    this.removeActiveOption(indexRemovedOption)
  }

  if (addedOption) {
    indexAdded = this.options.indexOf(addedOption.model)
    this.addedNewCollectionUpper(indexAdded)

  /* if(~indexAdded){ // after added on ewizard this co-select marked as checked
      this.optionsIndex.push(indexAdded)
  } */
  }
}

exports.removeActiveOption = function (indexRemovedOption) {
  var newOptionsIndex = this.optionsIndex
    .filter((indexVal) => indexRemovedOption !== indexVal)
    .map((indexVal, index) => indexRemovedOption > -1 && indexVal > indexRemovedOption ? --indexVal : indexVal)

  this.optionsIndex = newOptionsIndex
}

exports.addedNewCollectionUpper = function (indexAdded) {
  var isChanged,
    newOptionsIndex = this.optionsIndex.map((activeIndex) => {
      if (indexAdded <= activeIndex) {
        isChanged = true
        return ++activeIndex
      }else {
        return activeIndex
      }
    })

  if (isChanged) {
    this.optionsIndex = newOptionsIndex
  }
}

exports.onOptionTap = function (event) {
  let option = event.detail
  option.toggle()
  event.stopPropagation()
}

exports.onOptionChange = function (event) {
  let option = event.detail,
    index = this.options.indexOf(option),
    indexInSelect

  if (!this.optionsIndexStateLocalChange) {
    indexInSelect = this.optionsIndex.indexOf(index)

    if (~indexInSelect) {
      this.optionsIndex.splice(indexInSelect, 1)
    }else {
      this.optionsIndex.push(index)
    }
  }
  this.optionsIndexStateLocalChange = false
  event.stopPropagation()
}

exports._refresh = function (attrName, isModel) {
  switch (attrName) {
    case 'optionsIndex': {

      let isChanges,
        selectedValues = []

      this.options.forEach((option, index) => {
        this.optionsIndexStateLocalChange = true

        if (~this.optionsIndex.indexOf(index)) {
          option.select()
          if (!(~this.selectedValues.indexOf(option.value))) {
            isChanges = true
          }
          selectedValues.push(option.value)
        }else {
          option.unselect()
          if (~this.selectedValues.indexOf(option.value)) {
            isChanges = true
          }
        }
      })

      if (isChanges || this.selectedValues.length !== this.optionsIndex.length) {
        this.selectedValues = selectedValues
        this.dispatchEvent('change', {detail: this.selectedValues})
      }

      this.optionsIndexStateLocalChange = false
      break
    }
    case 'selectedValues': {
      let isChanges,
        newIndexArray = [],
        currentInd,
        indexInAll,
        values = this.getValuesByIndexAll()

      this.selectedValues.forEach((value, index) => {

        currentInd = values.indexOf(value)

        if (!(~currentInd)) {
          isChanges = true
        }

        indexInAll = this.options.indexOf(this.getOptionByValue(value))

        if (~indexInAll) {
          newIndexArray.push(indexInAll)
        }
      })

      if (!isChanges) {
        isChanges = values.some((activeValue) => {
          return !~this.selectedValues.indexOf(activeValue)
        })
      }

      if (isChanges) {
        this.optionsIndex = newIndexArray
      }
    }
  }
}

exports.getValuesByIndexAll = function () {
  return this.optionsIndex.map((option) => {
    return this.options[option].value
  })
}
