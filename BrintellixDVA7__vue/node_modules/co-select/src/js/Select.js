import { Component } from 'component'
import * as multiple from './multiple.js'
import * as single from './single.js'
import * as utils from 'utils'
import * as selectUtils from './utils.js'

class Select extends Component {
  constructor (element, model) {
    super(...arguments)
    utils.mixin(this, this.multiple ? multiple : single)
  }

  addEventListeners () {
    setTimeout(() => {
      this.init()
      if (!selectUtils.isThisComponentInCheckbox(this.element)) {
        this.element.addEventListener('option-tap', this.onOptionTapLocalListener.bind(this))
      }
      this.element.addEventListener('option-change', this.onOptionChangeLocalListener.bind(this))
    }, 0)
  }

  ready () {
    selectUtils.observe(this.element, { childList: true, subtree: true }, this.reInitSelect.bind(this))
    this.addEventListeners()
  }

  reInitSelect (mutations) {
    if (mutations.length >= 1 && this.options) {
      let removedOption = selectUtils.getCoOptionFromCollectionItemInMutations(mutations[0].removedNodes)
      let addedOption = selectUtils.getCoOptionFromCollectionItemInMutations(mutations[0].addedNodes)
      let indexRemovedOption = removedOption ? this.getIndexActiveOption(removedOption.model) : -1

      this.options = selectUtils.getOptions(this.element)

      this.optionsRefresh(this.selected || this.selectedValues, this.options, addedOption, removedOption, indexRemovedOption)
    } else {
      this.options = selectUtils.getOptions(this.element)
    }
  }

  getIndexActiveOption (optionModel) {
    return this.options.indexOf(optionModel)
  }

  template () {
    return require('../template.html')
  };

  get defaults () {
    return {
      'multiple': {
        type: Boolean,
        value: false,
        refresh: true
      },
      'selected-values': {
        type: Array,
        value: [],
        refresh: true
      },
      'selected': {
        type: String,
        value: '',
        refresh: true
      },
      'index': {
        type: Number,
        value: -1,
        refresh: true
      },
      'options-index': {
        type: Array,
        value: [],
        refresh: true,
        sealed: true
      }
    }
  }

  dispatchEvent (eventName, options) {
    utils.dispatchEvent(this.element, eventName, options)
  };

  onOptionChangeLocalListener () {
    this.onOptionChange(...arguments)
  }

  onOptionTapLocalListener () {
    this.onOptionTap(...arguments)
  }

  refresh (attrName) {
    switch (attrName) {
      case 'multiple':
        this.clearAllData()
        utils.mixin(this, this.multiple ? multiple : single)
        break
      default:
        this._refresh(attrName)
    }
  };

  getOptionByValue (value) {
    let optionFound
    if (this.options) {
      this.options.some((option) => (option && option.value === value && (optionFound = option)))
    }
    return optionFound || null
  };

  clearAllData () {
    Object.keys(this.defaults).forEach((el) => {
      if (el !== 'multiple') {
        this[utils.toCamelCase(el)] = this.defaults[el].value
      }
    })
  }
}

export { Select, single, multiple }
