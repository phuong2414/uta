import	{Component} from "component";
import * as utils from 'utils';
import {events} from 'prefixer';
import nav from 'nav';
import AnimateBinder from "animate-binder";
import {EventManager} from "./event-manager";
import dispatcher from 'dispatcher';

export class Shower extends Component{
	constructor(){
		super(...arguments);

		this.saveEvent = null;

		this.animationModel = {};

		this.show = event => this.showHandler(event);
		this.hide = event => this.hideHandler(event);

		this.allowHide = utils.debounce(() => {
			this.forbidHide = false;
		}, 25);

		this.showManager = new EventManager(this.show);
		this.hideManager = new EventManager(this.hide);

		this.element.addEventListener(events.animationstart, this);
		this.element.addEventListener(events.animationend, this);

		nav.onenter(()=>{this.isOnleave = false;});
		nav.onleave(()=>{
			this.isOnleave = true;
			this.isAnimate = false;
		});

		this.element.addEventListener('tap', this);

		this.updateShowGlobalEvents();
		this.updateHideGlobalEvents();

		this.element.addEventListener('show', event => event.stopPropagation());
		this.element.addEventListener('hide', event => event.stopPropagation());

		this.setOutsideClose();

		this[this.showOnSlideEnter ? 'showElement' : 'hideElement']();

		if(!this.blockDispatcher){
			this.subscribeDispatcher();
		}

		document.addEventListener('resetModel', () => {
			this.visible = this.showOnSlideEnter;
		});

	}

	ready(localView){
		const fixedValue = this.element.getAttribute('fixed') ? this.element.getAttribute('fixed') + ',animation' : 'animation';
		this.element.setAttribute('fixed', fixedValue);
		localView.addBinding(this.element, 'animate', 'animationModel');
		this.animationModel.blockDispatcher = this.showAnimation.blockDispatcher || this.hideAnimation.blockDispatcher;
	}

	subscribeDispatcher(){
		dispatcher.subscribeAction((action) => {
			switch(action.type){
				case dispatcher.ActionType.EDIT_PRESENTATION:
					this.visible = this.showOnSlideEnter;
					this.saveStateVisible = this.visible;
					break;
				case dispatcher.ActionType.VIEW_PRESENTATION:
					this.deactivate();
					setTimeout(_ => {
						this.visible = this.showOnSlideEnter;
					}, 100);
					break;
				default:
					break;
			}
		});
	}

	activate(){
		this.saveStateVisible = this.visible;
		this.visible = true;
		this.showElement();
	}

	deactivate(){
		this.visible = this.saveStateVisible;
		if(!this.visible){
			this.hideElement();
		}
	}

	showHandler(event){
		if(this.saveEvent !== event && !this.visible){
			this.visible = true;
			this.saveEvent = event;
		}
	};

	hideHandler(event){
		if(this.saveEvent !== event && this.visible && !this.forbidHide){
			this.visible = false;
			if(this.lockSwipeWhenOpened){
				nav.unlock();
			}
			this.saveEvent = event;
		}
	};

	get defaults(){
		return {
			"visible": {
				value: false,
				type: Boolean,
				refresh: true
			},
			showOnSlideEnter: {
				value: false,
				type: Boolean,
				optional: true,
			},
			"show-on": {
				value: 'show',
				type: String,
				refresh: true,
				optional: true
			},
			"hide-on": {
				value: 'hide',
				type: String,
				refresh: true,
				optional: true
			},
			"show-animation": {
				value: {
					name: "fadeIn",
					duration: 0.5,
					delay: 0,
					disabled: false,
					infinite: false,
					on: "",
					initVisibility: false,
					blockDispatcher: false
				},
				scheme: AnimateBinder.prototype.defaults,
				base: AnimateBinder,
				type: Object
			},
			"hide-animation": {
				value: {
					name: "fadeOut",
					duration: 0.5,
					delay: 0,
					disabled: false,
					infinite: false,
					on: "",
					initVisibility: true,
					blockDispatcher: false
				},
				scheme: AnimateBinder.prototype.defaults,
				base: AnimateBinder,
				type: Object
			},
			"hide-on-outside-tap": {
				value: false,
				type: Boolean,
				refresh: true,
				optional: true
			},
			'lock-swipe-when-opened': {
				value: false,
				type: Boolean
			}
		}
	}

	template(){
		return require('../template.html');
	}

	handleEvent(event){
		switch(event.type){
			case 'tap':
				event.stopPropagation();
				break;
			case 'animationstart':
			case 'webkitAnimationStart':
				if(event.target === this.element){
					this.isAnimate = true;
					this.showElement();
				}
				break;
			case 'animationend':
			case 'webkitAnimationEnd':
				if(event.target === this.element){
					this.isAnimate = false;
					this.hideElement();
				}
				break;
		}
	}

	refresh(key){
		switch(key){
			case 'visible':
				if(this.element.binders.animate.isEditMode || this.isOnleave){
					if(this[key]){
						this.showElement();
					}else{
						this.hideElement();
					}
				}
				this.animateContainer();
				break;
			case 'hideOnOutsideTap':
				this.setOutsideClose();
				break;
			case 'showOn':
				this.updateShowGlobalEvents();
				break;
			case 'hideOn':
				this.updateHideGlobalEvents();
				break;
		}

	}

	animateContainer(){
		if(this.visible){
			this.showContainer();
		}else{
			this.hideContainer();
		}
	}

	isWithoutAnimation(model) {
		return !model.name || model.disabled;
	}

	showContainer(){
		this.forbidHide = true;
		this.allowHide();
		if(this.isWithoutAnimation(this.showAnimation)) {
			this.showElement();
			this.disableAnimation();
		}
		this.animateElement(this.showAnimation);
		utils.dispathEvent(this.element, "show", {cancelable: true});
	}

	hideContainer(){
		if(this.isWithoutAnimation(this.hideAnimation)) {
			this.hideElement();
			this.disableAnimation();
		}
		this.animateElement(this.hideAnimation);
		utils.dispathEvent(this.element, "hide", {cancelable: true});
	}

	disableAnimation() {
		this.animationModel.name = '';
		this.animationModel.disabled = true;
	}

	animateElement(animation) {
		this.animationModel.delay = animation.delay; // from utils.mixin a keys did not ordered
		this.animationModel.duration = animation.duration;
		this.animationModel.disabled = animation.disabled;
		utils.mixin(this.animationModel, animation);
	}

	showElement(){
		if(this.visible){
			this.element.classList.add('visible');
		}
	}

	hideElement(){
		if(!this.visible){
			this.element.classList.remove('visible');
		}
	}

	updateShowGlobalEvents(){
		this.showManager.updateListeners(this.getEvents("showOn"));
	}

	updateHideGlobalEvents(){
		this.hideManager.updateListeners(this.getEvents("hideOn"));
	}

	getEvents(type){
		return this[type] ? this[type].split(' ') : [];
	}

	setOutsideClose(){
		document[this.hideOnOutsideTap ? 'addEventListener':'removeEventListener']('tap', this.hide);
	}
}
