(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
(function (resolve){
'use strict';

var Iscroller = require('./src/js/iscroller.js').Iscroller,
    createComponent = require("component").createComponent;

module.exports = createComponent({
	name: 'co-iscroll',
	constructor: Iscroller,
	localExtensions: {
		components: {
			'co-container': require('co-container')
		}
	},
	localizationTemplate: resolve('i18n/{lang}.json')
});
require("rivets").components[module.exports.name] = module.exports;

}).call(this,function(relativePath){
			var settings = require('settings'),
				componentsDirecotry = settings.components;

			  return componentsDirecotry + '/co-iscroll/' + relativePath;
		})
},{"./src/js/iscroller.js":15,"co-container":3,"component":7,"rivets":"rivets","settings":"settings"}],2:[function(require,module,exports){
"use strict";

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var Cache = function () {
  function Cache() {
    _classCallCheck(this, Cache);

    this.storage = {};
  }

  _createClass(Cache, [{
    key: "set",
    value: function set(key, data) {
      this.storage[key] = data;
    }
  }, {
    key: "get",
    value: function get(key) {
      return this.storage[key];
    }
  }, {
    key: "isCache",
    value: function isCache(key) {
      return Object.prototype.hasOwnProperty.call(this.storage, key);
    }
  }]);

  return Cache;
}();

module.exports = Cache;

},{}],3:[function(require,module,exports){
(function (resolve){
'use strict';

var createComponent = require('component').createComponent,
    Container = require('./src/js/Container.js').Container;

module.exports = createComponent({
	name: 'co-container',
	constructor: Container,
	localizationTemplate: resolve('i18n/{lang}.json')
});

}).call(this,function(relativePath){
			var settings = require('settings'),
				componentsDirecotry = settings.components;

			  return componentsDirecotry + '/co-iscroll/_assets/co-container/' + relativePath;
		})
},{"./src/js/Container.js":4,"component":7,"settings":"settings"}],4:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.Container = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _component = require('component');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Container = exports.Container = function (_Component) {
	_inherits(Container, _Component);

	function Container() {
		_classCallCheck(this, Container);

		var _this = _possibleConstructorReturn(this, (Container.__proto__ || Object.getPrototypeOf(Container)).apply(this, arguments));

		if (_this.element.getAttribute('container') === 'false') {
			_this.element.removeAttribute('container');
		} else {
			_this.element.setAttribute('container', 'true');
		}
		return _this;
	}

	_createClass(Container, [{
		key: 'template',
		value: function template() {
			return require("../template.html");
		}
	}, {
		key: 'defaults',
		get: function get() {
			return {};
		}
	}]);

	return Container;
}(_component.Component);

},{"../template.html":5,"component":7}],5:[function(require,module,exports){
module.exports = '<content co-container=""></content>'
},{}],6:[function(require,module,exports){
module.exports={
	"localizationPath": "components/{name}/i18n/{lang}.json"
}
},{}],7:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var rivets = require('rivets');
var utils = require('utils');
var ComponentConstructor = require('./src/js/ComponentConstructor.js').ComponentConstructor;
var buildModel = require('./src/js/buildModel.js');
var buildObservations = require('./src/js/buildObservations.js');
var config = require('./config.json');

function registerComponent(name, Constructor, localExtensions) {
  rivets.components[name] = createComponent(name, Constructor, localExtensions);
}

function createComponent(options, Constructor, localExtensions) {
  var name;

  if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object') {
    name = options.name;
    Constructor = options.constructor;
    localExtensions = options.localExtensions;
  } else {
    name = options;
  }

  Constructor.prototype.localizationTemplate = options.localizationTemplate || config.localizationPath;

  var descriptor = {
    name: name,
    block: Constructor.block,
    static: getStaticProperties(Constructor.prototype.defaults),
    template: Constructor.prototype.template,
    constructor: Constructor,
    initialize: function initialize(element, data) {
      var defaultProperties = utils.toCamelCaseObject(Constructor.prototype.defaults);
      var model = buildModel(defaultProperties, data, name);
      var componentInstance = new Constructor(element, model, this.view, this);

      Constructor.prototype.name = name;

      buildObservations.call(this, componentInstance, defaultProperties, data.model || {});

      return componentInstance;
    },
    unbind: function unbind() {
      // TODO: make unobserve..
    }
  };

  if (localExtensions) {
    rivets._.extensions.forEach(function (extensionName) {
      var extension = localExtensions[extensionName];

      if (extension) {
        descriptor[extensionName] = extension;
      }
    });
  }

  return descriptor;
}

function getStaticProperties(properties) {
  return Object.keys(properties).filter(function (property) {
    return isStaticProperty(properties, property);
  }).map(function (property) {
    return utils.toCamelCase(property);
  });
}

function isStaticProperty(properties, property) {
  return properties[property] && properties[property].static;
}

module.exports = registerComponent;
module.exports.createComponent = createComponent;
module.exports.Component = ComponentConstructor;

},{"./config.json":6,"./src/js/ComponentConstructor.js":8,"./src/js/buildModel.js":11,"./src/js/buildObservations.js":12,"rivets":"rivets","utils":"utils"}],8:[function(require,module,exports){
'use strict';

var _Promise = typeof Promise === 'undefined' ? require('es6-promise').Promise : Promise;

var utils = require('utils');
var builKeypath = require('./buildKeypath.js');
var getLocalizationByConstructor = require('./buildLocalization.js');
var generalModel = require('general-model');
var dispatcher = require('dispatcher');

function ComponentConstructor(element, model, view, binding) {
  this.element = element;
  this.parentScope = view.models;
  utils.mixin(this, model);
  this.element.model = this;
  this.element.view = {
    subscribe: subscribeToView.bind(this)
  };
  this.element.setAttribute('co-component', '');
  this.model = model;
  this.view = view;
  this.binding = binding;
  this.element.addEventListener('activate', handleActivation.bind(this));
  this.element.addEventListener('deactivate', handleDeactivation.bind(this));

  this.setIsConfigurable();
}

ComponentConstructor.prototype.isCommon = function () {
  return getParentKeypathes(this).some(function (keypath) {
    return utils.startsWith(keypath, 'm.common');
  });
};

ComponentConstructor.prototype.getTextElementsByProperty = function (property) {
  return utils.toArray(this.element.querySelectorAll('[rv-html]')).filter(function (element) {
    return element.getAttribute('rv-html') === property;
  }).filter(function (element) {
    return element.scope === this;
  }, this);
};

ComponentConstructor.prototype.getLocalization = function (lang) {
  return getLocalizationByConstructor(this.__proto__.constructor, lang);
};

ComponentConstructor.prototype.getAbsoluteKeypath = function () {
  return builKeypath(this.parentScope, this.getKeypath());
};

ComponentConstructor.prototype.getKeypath = function () {
  return this.element.getAttribute('model') || '';
};

ComponentConstructor.prototype.toJSON = function () {
  var that = this;
  return Object.keys(this).reduce(function (acc, property) {
    if (that.model.hasOwnProperty(property)) {
      acc[property] = that[property];
    }
    return acc;
  }, {});
};

ComponentConstructor.prototype.setIsConfigurable = function () {
  var keypath = this.getKeypath();
  Object.defineProperty(this, 'isConfigurable', {
    value: utils.startsWith(keypath, 'm.'),
    enumerable: true,
    configurable: false,
    writable: true
  });
};

ComponentConstructor.prototype.getLabel = function (lang) {
  return new _Promise(function (resolve, reject) {
    var label = getLabelFromElement(this.element);

    if (label) {
      resolve(label);
    } else {
      getLocalizationByConstructor(this.__proto__.constructor, lang).then(function (localization) {
        resolve(localization.name);
      }).catch(function (err) {
        resolve(getNameFromTagNameComponent(this.name || this.element.tagName.toLowerCase()));
      }.bind(this));
    }
  }.bind(this));
};

ComponentConstructor.prototype.setLabel = function (label) {
  this.element.setAttribute('user-label', label);
};

ComponentConstructor.prototype.subscribe = function (callback) {
  return new generalModel.ModelNotifier().observe(this.model).subscribe(function (model) {
    callback(model);
  }, true);
};

function getNameFromTagNameComponent(coTagName) {
  var normalName = coTagName.replace('co-', '').split('-').join(' ');

  return normalName[0].toUpperCase() + normalName.substring(1, normalName.lenght);
}

function handleActivation(event) {
  if (typeof this.activate === 'function' && isCobaltEvent(event)) {
    var prevModelState = utils.parse(this);
    this.activate(event.target);
    this.difference = utils.difference(prevModelState, utils.parse(this));
  }
}

function handleDeactivation(event) {
  if (typeof this.deactivate === 'function' && isCobaltEvent(event)) {
    this.deactivate(event.target);
  }

  utils.deepMixin(this, this.difference);
}

function isCobaltEvent(event) {
  return event.detail && !!event.detail.isCobaltEvent;
}

function getParentKeypathes(scope, keypathes) {
  keypathes = keypathes || [];
  if (scope && typeof scope.getKeypath === 'function') {
    keypathes.push(scope.getKeypath());
    getParentKeypathes(scope.parentScope, keypathes);
  }

  return keypathes;
}

function getLabelFromElement(element) {
  return element.getAttribute('user-label');
}

function subscribeToView(callback) {
  var _this = this;

  dispatcher.subscribeEvent(function (event) {
    if (event.type === dispatcher.EventType.DOM_REFRESHED && event.element === _this.element) {
      callback(_this.element);
    }
  });
}

exports.ComponentConstructor = ComponentConstructor;

},{"./buildKeypath.js":9,"./buildLocalization.js":10,"dispatcher":"dispatcher","es6-promise":"es6-promise","general-model":"general-model","utils":"utils"}],9:[function(require,module,exports){
'use strict';

function buildAbsoluteKeypath(parentPath, keypath) {
	var key = removeAlias(keypath);

	if (parentPath) {
		return key ? parentPath + '.' + removeAlias(keypath) : parentPath;
	} else {
		return keypath;
	}
}

function collectParentsKeypath(model, keypathes) {
	keypathes = keypathes || [];
	if (model && model.keypath) {
		keypathes.unshift(keypathModifier(model), model.index);
		collectParentsKeypath(model.__proto__, keypathes);
	}

	return keypathes;
}

function keypathModifier(model) {
	if (model.__proto__.keypath) {
		return removeAlias(model.keypath);
	}

	return model.keypath;
}

function removeAlias(keypath) {
	return keypath.split('.').slice(1).join('.');
}

module.exports = function (parentScope, keypath) {
	return buildAbsoluteKeypath(collectParentsKeypath(parentScope).join('.'), keypath);
};

},{}],10:[function(require,module,exports){
'use strict';

var _loader = require('loader');

var _utils = require('utils');

var _cache = require('cache');

var _cache2 = _interopRequireDefault(_cache);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _Promise = typeof Promise === 'undefined' ? require('es6-promise').Promise : Promise;

var cache = new _cache2.default();

module.exports = getLocalizationByConstructor;

function getLocalizationByConstructor(constructor, outsideLang) {
  var defaultLang = 'en';
  var lang = outsideLang || defaultLang;
  // TODO: works only if localizationTemplate and name were added to the prototype during component registration

  return getLocalization(constructor, lang, defaultLang).then(function (localization) {
    return extendLocalizationByScheme(localization.defaults, constructor.prototype.defaults, lang).then(function () {
      return localization;
    });
  });
}

function getLocalization(constructor, lang, defaultLang) {
  var localizationPath = getLocalizationPath(constructor, lang);

  return loadLocalizationData(localizationPath).then(function (localization) {
    if (isLocalization(localization)) {
      return localization;
    } else if (lang !== defaultLang) {
      var defaultLocalizationPath = getLocalizationPath(constructor, defaultLang);
      return loadLocalizationData(defaultLocalizationPath);
    }
    return _Promise.resolve({});
  });
}

function getLocalizationPath(constructor, lang) {
  return (0, _utils.template)(constructor.prototype.localizationTemplate, { name: constructor.prototype.name, lang: lang });
}

function loadLocalizationData(path) {
  var loadFromCache = true;
  var reviver = null;

  if (!cache.isCache(path)) {
    cache.set(path, (0, _loader.loadJSON)(path, reviver, loadFromCache));
  }

  return cache.get(path);
}

function isLocalization(localization) {
  return localization && Object.keys(localization).length;
}

// if property described in scheme has 'base' defined, it's localization is extended with localization from 'base'
function extendLocalizationByScheme(localization, scheme, lang) {
  var localizationPromises = [];

  var _loop = function _loop(prop) {
    var propertyDescriptor = scheme[prop],
        localizationLoadingPromise = void 0;

    if (propertyDescriptor.sealed) {
      return 'continue';
    }

    if (propertyDescriptor.base) {
      localizationLoadingPromise = getLocalizationByConstructor(propertyDescriptor.base, lang).then(function (subLocalization) {
        return localization[prop].defaults = subLocalization.defaults;
      });
    } else if (propertyDescriptor.scheme) {
      localizationLoadingPromise = extendLocalizationByScheme(localization[prop].defaults, propertyDescriptor.scheme, lang);
    } else {
      return 'continue';
    }
    localizationPromises.push(localizationLoadingPromise);
  };

  for (var prop in scheme) {
    var _ret = _loop(prop);

    if (_ret === 'continue') continue;
  }

  return _Promise.all(localizationPromises);
}

},{"cache":2,"es6-promise":"es6-promise","loader":"loader","utils":"utils"}],11:[function(require,module,exports){
"use strict";

var utils = require("utils");

function buildModel(defaultProperties, data, name) {
	var defaultModel = getDefaultModel(defaultProperties),
	    elementModel = utils.toCamelCaseObject(data.model || {}),
	    attributesData = getDataFromAttributes(defaultProperties, data),
	    model = mixin(mixin(defaultModel, elementModel, defaultProperties), attributesData, defaultProperties);

	return model;
}

function mixin(target, source, defaultProperties) {
	Object.keys(source).forEach(function (property) {
		if (source.hasOwnProperty(property) && defined(source[property]) && defaultProperties.hasOwnProperty(property)) {
			if (target[property] && target[property].constructor === Object) {
				addMissingProperies(defaultProperties[property].value, source[property]); // add missing properties and keep reference for correct observing
			}
			target[property] = source[property];
		}
	});

	return target;
}

function addMissingProperies(defaultProperties, source) {
	return Object.keys(defaultProperties).forEach(function (property) {
		if (!source.hasOwnProperty(property)) {
			source[property] = defaultProperties[property];
		}
	});
}

function getDefaultModel(defaultProperties) {
	return Object.keys(defaultProperties).reduce(function (acc, property) {
		acc[property] = defaultProperties[property].value;
		return acc;
	}, {});
}

function getDataFromAttributes(defaultProperties, data) {
	return Object.keys(defaultProperties).reduce(function (acc, property) {
		if (data.hasOwnProperty(property)) {
			if (defaultProperties[property] && defaultProperties[property].static) {
				acc[property] = utils.revive(data[property]);
			} else {
				acc[property] = data[property];
			}
		}
		return acc;
	}, {});
}

function defined(value) {
	return value !== undefined && value !== null;
}

module.exports = buildModel;

},{"utils":"utils"}],12:[function(require,module,exports){
'use strict';

var generalModel = require('general-model');
var complexProperties = [Object, Array, DataView, 'Object', 'Array', 'DataView'];

module.exports = function buildObservations(componentInstance, defaultProperties, model) {
  Object.keys(defaultProperties).forEach(function (property) {
    model[property] = componentInstance[property];

    if (isRefreshableProperty(defaultProperties, property) && isComplexProperty(defaultProperties, property)) {
      observeComplexProperty(property, componentInstance);
    }

    this.observe(componentInstance, property, function () {
      if (isRefreshableProperty(defaultProperties, property)) {
        componentInstance.refresh(property);
      }
      componentInstance.model[property] = componentInstance[property];
      model[property] = componentInstance[property];
    });

    this.observe(componentInstance.model, property, function () {
      componentInstance[property] = componentInstance.model[property];
    });

    this.observe(model, property, function () {
      componentInstance[property] = model[property];
    });
  }, this);
};

function observeComplexProperty(property, componentInstance) {
  // setTimeout because nested bindings...
  setTimeout(function () {
    new generalModel.ModelNotifier().deepObserve(componentInstance, property).subscribe(function (model) {
      componentInstance.refresh(property);
    }, true);
  }, 50);
}

function isComplexProperty(defaultProperties, property) {
  var isComplexProp = complexProperties.indexOf(defaultProperties[property].type) !== -1;
  return !isComplexProp ? Array.isArray(defaultProperties[property].type) : isComplexProp;
}

function isRefreshableProperty(defaultProperties, property) {
  return !!defaultProperties[property].refresh;
}

},{"general-model":"general-model"}],13:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*! iScroll v5.2.0 ~ (c) 2008-2016 Matteo Spinelli ~ http://cubiq.org/license */
(function (window, document, Math) {
	var rAF = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) {
		window.setTimeout(callback, 1000 / 60);
	};

	var utils = function () {
		var me = {};

		var _elementStyle = document.createElement('div').style;
		var _vendor = function () {
			var vendors = ['t', 'webkitT', 'MozT', 'msT', 'OT'],
			    transform,
			    i = 0,
			    l = vendors.length;

			for (; i < l; i++) {
				transform = vendors[i] + 'ransform';
				if (transform in _elementStyle) return vendors[i].substr(0, vendors[i].length - 1);
			}

			return false;
		}();

		function _prefixStyle(style) {
			if (_vendor === false) return false;
			if (_vendor === '') return style;
			return _vendor + style.charAt(0).toUpperCase() + style.substr(1);
		}

		me.getTime = Date.now || function getTime() {
			return new Date().getTime();
		};

		me.extend = function (target, obj) {
			for (var i in obj) {
				target[i] = obj[i];
			}
		};

		me.addEvent = function (el, type, fn, capture) {
			el.addEventListener(type, fn, !!capture);
		};

		me.removeEvent = function (el, type, fn, capture) {
			el.removeEventListener(type, fn, !!capture);
		};

		me.prefixPointerEvent = function (pointerEvent) {
			return window.MSPointerEvent ? 'MSPointer' + pointerEvent.charAt(7).toUpperCase() + pointerEvent.substr(8) : pointerEvent;
		};

		me.momentum = function (current, start, time, lowerMargin, wrapperSize, deceleration) {
			var distance = current - start,
			    speed = Math.abs(distance) / time,
			    destination,
			    duration;

			deceleration = deceleration === undefined ? 0.0006 : deceleration;

			destination = current + speed * speed / (2 * deceleration) * (distance < 0 ? -1 : 1);
			duration = speed / deceleration;

			if (destination < lowerMargin) {
				destination = wrapperSize ? lowerMargin - wrapperSize / 2.5 * (speed / 8) : lowerMargin;
				distance = Math.abs(destination - current);
				duration = distance / speed;
			} else if (destination > 0) {
				destination = wrapperSize ? wrapperSize / 2.5 * (speed / 8) : 0;
				distance = Math.abs(current) + destination;
				duration = distance / speed;
			}

			return {
				destination: Math.round(destination),
				duration: duration
			};
		};

		var _transform = _prefixStyle('transform');

		me.extend(me, {
			hasTransform: _transform !== false,
			hasPerspective: _prefixStyle('perspective') in _elementStyle,
			hasTouch: 'ontouchstart' in window,
			hasPointer: !!(window.PointerEvent || window.MSPointerEvent), // IE10 is prefixed
			hasTransition: _prefixStyle('transition') in _elementStyle
		});

		/*
  This should find all Android browsers lower than build 535.19 (both stock browser and webview)
  - galaxy S2 is ok
     - 2.3.6 : `AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1`
     - 4.0.4 : `AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30`
    - galaxy S3 is badAndroid (stock brower, webview)
      `AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30`
    - galaxy S4 is badAndroid (stock brower, webview)
      `AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30`
    - galaxy S5 is OK
      `AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Mobile Safari/537.36 (Chrome/)`
    - galaxy S6 is OK
      `AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Mobile Safari/537.36 (Chrome/)`
   */
		me.isBadAndroid = function () {
			var appVersion = window.navigator.appVersion;
			// Android browser is not a chrome browser.
			if (/Android/.test(appVersion) && !/Chrome\/\d/.test(appVersion)) {
				var safariVersion = appVersion.match(/Safari\/(\d+.\d)/);
				if (safariVersion && (typeof safariVersion === 'undefined' ? 'undefined' : _typeof(safariVersion)) === "object" && safariVersion.length >= 2) {
					return parseFloat(safariVersion[1]) < 535.19;
				} else {
					return true;
				}
			} else {
				return false;
			}
		}();

		me.extend(me.style = {}, {
			transform: _transform,
			transitionTimingFunction: _prefixStyle('transitionTimingFunction'),
			transitionDuration: _prefixStyle('transitionDuration'),
			transitionDelay: _prefixStyle('transitionDelay'),
			transformOrigin: _prefixStyle('transformOrigin')
		});

		me.hasClass = function (e, c) {
			var re = new RegExp("(^|\\s)" + c + "(\\s|$)");
			return re.test(e.className);
		};

		me.addClass = function (e, c) {
			if (me.hasClass(e, c)) {
				return;
			}

			var newclass = e.className.split(' ');
			newclass.push(c);
			e.className = newclass.join(' ');
		};

		me.removeClass = function (e, c) {
			if (!me.hasClass(e, c)) {
				return;
			}

			var re = new RegExp("(^|\\s)" + c + "(\\s|$)", 'g');
			e.className = e.className.replace(re, ' ');
		};

		me.offset = function (el) {
			var left = -el.offsetLeft,
			    top = -el.offsetTop;

			// jshint -W084
			while (el = el.offsetParent) {
				left -= el.offsetLeft;
				top -= el.offsetTop;
			}
			// jshint +W084

			return {
				left: left,
				top: top
			};
		};

		me.preventDefaultException = function (el, exceptions) {
			for (var i in exceptions) {
				if (exceptions[i].test(el[i])) {
					return true;
				}
			}

			return false;
		};

		me.extend(me.eventType = {}, {
			touchstart: 1,
			touchmove: 1,
			touchend: 1,

			mousedown: 2,
			mousemove: 2,
			mouseup: 2,

			pointerdown: 3,
			pointermove: 3,
			pointerup: 3,

			MSPointerDown: 3,
			MSPointerMove: 3,
			MSPointerUp: 3
		});

		me.extend(me.ease = {}, {
			quadratic: {
				style: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)',
				fn: function fn(k) {
					return k * (2 - k);
				}
			},
			circular: {
				style: 'cubic-bezier(0.1, 0.57, 0.1, 1)', // Not properly "circular" but this looks better, it should be (0.075, 0.82, 0.165, 1)
				fn: function fn(k) {
					return Math.sqrt(1 - --k * k);
				}
			},
			back: {
				style: 'cubic-bezier(0.175, 0.885, 0.32, 1.275)',
				fn: function fn(k) {
					var b = 4;
					return (k = k - 1) * k * ((b + 1) * k + b) + 1;
				}
			},
			bounce: {
				style: '',
				fn: function fn(k) {
					if ((k /= 1) < 1 / 2.75) {
						return 7.5625 * k * k;
					} else if (k < 2 / 2.75) {
						return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;
					} else if (k < 2.5 / 2.75) {
						return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;
					} else {
						return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;
					}
				}
			},
			elastic: {
				style: '',
				fn: function fn(k) {
					var f = 0.22,
					    e = 0.4;

					if (k === 0) {
						return 0;
					}
					if (k == 1) {
						return 1;
					}

					return e * Math.pow(2, -10 * k) * Math.sin((k - f / 4) * (2 * Math.PI) / f) + 1;
				}
			}
		});

		me.tap = function (e, eventName) {
			var ev = document.createEvent('Event');
			ev.initEvent(eventName, true, true);
			ev.pageX = e.pageX;
			ev.pageY = e.pageY;
			e.target.dispatchEvent(ev);
		};

		me.click = function (e) {
			var target = e.target,
			    ev;

			if (!/(SELECT|INPUT|TEXTAREA)/i.test(target.tagName)) {
				ev = document.createEvent('MouseEvents');
				ev.initMouseEvent('click', true, true, e.view, 1, target.screenX, target.screenY, target.clientX, target.clientY, e.ctrlKey, e.altKey, e.shiftKey, e.metaKey, 0, null);

				ev._constructed = true;
				target.dispatchEvent(ev);
			}
		};

		return me;
	}();
	function IScroll(el, options) {
		this.wrapper = typeof el == 'string' ? document.querySelector(el) : el;
		this.scroller = this.wrapper.children[0];
		this.scrollerStyle = this.scroller.style; // cache style for better performance

		this.options = {

			resizeScrollbars: true,

			mouseWheelSpeed: 20,

			snapThreshold: 0.334,

			// INSERT POINT: OPTIONS
			disablePointer: !utils.hasPointer,
			disableTouch: utils.hasPointer || !utils.hasTouch,
			disableMouse: utils.hasPointer || utils.hasTouch,
			startX: 0,
			startY: 0,
			scrollY: true,
			directionLockThreshold: 5,
			momentum: true,

			bounce: true,
			bounceTime: 600,
			bounceEasing: '',

			preventDefault: true,
			preventDefaultException: { tagName: /^(INPUT|TEXTAREA|BUTTON|SELECT)$/ },

			HWCompositing: true,
			useTransition: true,
			useTransform: true,
			bindToWrapper: typeof window.onmousedown === "undefined"
		};

		for (var i in options) {
			this.options[i] = options[i];
		}

		// Normalize options
		this.translateZ = this.options.HWCompositing && utils.hasPerspective ? ' translateZ(0)' : '';

		this.options.useTransition = utils.hasTransition && this.options.useTransition;
		this.options.useTransform = utils.hasTransform && this.options.useTransform;

		this.options.eventPassthrough = this.options.eventPassthrough === true ? 'vertical' : this.options.eventPassthrough;
		this.options.preventDefault = !this.options.eventPassthrough && this.options.preventDefault;

		// If you want eventPassthrough I have to lock one of the axes
		this.options.scrollY = this.options.eventPassthrough == 'vertical' ? false : this.options.scrollY;
		this.options.scrollX = this.options.eventPassthrough == 'horizontal' ? false : this.options.scrollX;

		// With eventPassthrough we also need lockDirection mechanism
		this.options.freeScroll = this.options.freeScroll && !this.options.eventPassthrough;
		this.options.directionLockThreshold = this.options.eventPassthrough ? 0 : this.options.directionLockThreshold;

		this.options.bounceEasing = typeof this.options.bounceEasing == 'string' ? utils.ease[this.options.bounceEasing] || utils.ease.circular : this.options.bounceEasing;

		this.options.resizePolling = this.options.resizePolling === undefined ? 60 : this.options.resizePolling;

		if (this.options.tap === true) {
			this.options.tap = 'tap';
		}

		if (this.options.shrinkScrollbars == 'scale') {
			this.options.useTransition = false;
		}

		this.options.invertWheelDirection = this.options.invertWheelDirection ? -1 : 1;

		// INSERT POINT: NORMALIZATION

		// Some defaults
		this.x = 0;
		this.y = 0;
		this.directionX = 0;
		this.directionY = 0;
		this._events = {};

		// INSERT POINT: DEFAULTS

		this._init();
		this.refresh();

		this.scrollTo(this.options.startX, this.options.startY);
		this.enable();
	}

	IScroll.prototype = {
		version: '5.2.0',

		_init: function _init() {
			this._initEvents();

			if (this.options.scrollbars || this.options.indicators) {
				this._initIndicators();
			}

			if (this.options.mouseWheel) {
				this._initWheel();
			}

			if (this.options.snap) {
				this._initSnap();
			}

			if (this.options.keyBindings) {
				this._initKeys();
			}

			// INSERT POINT: _init
		},

		destroy: function destroy() {
			this._initEvents(true);
			clearTimeout(this.resizeTimeout);
			this.resizeTimeout = null;
			this._execEvent('destroy');
		},

		_transitionEnd: function _transitionEnd(e) {
			if (e.target != this.scroller || !this.isInTransition) {
				return;
			}

			this._transitionTime();
			if (!this.resetPosition(this.options.bounceTime)) {
				this.isInTransition = false;
				this._execEvent('scrollEnd');
			}
		},

		_start: function _start(e) {
			// React to left mouse button only
			if (utils.eventType[e.type] != 1) {
				// for button property
				// http://unixpapa.com/js/mouse.html
				var button;
				if (!e.which) {
					/* IE case */
					button = e.button < 2 ? 0 : e.button == 4 ? 1 : 2;
				} else {
					/* All others */
					button = e.button;
				}
				if (button !== 0) {
					return;
				}
			}

			if (!this.enabled || this.initiated && utils.eventType[e.type] !== this.initiated) {
				return;
			}

			if (this.options.preventDefault && !utils.isBadAndroid && !utils.preventDefaultException(e.target, this.options.preventDefaultException)) {
				e.preventDefault();
			}

			var point = e.touches ? e.touches[0] : e,
			    pos;

			this.initiated = utils.eventType[e.type];
			this.moved = false;
			this.distX = 0;
			this.distY = 0;
			this.directionX = 0;
			this.directionY = 0;
			this.directionLocked = 0;

			this.startTime = utils.getTime();

			if (this.options.useTransition && this.isInTransition) {
				this._transitionTime();
				this.isInTransition = false;
				pos = this.getComputedPosition();
				this._translate(Math.round(pos.x), Math.round(pos.y));
				this._execEvent('scrollEnd');
			} else if (!this.options.useTransition && this.isAnimating) {
				this.isAnimating = false;
				this._execEvent('scrollEnd');
			}

			this.startX = this.x;
			this.startY = this.y;
			this.absStartX = this.x;
			this.absStartY = this.y;
			this.pointX = point.pageX;
			this.pointY = point.pageY;

			this._execEvent('beforeScrollStart');
		},

		_move: function _move(e) {
			if (!this.enabled || utils.eventType[e.type] !== this.initiated) {
				return;
			}

			if (this.options.preventDefault) {
				// increases performance on Android? TODO: check!
				e.preventDefault();
			}

			var point = e.touches ? e.touches[0] : e,
			    deltaX = point.pageX - this.pointX,
			    deltaY = point.pageY - this.pointY,
			    timestamp = utils.getTime(),
			    newX,
			    newY,
			    absDistX,
			    absDistY;

			this.pointX = point.pageX;
			this.pointY = point.pageY;

			this.distX += deltaX;
			this.distY += deltaY;
			absDistX = Math.abs(this.distX);
			absDistY = Math.abs(this.distY);

			// We need to move at least 10 pixels for the scrolling to initiate
			if (timestamp - this.endTime > 300 && absDistX < 10 && absDistY < 10) {
				return;
			}

			// If you are scrolling in one direction lock the other
			if (!this.directionLocked && !this.options.freeScroll) {
				if (absDistX > absDistY + this.options.directionLockThreshold) {
					this.directionLocked = 'h'; // lock horizontally
				} else if (absDistY >= absDistX + this.options.directionLockThreshold) {
					this.directionLocked = 'v'; // lock vertically
				} else {
					this.directionLocked = 'n'; // no lock
				}
			}

			if (this.directionLocked == 'h') {
				if (this.options.eventPassthrough == 'vertical') {
					e.preventDefault();
				} else if (this.options.eventPassthrough == 'horizontal') {
					this.initiated = false;
					return;
				}

				deltaY = 0;
			} else if (this.directionLocked == 'v') {
				if (this.options.eventPassthrough == 'horizontal') {
					e.preventDefault();
				} else if (this.options.eventPassthrough == 'vertical') {
					this.initiated = false;
					return;
				}

				deltaX = 0;
			}

			deltaX = this.hasHorizontalScroll ? deltaX : 0;
			deltaY = this.hasVerticalScroll ? deltaY : 0;

			newX = this.x + deltaX;
			newY = this.y + deltaY;

			// Slow down if outside of the boundaries
			if (newX > 0 || newX < this.maxScrollX) {
				newX = this.options.bounce ? this.x + deltaX / 3 : newX > 0 ? 0 : this.maxScrollX;
			}
			if (newY > 0 || newY < this.maxScrollY) {
				newY = this.options.bounce ? this.y + deltaY / 3 : newY > 0 ? 0 : this.maxScrollY;
			}

			this.directionX = deltaX > 0 ? -1 : deltaX < 0 ? 1 : 0;
			this.directionY = deltaY > 0 ? -1 : deltaY < 0 ? 1 : 0;

			if (!this.moved) {
				this._execEvent('scrollStart');
			}

			this.moved = true;

			this._translate(newX, newY);

			/* REPLACE START: _move */

			if (timestamp - this.startTime > 300) {
				this.startTime = timestamp;
				this.startX = this.x;
				this.startY = this.y;
			}

			/* REPLACE END: _move */
		},

		_end: function _end(e) {
			if (!this.enabled || utils.eventType[e.type] !== this.initiated) {
				return;
			}

			if (this.options.preventDefault && !utils.preventDefaultException(e.target, this.options.preventDefaultException)) {
				e.preventDefault();
			}

			var point = e.changedTouches ? e.changedTouches[0] : e,
			    momentumX,
			    momentumY,
			    duration = utils.getTime() - this.startTime,
			    newX = Math.round(this.x),
			    newY = Math.round(this.y),
			    distanceX = Math.abs(newX - this.startX),
			    distanceY = Math.abs(newY - this.startY),
			    time = 0,
			    easing = '';

			this.isInTransition = 0;
			this.initiated = 0;
			this.endTime = utils.getTime();

			// reset if we are outside of the boundaries
			if (this.resetPosition(this.options.bounceTime)) {
				return;
			}

			this.scrollTo(newX, newY); // ensures that the last position is rounded

			// we scrolled less than 10 pixels
			if (!this.moved) {
				if (this.options.tap) {
					utils.tap(e, this.options.tap);
				}

				if (this.options.click) {
					utils.click(e);
				}

				this._execEvent('scrollCancel');
				return;
			}

			if (this._events.flick && duration < 200 && distanceX < 100 && distanceY < 100) {
				this._execEvent('flick');
				return;
			}

			// start momentum animation if needed
			if (this.options.momentum && duration < 300) {
				momentumX = this.hasHorizontalScroll ? utils.momentum(this.x, this.startX, duration, this.maxScrollX, this.options.bounce ? this.wrapperWidth : 0, this.options.deceleration) : { destination: newX, duration: 0 };
				momentumY = this.hasVerticalScroll ? utils.momentum(this.y, this.startY, duration, this.maxScrollY, this.options.bounce ? this.wrapperHeight : 0, this.options.deceleration) : { destination: newY, duration: 0 };
				newX = momentumX.destination;
				newY = momentumY.destination;
				time = Math.max(momentumX.duration, momentumY.duration);
				this.isInTransition = 1;
			}

			if (this.options.snap) {
				var snap = this._nearestSnap(newX, newY);
				this.currentPage = snap;
				time = this.options.snapSpeed || Math.max(Math.max(Math.min(Math.abs(newX - snap.x), 1000), Math.min(Math.abs(newY - snap.y), 1000)), 300);
				newX = snap.x;
				newY = snap.y;

				this.directionX = 0;
				this.directionY = 0;
				easing = this.options.bounceEasing;
			}

			// INSERT POINT: _end

			if (newX != this.x || newY != this.y) {
				// change easing function when scroller goes out of the boundaries
				if (newX > 0 || newX < this.maxScrollX || newY > 0 || newY < this.maxScrollY) {
					easing = utils.ease.quadratic;
				}

				this.scrollTo(newX, newY, time, easing);
				return;
			}

			this._execEvent('scrollEnd');
		},

		_resize: function _resize() {
			var that = this;

			clearTimeout(this.resizeTimeout);

			this.resizeTimeout = setTimeout(function () {
				that.refresh();
			}, this.options.resizePolling);
		},

		resetPosition: function resetPosition(time) {
			var x = this.x,
			    y = this.y;

			time = time || 0;

			if (!this.hasHorizontalScroll || this.x > 0) {
				x = 0;
			} else if (this.x < this.maxScrollX) {
				x = this.maxScrollX;
			}

			if (!this.hasVerticalScroll || this.y > 0) {
				y = 0;
			} else if (this.y < this.maxScrollY) {
				y = this.maxScrollY;
			}

			if (x == this.x && y == this.y) {
				return false;
			}

			this.scrollTo(x, y, time, this.options.bounceEasing);

			return true;
		},

		disable: function disable() {
			this.enabled = false;
		},

		enable: function enable() {
			this.enabled = true;
		},

		refresh: function refresh() {
			var rf = this.wrapper.offsetHeight; // Force reflow

			this.wrapperWidth = this.wrapper.clientWidth;
			this.wrapperHeight = this.wrapper.clientHeight;

			/* REPLACE START: refresh */

			this.scrollerWidth = this.scroller.offsetWidth;
			this.scrollerHeight = this.scroller.offsetHeight;

			this.maxScrollX = this.wrapperWidth - this.scrollerWidth;
			this.maxScrollY = this.wrapperHeight - this.scrollerHeight;

			/* REPLACE END: refresh */

			this.hasHorizontalScroll = this.options.scrollX && this.maxScrollX < 0;
			this.hasVerticalScroll = this.options.scrollY && this.maxScrollY < 0;

			if (!this.hasHorizontalScroll) {
				this.maxScrollX = 0;
				this.scrollerWidth = this.wrapperWidth;
			}

			if (!this.hasVerticalScroll) {
				this.maxScrollY = 0;
				this.scrollerHeight = this.wrapperHeight;
			}

			this.endTime = 0;
			this.directionX = 0;
			this.directionY = 0;

			this.wrapperOffset = utils.offset(this.wrapper);

			this._execEvent('refresh');

			this.resetPosition();

			// INSERT POINT: _refresh
		},

		on: function on(type, fn) {
			if (!this._events[type]) {
				this._events[type] = [];
			}

			this._events[type].push(fn);
		},

		off: function off(type, fn) {
			if (!this._events[type]) {
				return;
			}

			var index = this._events[type].indexOf(fn);

			if (index > -1) {
				this._events[type].splice(index, 1);
			}
		},

		_execEvent: function _execEvent(type) {
			if (!this._events[type]) {
				return;
			}

			var i = 0,
			    l = this._events[type].length;

			if (!l) {
				return;
			}

			for (; i < l; i++) {
				this._events[type][i].apply(this, [].slice.call(arguments, 1));
			}
		},

		scrollBy: function scrollBy(x, y, time, easing) {
			x = this.x + x;
			y = this.y + y;
			time = time || 0;

			this.scrollTo(x, y, time, easing);
		},

		scrollTo: function scrollTo(x, y, time, easing) {
			easing = easing || utils.ease.circular;

			this.isInTransition = this.options.useTransition && time > 0;
			var transitionType = this.options.useTransition && easing.style;
			if (!time || transitionType) {
				if (transitionType) {
					this._transitionTimingFunction(easing.style);
					this._transitionTime(time);
				}
				this._translate(x, y);
			} else {
				this._animate(x, y, time, easing.fn);
			}
		},

		scrollToElement: function scrollToElement(el, time, offsetX, offsetY, easing) {
			el = el.nodeType ? el : this.scroller.querySelector(el);

			if (!el) {
				return;
			}

			var pos = utils.offset(el);

			pos.left -= this.wrapperOffset.left;
			pos.top -= this.wrapperOffset.top;

			// if offsetX/Y are true we center the element to the screen
			if (offsetX === true) {
				offsetX = Math.round(el.offsetWidth / 2 - this.wrapper.offsetWidth / 2);
			}
			if (offsetY === true) {
				offsetY = Math.round(el.offsetHeight / 2 - this.wrapper.offsetHeight / 2);
			}

			pos.left -= offsetX || 0;
			pos.top -= offsetY || 0;

			pos.left = pos.left > 0 ? 0 : pos.left < this.maxScrollX ? this.maxScrollX : pos.left;
			pos.top = pos.top > 0 ? 0 : pos.top < this.maxScrollY ? this.maxScrollY : pos.top;

			time = time === undefined || time === null || time === 'auto' ? Math.max(Math.abs(this.x - pos.left), Math.abs(this.y - pos.top)) : time;

			this.scrollTo(pos.left, pos.top, time, easing);
		},

		_transitionTime: function _transitionTime(time) {
			time = time || 0;

			var durationProp = utils.style.transitionDuration;
			this.scrollerStyle[durationProp] = time + 'ms';

			if (!time && utils.isBadAndroid) {
				this.scrollerStyle[durationProp] = '0.0001ms';
				// remove 0.0001ms
				var self = this;
				rAF(function () {
					if (self.scrollerStyle[durationProp] === '0.0001ms') {
						self.scrollerStyle[durationProp] = '0s';
					}
				});
			}

			if (this.indicators) {
				for (var i = this.indicators.length; i--;) {
					this.indicators[i].transitionTime(time);
				}
			}

			// INSERT POINT: _transitionTime
		},

		_transitionTimingFunction: function _transitionTimingFunction(easing) {
			this.scrollerStyle[utils.style.transitionTimingFunction] = easing;

			if (this.indicators) {
				for (var i = this.indicators.length; i--;) {
					this.indicators[i].transitionTimingFunction(easing);
				}
			}

			// INSERT POINT: _transitionTimingFunction
		},

		_translate: function _translate(x, y) {
			if (this.options.useTransform) {

				/* REPLACE START: _translate */

				this.scrollerStyle[utils.style.transform] = 'translate(' + x + 'px,' + y + 'px)' + this.translateZ;

				/* REPLACE END: _translate */
			} else {
				x = Math.round(x);
				y = Math.round(y);
				this.scrollerStyle.left = x + 'px';
				this.scrollerStyle.top = y + 'px';
			}

			this.x = x;
			this.y = y;

			if (this.indicators) {
				for (var i = this.indicators.length; i--;) {
					this.indicators[i].updatePosition();
				}
			}

			// INSERT POINT: _translate
		},

		_initEvents: function _initEvents(remove) {
			var eventType = remove ? utils.removeEvent : utils.addEvent,
			    target = this.options.bindToWrapper ? this.wrapper : window;

			eventType(window, 'orientationchange', this);
			eventType(window, 'resize', this);

			if (this.options.click) {
				eventType(this.wrapper, 'click', this, true);
			}

			if (!this.options.disableMouse) {
				eventType(this.wrapper, 'mousedown', this);
				eventType(target, 'mousemove', this);
				eventType(target, 'mousecancel', this);
				eventType(target, 'mouseup', this);
			}

			if (utils.hasPointer && !this.options.disablePointer) {
				eventType(this.wrapper, utils.prefixPointerEvent('pointerdown'), this);
				eventType(target, utils.prefixPointerEvent('pointermove'), this);
				eventType(target, utils.prefixPointerEvent('pointercancel'), this);
				eventType(target, utils.prefixPointerEvent('pointerup'), this);
			}

			if (utils.hasTouch && !this.options.disableTouch) {
				eventType(this.wrapper, 'touchstart', this);
				eventType(target, 'touchmove', this);
				eventType(target, 'touchcancel', this);
				eventType(target, 'touchend', this);
			}

			eventType(this.scroller, 'transitionend', this);
			eventType(this.scroller, 'webkitTransitionEnd', this);
			eventType(this.scroller, 'oTransitionEnd', this);
			eventType(this.scroller, 'MSTransitionEnd', this);
		},

		getComputedPosition: function getComputedPosition() {
			var matrix = window.getComputedStyle(this.scroller, null),
			    x,
			    y;

			if (this.options.useTransform) {
				matrix = matrix[utils.style.transform].split(')')[0].split(', ');
				x = +(matrix[12] || matrix[4]);
				y = +(matrix[13] || matrix[5]);
			} else {
				x = +matrix.left.replace(/[^-\d.]/g, '');
				y = +matrix.top.replace(/[^-\d.]/g, '');
			}

			return { x: x, y: y };
		},
		_initIndicators: function _initIndicators() {
			var interactive = this.options.interactiveScrollbars,
			    customStyle = typeof this.options.scrollbars != 'string',
			    indicators = [],
			    indicator;

			var that = this;

			this.indicators = [];

			if (this.options.scrollbars) {
				// Vertical scrollbar
				if (this.options.scrollY) {
					indicator = {
						el: createDefaultScrollbar('v', interactive, this.options.scrollbars),
						interactive: interactive,
						defaultScrollbars: true,
						customStyle: customStyle,
						resize: this.options.resizeScrollbars,
						shrink: this.options.shrinkScrollbars,
						fade: this.options.fadeScrollbars,
						listenX: false
					};

					this.wrapper.appendChild(indicator.el);
					indicators.push(indicator);
				}

				// Horizontal scrollbar
				if (this.options.scrollX) {
					indicator = {
						el: createDefaultScrollbar('h', interactive, this.options.scrollbars),
						interactive: interactive,
						defaultScrollbars: true,
						customStyle: customStyle,
						resize: this.options.resizeScrollbars,
						shrink: this.options.shrinkScrollbars,
						fade: this.options.fadeScrollbars,
						listenY: false
					};

					this.wrapper.appendChild(indicator.el);
					indicators.push(indicator);
				}
			}

			if (this.options.indicators) {
				// TODO: check concat compatibility
				indicators = indicators.concat(this.options.indicators);
			}

			for (var i = indicators.length; i--;) {
				this.indicators.push(new Indicator(this, indicators[i]));
			}

			// TODO: check if we can use array.map (wide compatibility and performance issues)
			function _indicatorsMap(fn) {
				if (that.indicators) {
					for (var i = that.indicators.length; i--;) {
						fn.call(that.indicators[i]);
					}
				}
			}

			if (this.options.fadeScrollbars) {
				this.on('scrollEnd', function () {
					_indicatorsMap(function () {
						this.fade();
					});
				});

				this.on('scrollCancel', function () {
					_indicatorsMap(function () {
						this.fade();
					});
				});

				this.on('scrollStart', function () {
					_indicatorsMap(function () {
						this.fade(1);
					});
				});

				this.on('beforeScrollStart', function () {
					_indicatorsMap(function () {
						this.fade(1, true);
					});
				});
			}

			this.on('refresh', function () {
				_indicatorsMap(function () {
					this.refresh();
				});
			});

			this.on('destroy', function () {
				_indicatorsMap(function () {
					this.destroy();
				});

				delete this.indicators;
			});
		},

		_initWheel: function _initWheel() {
			utils.addEvent(this.wrapper, 'wheel', this);
			utils.addEvent(this.wrapper, 'mousewheel', this);
			utils.addEvent(this.wrapper, 'DOMMouseScroll', this);

			this.on('destroy', function () {
				clearTimeout(this.wheelTimeout);
				this.wheelTimeout = null;
				utils.removeEvent(this.wrapper, 'wheel', this);
				utils.removeEvent(this.wrapper, 'mousewheel', this);
				utils.removeEvent(this.wrapper, 'DOMMouseScroll', this);
			});
		},

		_wheel: function _wheel(e) {
			if (!this.enabled) {
				return;
			}

			e.preventDefault();

			var wheelDeltaX,
			    wheelDeltaY,
			    newX,
			    newY,
			    that = this;

			if (this.wheelTimeout === undefined) {
				that._execEvent('scrollStart');
			}

			// Execute the scrollEnd event after 400ms the wheel stopped scrolling
			clearTimeout(this.wheelTimeout);
			this.wheelTimeout = setTimeout(function () {
				if (!that.options.snap) {
					that._execEvent('scrollEnd');
				}
				that.wheelTimeout = undefined;
			}, 400);

			if ('deltaX' in e) {
				if (e.deltaMode === 1) {
					wheelDeltaX = -e.deltaX * this.options.mouseWheelSpeed;
					wheelDeltaY = -e.deltaY * this.options.mouseWheelSpeed;
				} else {
					wheelDeltaX = -e.deltaX;
					wheelDeltaY = -e.deltaY;
				}
			} else if ('wheelDeltaX' in e) {
				wheelDeltaX = e.wheelDeltaX / 120 * this.options.mouseWheelSpeed;
				wheelDeltaY = e.wheelDeltaY / 120 * this.options.mouseWheelSpeed;
			} else if ('wheelDelta' in e) {
				wheelDeltaX = wheelDeltaY = e.wheelDelta / 120 * this.options.mouseWheelSpeed;
			} else if ('detail' in e) {
				wheelDeltaX = wheelDeltaY = -e.detail / 3 * this.options.mouseWheelSpeed;
			} else {
				return;
			}

			wheelDeltaX *= this.options.invertWheelDirection;
			wheelDeltaY *= this.options.invertWheelDirection;

			if (!this.hasVerticalScroll) {
				wheelDeltaX = wheelDeltaY;
				wheelDeltaY = 0;
			}

			if (this.options.snap) {
				newX = this.currentPage.pageX;
				newY = this.currentPage.pageY;

				if (wheelDeltaX > 0) {
					newX--;
				} else if (wheelDeltaX < 0) {
					newX++;
				}

				if (wheelDeltaY > 0) {
					newY--;
				} else if (wheelDeltaY < 0) {
					newY++;
				}

				this.goToPage(newX, newY);

				return;
			}

			newX = this.x + Math.round(this.hasHorizontalScroll ? wheelDeltaX : 0);
			newY = this.y + Math.round(this.hasVerticalScroll ? wheelDeltaY : 0);

			this.directionX = wheelDeltaX > 0 ? -1 : wheelDeltaX < 0 ? 1 : 0;
			this.directionY = wheelDeltaY > 0 ? -1 : wheelDeltaY < 0 ? 1 : 0;

			if (newX > 0) {
				newX = 0;
			} else if (newX < this.maxScrollX) {
				newX = this.maxScrollX;
			}

			if (newY > 0) {
				newY = 0;
			} else if (newY < this.maxScrollY) {
				newY = this.maxScrollY;
			}

			this.scrollTo(newX, newY, 0);

			// INSERT POINT: _wheel
		},

		_initSnap: function _initSnap() {
			this.currentPage = {};

			if (typeof this.options.snap == 'string') {
				this.options.snap = this.scroller.querySelectorAll(this.options.snap);
			}

			this.on('refresh', function () {
				var i = 0,
				    l,
				    m = 0,
				    n,
				    cx,
				    cy,
				    x = 0,
				    y,
				    stepX = this.options.snapStepX || this.wrapperWidth,
				    stepY = this.options.snapStepY || this.wrapperHeight,
				    el;

				this.pages = [];

				if (!this.wrapperWidth || !this.wrapperHeight || !this.scrollerWidth || !this.scrollerHeight) {
					return;
				}

				if (this.options.snap === true) {
					cx = Math.round(stepX / 2);
					cy = Math.round(stepY / 2);

					while (x > -this.scrollerWidth) {
						this.pages[i] = [];
						l = 0;
						y = 0;

						while (y > -this.scrollerHeight) {
							this.pages[i][l] = {
								x: Math.max(x, this.maxScrollX),
								y: Math.max(y, this.maxScrollY),
								width: stepX,
								height: stepY,
								cx: x - cx,
								cy: y - cy
							};

							y -= stepY;
							l++;
						}

						x -= stepX;
						i++;
					}
				} else {
					el = this.options.snap;
					l = el.length;
					n = -1;

					for (; i < l; i++) {
						if (i === 0 || el[i].offsetLeft <= el[i - 1].offsetLeft) {
							m = 0;
							n++;
						}

						if (!this.pages[m]) {
							this.pages[m] = [];
						}

						x = Math.max(-el[i].offsetLeft, this.maxScrollX);
						y = Math.max(-el[i].offsetTop, this.maxScrollY);
						cx = x - Math.round(el[i].offsetWidth / 2);
						cy = y - Math.round(el[i].offsetHeight / 2);

						this.pages[m][n] = {
							x: x,
							y: y,
							width: el[i].offsetWidth,
							height: el[i].offsetHeight,
							cx: cx,
							cy: cy
						};

						if (x > this.maxScrollX) {
							m++;
						}
					}
				}

				this.goToPage(this.currentPage.pageX || 0, this.currentPage.pageY || 0, 0);

				// Update snap threshold if needed
				if (this.options.snapThreshold % 1 === 0) {
					this.snapThresholdX = this.options.snapThreshold;
					this.snapThresholdY = this.options.snapThreshold;
				} else {
					this.snapThresholdX = Math.round(this.pages[this.currentPage.pageX][this.currentPage.pageY].width * this.options.snapThreshold);
					this.snapThresholdY = Math.round(this.pages[this.currentPage.pageX][this.currentPage.pageY].height * this.options.snapThreshold);
				}
			});

			this.on('flick', function () {
				var time = this.options.snapSpeed || Math.max(Math.max(Math.min(Math.abs(this.x - this.startX), 1000), Math.min(Math.abs(this.y - this.startY), 1000)), 300);

				this.goToPage(this.currentPage.pageX + this.directionX, this.currentPage.pageY + this.directionY, time);
			});
		},

		_nearestSnap: function _nearestSnap(x, y) {
			if (!this.pages.length) {
				return { x: 0, y: 0, pageX: 0, pageY: 0 };
			}

			var i = 0,
			    l = this.pages.length,
			    m = 0;

			// Check if we exceeded the snap threshold
			if (Math.abs(x - this.absStartX) < this.snapThresholdX && Math.abs(y - this.absStartY) < this.snapThresholdY) {
				return this.currentPage;
			}

			if (x > 0) {
				x = 0;
			} else if (x < this.maxScrollX) {
				x = this.maxScrollX;
			}

			if (y > 0) {
				y = 0;
			} else if (y < this.maxScrollY) {
				y = this.maxScrollY;
			}

			for (; i < l; i++) {
				if (x >= this.pages[i][0].cx) {
					x = this.pages[i][0].x;
					break;
				}
			}

			l = this.pages[i].length;

			for (; m < l; m++) {
				if (y >= this.pages[0][m].cy) {
					y = this.pages[0][m].y;
					break;
				}
			}

			if (i == this.currentPage.pageX) {
				i += this.directionX;

				if (i < 0) {
					i = 0;
				} else if (i >= this.pages.length) {
					i = this.pages.length - 1;
				}

				x = this.pages[i][0].x;
			}

			if (m == this.currentPage.pageY) {
				m += this.directionY;

				if (m < 0) {
					m = 0;
				} else if (m >= this.pages[0].length) {
					m = this.pages[0].length - 1;
				}

				y = this.pages[0][m].y;
			}

			return {
				x: x,
				y: y,
				pageX: i,
				pageY: m
			};
		},

		goToPage: function goToPage(x, y, time, easing) {
			easing = easing || this.options.bounceEasing;

			if (x >= this.pages.length) {
				x = this.pages.length - 1;
			} else if (x < 0) {
				x = 0;
			}

			if (y >= this.pages[x].length) {
				y = this.pages[x].length - 1;
			} else if (y < 0) {
				y = 0;
			}

			var posX = this.pages[x][y].x,
			    posY = this.pages[x][y].y;

			time = time === undefined ? this.options.snapSpeed || Math.max(Math.max(Math.min(Math.abs(posX - this.x), 1000), Math.min(Math.abs(posY - this.y), 1000)), 300) : time;

			this.currentPage = {
				x: posX,
				y: posY,
				pageX: x,
				pageY: y
			};

			this.scrollTo(posX, posY, time, easing);
		},

		next: function next(time, easing) {
			var x = this.currentPage.pageX,
			    y = this.currentPage.pageY;

			x++;

			if (x >= this.pages.length && this.hasVerticalScroll) {
				x = 0;
				y++;
			}

			this.goToPage(x, y, time, easing);
		},

		prev: function prev(time, easing) {
			var x = this.currentPage.pageX,
			    y = this.currentPage.pageY;

			x--;

			if (x < 0 && this.hasVerticalScroll) {
				x = 0;
				y--;
			}

			this.goToPage(x, y, time, easing);
		},

		_initKeys: function _initKeys(e) {
			// default key bindings
			var keys = {
				pageUp: 33,
				pageDown: 34,
				end: 35,
				home: 36,
				left: 37,
				up: 38,
				right: 39,
				down: 40
			};
			var i;

			// if you give me characters I give you keycode
			if (_typeof(this.options.keyBindings) == 'object') {
				for (i in this.options.keyBindings) {
					if (typeof this.options.keyBindings[i] == 'string') {
						this.options.keyBindings[i] = this.options.keyBindings[i].toUpperCase().charCodeAt(0);
					}
				}
			} else {
				this.options.keyBindings = {};
			}

			for (i in keys) {
				this.options.keyBindings[i] = this.options.keyBindings[i] || keys[i];
			}

			utils.addEvent(window, 'keydown', this);

			this.on('destroy', function () {
				utils.removeEvent(window, 'keydown', this);
			});
		},

		_key: function _key(e) {
			if (!this.enabled) {
				return;
			}

			var snap = this.options.snap,
			    // we are using this alot, better to cache it
			newX = snap ? this.currentPage.pageX : this.x,
			    newY = snap ? this.currentPage.pageY : this.y,
			    now = utils.getTime(),
			    prevTime = this.keyTime || 0,
			    acceleration = 0.250,
			    pos;

			if (this.options.useTransition && this.isInTransition) {
				pos = this.getComputedPosition();

				this._translate(Math.round(pos.x), Math.round(pos.y));
				this.isInTransition = false;
			}

			this.keyAcceleration = now - prevTime < 200 ? Math.min(this.keyAcceleration + acceleration, 50) : 0;

			switch (e.keyCode) {
				case this.options.keyBindings.pageUp:
					if (this.hasHorizontalScroll && !this.hasVerticalScroll) {
						newX += snap ? 1 : this.wrapperWidth;
					} else {
						newY += snap ? 1 : this.wrapperHeight;
					}
					break;
				case this.options.keyBindings.pageDown:
					if (this.hasHorizontalScroll && !this.hasVerticalScroll) {
						newX -= snap ? 1 : this.wrapperWidth;
					} else {
						newY -= snap ? 1 : this.wrapperHeight;
					}
					break;
				case this.options.keyBindings.end:
					newX = snap ? this.pages.length - 1 : this.maxScrollX;
					newY = snap ? this.pages[0].length - 1 : this.maxScrollY;
					break;
				case this.options.keyBindings.home:
					newX = 0;
					newY = 0;
					break;
				case this.options.keyBindings.left:
					newX += snap ? -1 : 5 + this.keyAcceleration >> 0;
					break;
				case this.options.keyBindings.up:
					newY += snap ? 1 : 5 + this.keyAcceleration >> 0;
					break;
				case this.options.keyBindings.right:
					newX -= snap ? -1 : 5 + this.keyAcceleration >> 0;
					break;
				case this.options.keyBindings.down:
					newY -= snap ? 1 : 5 + this.keyAcceleration >> 0;
					break;
				default:
					return;
			}

			if (snap) {
				this.goToPage(newX, newY);
				return;
			}

			if (newX > 0) {
				newX = 0;
				this.keyAcceleration = 0;
			} else if (newX < this.maxScrollX) {
				newX = this.maxScrollX;
				this.keyAcceleration = 0;
			}

			if (newY > 0) {
				newY = 0;
				this.keyAcceleration = 0;
			} else if (newY < this.maxScrollY) {
				newY = this.maxScrollY;
				this.keyAcceleration = 0;
			}

			this.scrollTo(newX, newY, 0);

			this.keyTime = now;
		},

		_animate: function _animate(destX, destY, duration, easingFn) {
			var that = this,
			    startX = this.x,
			    startY = this.y,
			    startTime = utils.getTime(),
			    destTime = startTime + duration;

			function step() {
				var now = utils.getTime(),
				    newX,
				    newY,
				    easing;

				if (now >= destTime) {
					that.isAnimating = false;
					that._translate(destX, destY);

					if (!that.resetPosition(that.options.bounceTime)) {
						that._execEvent('scrollEnd');
					}

					return;
				}

				now = (now - startTime) / duration;
				easing = easingFn(now);
				newX = (destX - startX) * easing + startX;
				newY = (destY - startY) * easing + startY;
				that._translate(newX, newY);

				if (that.isAnimating) {
					rAF(step);
				}
			}

			this.isAnimating = true;
			step();
		},
		handleEvent: function handleEvent(e) {
			switch (e.type) {
				case 'touchstart':
				case 'pointerdown':
				case 'MSPointerDown':
				case 'mousedown':
					this._start(e);
					break;
				case 'touchmove':
				case 'pointermove':
				case 'MSPointerMove':
				case 'mousemove':
					this._move(e);
					break;
				case 'touchend':
				case 'pointerup':
				case 'MSPointerUp':
				case 'mouseup':
				case 'touchcancel':
				case 'pointercancel':
				case 'MSPointerCancel':
				case 'mousecancel':
					this._end(e);
					break;
				case 'orientationchange':
				case 'resize':
					this._resize();
					break;
				case 'transitionend':
				case 'webkitTransitionEnd':
				case 'oTransitionEnd':
				case 'MSTransitionEnd':
					this._transitionEnd(e);
					break;
				case 'wheel':
				case 'DOMMouseScroll':
				case 'mousewheel':
					this._wheel(e);
					break;
				case 'keydown':
					this._key(e);
					break;
				case 'click':
					if (this.enabled && !e._constructed) {
						e.preventDefault();
						e.stopPropagation();
					}
					break;
			}
		}
	};
	function createDefaultScrollbar(direction, interactive, type) {
		var scrollbar = document.createElement('div'),
		    indicator = document.createElement('div');

		if (type === true) {
			scrollbar.style.cssText = 'position:absolute;z-index:9999';
			indicator.style.cssText = '-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;position:absolute;background:rgba(0,0,0,0.5);border:1px solid rgba(255,255,255,0.9);border-radius:3px';
		}

		indicator.className = 'iScrollIndicator';

		if (direction == 'h') {
			if (type === true) {
				scrollbar.style.cssText += ';height:7px;left:2px;right:2px;bottom:0';
				indicator.style.height = '100%';
			}
			scrollbar.className = 'iScrollHorizontalScrollbar';
		} else {
			if (type === true) {
				scrollbar.style.cssText += ';width:7px;bottom:2px;top:2px;right:1px';
				indicator.style.width = '100%';
			}
			scrollbar.className = 'iScrollVerticalScrollbar';
		}

		scrollbar.style.cssText += ';overflow:hidden';

		if (!interactive) {
			scrollbar.style.pointerEvents = 'none';
		}

		scrollbar.appendChild(indicator);

		return scrollbar;
	}

	function Indicator(scroller, options) {
		this.wrapper = typeof options.el == 'string' ? document.querySelector(options.el) : options.el;
		this.wrapperStyle = this.wrapper.style;
		this.indicator = this.wrapper.children[0];
		this.indicatorStyle = this.indicator.style;
		this.scroller = scroller;

		this.options = {
			listenX: true,
			listenY: true,
			interactive: false,
			resize: true,
			defaultScrollbars: false,
			shrink: false,
			fade: false,
			speedRatioX: 0,
			speedRatioY: 0
		};

		for (var i in options) {
			this.options[i] = options[i];
		}

		this.sizeRatioX = 1;
		this.sizeRatioY = 1;
		this.maxPosX = 0;
		this.maxPosY = 0;

		if (this.options.interactive) {
			if (!this.options.disableTouch) {
				utils.addEvent(this.indicator, 'touchstart', this);
				utils.addEvent(window, 'touchend', this);
			}
			if (!this.options.disablePointer) {
				utils.addEvent(this.indicator, utils.prefixPointerEvent('pointerdown'), this);
				utils.addEvent(window, utils.prefixPointerEvent('pointerup'), this);
			}
			if (!this.options.disableMouse) {
				utils.addEvent(this.indicator, 'mousedown', this);
				utils.addEvent(window, 'mouseup', this);
			}
		}

		if (this.options.fade) {
			this.wrapperStyle[utils.style.transform] = this.scroller.translateZ;
			var durationProp = utils.style.transitionDuration;
			this.wrapperStyle[durationProp] = utils.isBadAndroid ? '0.0001ms' : '0ms';
			// remove 0.0001ms
			var self = this;
			if (utils.isBadAndroid) {
				rAF(function () {
					if (self.wrapperStyle[durationProp] === '0.0001ms') {
						self.wrapperStyle[durationProp] = '0s';
					}
				});
			}
			this.wrapperStyle.opacity = '0';
		}
	}

	Indicator.prototype = {
		handleEvent: function handleEvent(e) {
			switch (e.type) {
				case 'touchstart':
				case 'pointerdown':
				case 'MSPointerDown':
				case 'mousedown':
					this._start(e);
					break;
				case 'touchmove':
				case 'pointermove':
				case 'MSPointerMove':
				case 'mousemove':
					this._move(e);
					break;
				case 'touchend':
				case 'pointerup':
				case 'MSPointerUp':
				case 'mouseup':
				case 'touchcancel':
				case 'pointercancel':
				case 'MSPointerCancel':
				case 'mousecancel':
					this._end(e);
					break;
			}
		},

		destroy: function destroy() {
			if (this.options.fadeScrollbars) {
				clearTimeout(this.fadeTimeout);
				this.fadeTimeout = null;
			}
			if (this.options.interactive) {
				utils.removeEvent(this.indicator, 'touchstart', this);
				utils.removeEvent(this.indicator, utils.prefixPointerEvent('pointerdown'), this);
				utils.removeEvent(this.indicator, 'mousedown', this);

				utils.removeEvent(window, 'touchmove', this);
				utils.removeEvent(window, utils.prefixPointerEvent('pointermove'), this);
				utils.removeEvent(window, 'mousemove', this);

				utils.removeEvent(window, 'touchend', this);
				utils.removeEvent(window, utils.prefixPointerEvent('pointerup'), this);
				utils.removeEvent(window, 'mouseup', this);
			}

			if (this.options.defaultScrollbars) {
				this.wrapper.parentNode.removeChild(this.wrapper);
			}
		},

		_start: function _start(e) {
			var point = e.touches ? e.touches[0] : e;

			e.preventDefault();
			e.stopPropagation();

			this.transitionTime();

			this.initiated = true;
			this.moved = false;
			this.lastPointX = point.pageX;
			this.lastPointY = point.pageY;

			this.startTime = utils.getTime();

			if (!this.options.disableTouch) {
				utils.addEvent(window, 'touchmove', this);
			}
			if (!this.options.disablePointer) {
				utils.addEvent(window, utils.prefixPointerEvent('pointermove'), this);
			}
			if (!this.options.disableMouse) {
				utils.addEvent(window, 'mousemove', this);
			}

			this.scroller._execEvent('beforeScrollStart');
		},

		_move: function _move(e) {
			var point = e.touches ? e.touches[0] : e,
			    deltaX,
			    deltaY,
			    newX,
			    newY,
			    timestamp = utils.getTime();

			if (!this.moved) {
				this.scroller._execEvent('scrollStart');
			}

			this.moved = true;

			deltaX = point.pageX - this.lastPointX;
			this.lastPointX = point.pageX;

			deltaY = point.pageY - this.lastPointY;
			this.lastPointY = point.pageY;

			newX = this.x + deltaX;
			newY = this.y + deltaY;

			this._pos(newX, newY);

			// INSERT POINT: indicator._move

			e.preventDefault();
			e.stopPropagation();
		},

		_end: function _end(e) {
			if (!this.initiated) {
				return;
			}

			this.initiated = false;

			e.preventDefault();
			e.stopPropagation();

			utils.removeEvent(window, 'touchmove', this);
			utils.removeEvent(window, utils.prefixPointerEvent('pointermove'), this);
			utils.removeEvent(window, 'mousemove', this);

			if (this.scroller.options.snap) {
				var snap = this.scroller._nearestSnap(this.scroller.x, this.scroller.y);

				var time = this.options.snapSpeed || Math.max(Math.max(Math.min(Math.abs(this.scroller.x - snap.x), 1000), Math.min(Math.abs(this.scroller.y - snap.y), 1000)), 300);

				if (this.scroller.x != snap.x || this.scroller.y != snap.y) {
					this.scroller.directionX = 0;
					this.scroller.directionY = 0;
					this.scroller.currentPage = snap;
					this.scroller.scrollTo(snap.x, snap.y, time, this.scroller.options.bounceEasing);
				}
			}

			if (this.moved) {
				this.scroller._execEvent('scrollEnd');
			}
		},

		transitionTime: function transitionTime(time) {
			time = time || 0;
			var durationProp = utils.style.transitionDuration;
			this.indicatorStyle[durationProp] = time + 'ms';

			if (!time && utils.isBadAndroid) {
				this.indicatorStyle[durationProp] = '0.0001ms';
				// remove 0.0001ms
				var self = this;
				rAF(function () {
					if (self.indicatorStyle[durationProp] === '0.0001ms') {
						self.indicatorStyle[durationProp] = '0s';
					}
				});
			}
		},

		transitionTimingFunction: function transitionTimingFunction(easing) {
			this.indicatorStyle[utils.style.transitionTimingFunction] = easing;
		},

		refresh: function refresh() {
			this.transitionTime();

			if (this.options.listenX && !this.options.listenY) {
				this.indicatorStyle.display = this.scroller.hasHorizontalScroll ? 'block' : 'none';
			} else if (this.options.listenY && !this.options.listenX) {
				this.indicatorStyle.display = this.scroller.hasVerticalScroll ? 'block' : 'none';
			} else {
				this.indicatorStyle.display = this.scroller.hasHorizontalScroll || this.scroller.hasVerticalScroll ? 'block' : 'none';
			}

			if (this.scroller.hasHorizontalScroll && this.scroller.hasVerticalScroll) {
				utils.addClass(this.wrapper, 'iScrollBothScrollbars');
				utils.removeClass(this.wrapper, 'iScrollLoneScrollbar');

				if (this.options.defaultScrollbars && this.options.customStyle) {
					if (this.options.listenX) {
						this.wrapper.style.right = '8px';
					} else {
						this.wrapper.style.bottom = '8px';
					}
				}
			} else {
				utils.removeClass(this.wrapper, 'iScrollBothScrollbars');
				utils.addClass(this.wrapper, 'iScrollLoneScrollbar');

				if (this.options.defaultScrollbars && this.options.customStyle) {
					if (this.options.listenX) {
						this.wrapper.style.right = '2px';
					} else {
						this.wrapper.style.bottom = '2px';
					}
				}
			}

			var r = this.wrapper.offsetHeight; // force refresh

			if (this.options.listenX) {
				this.wrapperWidth = this.wrapper.clientWidth;
				if (this.options.resize) {
					this.indicatorWidth = Math.max(Math.round(this.wrapperWidth * this.wrapperWidth / (this.scroller.scrollerWidth || this.wrapperWidth || 1)), 8);
					this.indicatorStyle.width = this.indicatorWidth + 'px';
				} else {
					this.indicatorWidth = this.indicator.clientWidth;
				}

				this.maxPosX = this.wrapperWidth - this.indicatorWidth;

				if (this.options.shrink == 'clip') {
					this.minBoundaryX = -this.indicatorWidth + 8;
					this.maxBoundaryX = this.wrapperWidth - 8;
				} else {
					this.minBoundaryX = 0;
					this.maxBoundaryX = this.maxPosX;
				}

				this.sizeRatioX = this.options.speedRatioX || this.scroller.maxScrollX && this.maxPosX / this.scroller.maxScrollX;
			}

			if (this.options.listenY) {
				this.wrapperHeight = this.wrapper.clientHeight;
				if (this.options.resize) {
					this.indicatorHeight = Math.max(Math.round(this.wrapperHeight * this.wrapperHeight / (this.scroller.scrollerHeight || this.wrapperHeight || 1)), 8);
					this.indicatorStyle.height = this.indicatorHeight + 'px';
				} else {
					this.indicatorHeight = this.indicator.clientHeight;
				}

				this.maxPosY = this.wrapperHeight - this.indicatorHeight;

				if (this.options.shrink == 'clip') {
					this.minBoundaryY = -this.indicatorHeight + 8;
					this.maxBoundaryY = this.wrapperHeight - 8;
				} else {
					this.minBoundaryY = 0;
					this.maxBoundaryY = this.maxPosY;
				}

				this.maxPosY = this.wrapperHeight - this.indicatorHeight;
				this.sizeRatioY = this.options.speedRatioY || this.scroller.maxScrollY && this.maxPosY / this.scroller.maxScrollY;
			}

			this.updatePosition();
		},

		updatePosition: function updatePosition() {
			var x = this.options.listenX && Math.round(this.sizeRatioX * this.scroller.x) || 0,
			    y = this.options.listenY && Math.round(this.sizeRatioY * this.scroller.y) || 0;

			if (!this.options.ignoreBoundaries) {
				if (x < this.minBoundaryX) {
					if (this.options.shrink == 'scale') {
						this.width = Math.max(this.indicatorWidth + x, 8);
						this.indicatorStyle.width = this.width + 'px';
					}
					x = this.minBoundaryX;
				} else if (x > this.maxBoundaryX) {
					if (this.options.shrink == 'scale') {
						this.width = Math.max(this.indicatorWidth - (x - this.maxPosX), 8);
						this.indicatorStyle.width = this.width + 'px';
						x = this.maxPosX + this.indicatorWidth - this.width;
					} else {
						x = this.maxBoundaryX;
					}
				} else if (this.options.shrink == 'scale' && this.width != this.indicatorWidth) {
					this.width = this.indicatorWidth;
					this.indicatorStyle.width = this.width + 'px';
				}

				if (y < this.minBoundaryY) {
					if (this.options.shrink == 'scale') {
						this.height = Math.max(this.indicatorHeight + y * 3, 8);
						this.indicatorStyle.height = this.height + 'px';
					}
					y = this.minBoundaryY;
				} else if (y > this.maxBoundaryY) {
					if (this.options.shrink == 'scale') {
						this.height = Math.max(this.indicatorHeight - (y - this.maxPosY) * 3, 8);
						this.indicatorStyle.height = this.height + 'px';
						y = this.maxPosY + this.indicatorHeight - this.height;
					} else {
						y = this.maxBoundaryY;
					}
				} else if (this.options.shrink == 'scale' && this.height != this.indicatorHeight) {
					this.height = this.indicatorHeight;
					this.indicatorStyle.height = this.height + 'px';
				}
			}

			this.x = x;
			this.y = y;

			if (this.scroller.options.useTransform) {
				this.indicatorStyle[utils.style.transform] = 'translate(' + x + 'px,' + y + 'px)' + this.scroller.translateZ;
			} else {
				this.indicatorStyle.left = x + 'px';
				this.indicatorStyle.top = y + 'px';
			}
		},

		_pos: function _pos(x, y) {
			if (x < 0) {
				x = 0;
			} else if (x > this.maxPosX) {
				x = this.maxPosX;
			}

			if (y < 0) {
				y = 0;
			} else if (y > this.maxPosY) {
				y = this.maxPosY;
			}

			x = this.options.listenX ? Math.round(x / this.sizeRatioX) : this.scroller.x;
			y = this.options.listenY ? Math.round(y / this.sizeRatioY) : this.scroller.y;

			this.scroller.scrollTo(x, y);
		},

		fade: function fade(val, hold) {
			if (hold && !this.visible) {
				return;
			}

			clearTimeout(this.fadeTimeout);
			this.fadeTimeout = null;

			var time = val ? 250 : 500,
			    delay = val ? 0 : 300;

			val = val ? '1' : '0';

			this.wrapperStyle[utils.style.transitionDuration] = time + 'ms';

			this.fadeTimeout = setTimeout(function (val) {
				this.wrapperStyle.opacity = val;
				this.visible = +val;
			}.bind(this, val), delay);
		}
	};

	IScroll.utils = utils;

	if (typeof module != 'undefined' && module.exports) {
		module.exports = IScroll;
	} else if (typeof define == 'function' && define.amd) {
		define(function () {
			return IScroll;
		});
	} else {
		window.IScroll = IScroll;
	}
})(window, document, Math);

},{}],14:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _Promise = typeof Promise === 'undefined' ? require('es6-promise').Promise : Promise;

var StateIterator = function () {
  function StateIterator(scroller) {
    _classCallCheck(this, StateIterator);

    var maxScrollY = scroller.maxScrollY,
        maxScrollX = scroller.maxScrollX,
        wrapperHeight = scroller.wrapperHeight,
        wrapperWidth = scroller.wrapperWidth;


    this.x = 0;
    this.y = 0;
    this.maxScrollY = maxScrollY;
    this.maxScrollX = maxScrollX;
    this.stepY = wrapperHeight;
    this.stepX = wrapperWidth;
  }

  _createClass(StateIterator, [{
    key: "next",
    value: function next() {
      if (this.hasScroll()) {
        if (this.hasScrollX()) {
          this.x = this.nextX();
          return this.resolveValue();
        } else {
          this.x = 0;
        }

        this.y = this.nextY();
        return this.resolveValue();
      }

      return this.done();
    }
  }, {
    key: "hasScroll",
    value: function hasScroll() {
      return this.hasScrollX() || this.hasScrollY();
    }
  }, {
    key: "hasScrollX",
    value: function hasScrollX() {
      return this.x > this.maxScrollX;
    }
  }, {
    key: "hasScrollY",
    value: function hasScrollY() {
      return this.y > this.maxScrollY;
    }
  }, {
    key: "nextX",
    value: function nextX() {
      return Math.max(this.x - this.stepX, this.maxScrollX);
    }
  }, {
    key: "nextY",
    value: function nextY() {
      return Math.max(this.y - this.stepY, this.maxScrollY);
    }
  }, {
    key: "resolveValue",
    value: function resolveValue() {
      var x = this.x,
          y = this.y;

      return _Promise.resolve({
        done: false,
        value: { x: x, y: y }
      });
    }
  }, {
    key: "done",
    value: function done() {
      return _Promise.resolve({ done: true, value: undefined });
    }
  }]);

  return StateIterator;
}();

exports.default = StateIterator;

},{"es6-promise":"es6-promise"}],15:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.Iscroller = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _component = require("component");

var _iscroll = require("iscroll");

var _iscroll2 = _interopRequireDefault(_iscroll);

var _dispatcher = require("dispatcher");

var _dispatcher2 = _interopRequireDefault(_dispatcher);

var _utils = require("utils");

var _utils2 = _interopRequireDefault(_utils);

var _touch = require("touch");

var _StateIterator = require("./StateIterator");

var _StateIterator2 = _interopRequireDefault(_StateIterator);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Iscroller = exports.Iscroller = function (_Component) {
	_inherits(Iscroller, _Component);

	function Iscroller(element) {
		_classCallCheck(this, Iscroller);

		var _this = _possibleConstructorReturn(this, (Iscroller.__proto__ || Object.getPrototypeOf(Iscroller)).apply(this, arguments));

		element.style.opacity = 0;
		_this.indicators = [];

		_this.activateElement = function (event) {
			_this.scroller.scrollToElement(event.target, 0);
		};

		_this.deactivateElement = function () {
			_this.scroller.x = _this.xBeforeEditing;
			_this.scroller.y = _this.yBeforeEditing;
			_this.refresh();
		};
		return _this;
	}

	_createClass(Iscroller, [{
		key: "addCheckOnElementListener",
		value: function addCheckOnElementListener() {
			var _this2 = this;

			document.addEventListener(_touch.events.move, function (event) {
				if (!checkOnElement(event.target, _this2.element)) {
					_this2.scroller.initiated = 0;
				}
			}, false);
		}
	}, {
		key: "ready",
		value: function ready() {
			var _this3 = this;

			this.init();

			var intervalHandler;

			_dispatcher2.default.subscribeAction(function (action) {
				if (action.type === _dispatcher2.default.ActionType.EDIT_PRESENTATION) {
					_this3.isEditing = true;
					_this3.xBeforeEditing = _this3.scroller.x;
					_this3.yBeforeEditing = _this3.scroller.y;
					if (!intervalHandler) {
						clearInterval(intervalHandler);
					}
					intervalHandler = setInterval(function () {
						_this3.scroller.refresh();
						_utils2.default.dispatchEvent(_this3.element, "resize-scroll");
					}, 1000);
				}
				if (action.type === _dispatcher2.default.ActionType.VIEW_PRESENTATION) {
					_this3.isEditing = false;
					clearInterval(intervalHandler);
				}
			});
		}
	}, {
		key: "init",
		value: function init() {
			var _this4 = this;

			this.scroller = this.createScroller();
			this.scrollToElement(this.scrollToSelector, 0);
			this.scroller.on('beforeScrollStart', function () {
				_this4.scrollToSelector = '';
			});
			this.observe();
			this.element.style.removeProperty('opacity');
			this.addCheckOnElementListener();
			this.refreshScroll();
		}
	}, {
		key: "createScroller",
		value: function createScroller() {
			this.createIndicators();
			var options = Object.assign({}, this, { scrollbars: false // disable default scrollbars
			});

			return new _iscroll2.default(this.getElement('.scroll-wrapper'), options);
		}
	}, {
		key: "createIndicators",
		value: function createIndicators() {
			if (this.scrollbars) {
				this.indicators = [{
					el: this.getElement('.iScrollVertical'),
					listenX: false
				}, {
					el: this.getElement('.iScrollHorizontal'),
					listenY: false
				}];
			} else {
				this.indicators = [];
			}
			this.indicators.forEach(this.updateScrollbar, this);
		}
	}, {
		key: "updateScrollbar",
		value: function updateScrollbar(scrollbar) {
			scrollbar.fade = this.fadeScrollbars;
			scrollbar.interactive = this.interactiveScrollbars;
			scrollbar.resize = !this.fixedSizeScrollbars;
			// clean styles
			if (!scrollbar.resize) {
				var indicatorStyle = scrollbar.el.children[0].style;
				indicatorStyle.width = "";
				indicatorStyle.height = "";
			}
			if (!scrollbar.fade) {
				scrollbar.el.style.opacity = "";
			}
		}
	}, {
		key: "showVerticalScrollbar",
		value: function showVerticalScrollbar() {
			return this.scrollbars && this.scrollY;
		}
	}, {
		key: "showHorizontalScrollbar",
		value: function showHorizontalScrollbar() {
			return this.scrollbars && this.scrollX;
		}
	}, {
		key: "template",
		value: function template() {
			return require('../template.html');
		}
	}, {
		key: "refresh",
		value: function refresh(property) {
			switch (property) {
				case 'scrollToSelector':
					this.scrollToElement(this.scrollToSelector);
					break;
				case 'stopPropagationSwipe':
					this.unlockSwipeEvents('all');
					this.lockSwipeEvents(this.stopPropagationSwipe);
					break;
				default:
					var x = this.scroller.x;
					var y = this.scroller.y;

					this.scroller.destroy();
					this.scroller = this.createScroller();

					if (property === 'scrollX' || property === 'scrollY') {
						this.scrollToElement(this.scrollToSelector, 0);
					} else if (property !== 'startX' && property !== 'startY') {
						this.scroller.scrollTo(x, y);
					}

					this.scroller.refresh();
			}
		}
	}, {
		key: "_toggleEvents",
		value: function _toggleEvents(eventsType, actionType) {
			var _this5 = this;

			var events = {
				'all': []
			};
			if (this.scroller.hasHorizontalScroll) {
				events.all.push('left', 'right');
			}
			if (this.scroller.hasVerticalScroll) {
				events.all.push('up', 'down');
			}

			eventsType && events[eventsType].forEach(function (side) {
				_this5.element[actionType + 'EventListener']('swipe' + side, stopSwipeEvent);
			});
		}
	}, {
		key: "lockSwipeEvents",
		value: function lockSwipeEvents(type) {
			this._toggleEvents(type, 'add');
		}
	}, {
		key: "unlockSwipeEvents",
		value: function unlockSwipeEvents(type) {
			this._toggleEvents(type, 'remove');
		}
	}, {
		key: "observe",
		value: function observe() {
			var _this6 = this;

			new window.MutationObserver(function () {
				return _this6.refreshScroll();
			}).observe(this.getElement('.scroller'), { childList: true, subtree: true });
		}
	}, {
		key: "refreshScroll",
		value: function refreshScroll() {
			var _this7 = this;

			setTimeout(function () {
				_this7.scroller.refresh();
				_this7.refresh('stopPropagationSwipe');
			});
		}
	}, {
		key: "scrollToElement",
		value: function scrollToElement(selector) {
			var time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.isEditing ? 0 : 200;
			var offsetX = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
			var offsetY = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

			if (selector) {
				var element = getDOMElement(this.element, selector);
				this.element.contains(element) && this.scroller.scrollToElement(element, time, offsetX, offsetY);
			}
		}
	}, {
		key: "getElement",
		value: function getElement(selector) {
			return this.element.querySelector(selector);
		}
	}, {
		key: "scrollTo",
		value: function scrollTo(x, y) {
			var time = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
			var easing = arguments[3];

			this.scroller.scrollTo(x, y, time, easing);
		}
	}, {
		key: "nextState",
		value: function nextState() {
			var _this8 = this;

			if (!this.stateIterator) {
				this.stateIterator = new _StateIterator2.default(this.scroller);
			}

			return this.stateIterator.next().then(function (state) {
				if (!state.done) {
					var _state$value = state.value,
					    x = _state$value.x,
					    y = _state$value.y;

					_this8.currentPosition = state.value;
					_this8.scrollTo(x, y);
				}
				return state;
			});
		}
	}, {
		key: "defaults",
		get: function get() {
			return {
				'fade-scrollbars': {
					value: false,
					type: Boolean,
					refresh: true,
					optional: true
				},
				'fixed-size-scrollbars': {
					value: false,
					type: Boolean,
					refresh: true,
					optional: true
				},
				'scrollbars': {
					value: true,
					type: Boolean,
					refresh: true
				},
				'scroll-x': {
					value: true,
					type: Boolean,
					refresh: true
				},
				'scroll-y': {
					value: true,
					type: Boolean,
					refresh: true
				},
				'start-x': {
					value: 0,
					type: Number,
					refresh: true,
					optional: true,
					units: 'px'
				},
				'start-y': {
					value: 0,
					type: Number,
					refresh: true,
					optional: true,
					units: 'px'
				},
				'mouse-wheel': {
					value: true,
					type: Boolean,
					refresh: true
				},
				'mouse-wheel-speed': {
					value: 20,
					type: Number,
					refresh: true,
					optional: true,
					units: 'px'
				},
				'interactive-scrollbars': {
					value: true,
					type: Boolean,
					refresh: true,
					optional: true
				},
				'momentum': {
					value: true,
					type: Boolean,
					refresh: true
				},
				'use-transition': {
					value: true,
					type: Boolean,
					refresh: true,
					optional: true
				},
				'bounce': {
					value: true,
					type: Boolean,
					refresh: true
				},
				'bounce-easing': {
					value: '',
					values: ['quadratic', 'circular', 'back', 'bounce', 'elastic', ''],
					type: String,
					refresh: true,
					optional: true
				},
				'bounce-time': {
					value: 600,
					type: Number,
					refresh: true,
					optional: true,
					units: 'ms'
				},
				'scroll-to-selector': {
					value: '',
					type: String,
					refresh: true,
					optional: true
				},
				'snap': {
					value: '',
					type: String,
					refresh: true,
					optional: true
				},
				"snapThreshold": {
					value: 0.334, //default value in IScroll
					type: Boolean,
					refresh: true
				},
				'stop-propagation-swipe': {
					value: 'all',
					values: ['all', 'horizontal', 'vertical', ''],
					type: String,
					refresh: true,
					optional: true
				},
				'preventDefault': {
					value: true,
					type: Boolean,
					refresh: false,
					optional: true
				},
				'bindToWrapper': {
					value: true,
					type: Boolean,
					refresh: false,
					optional: true
				},
				'currentPosition': { //need to screenshoter states
					value: {
						x: 0,
						y: 0
					},
					type: Object,
					sealed: true
				}
			};
		}
	}]);

	return Iscroller;
}(_component.Component);

function stopSwipeEvent(event) {
	event.stopPropagation();
}

function getDOMElement(parentElement, selector) {
	return parentElement.querySelector(selector);
}

function checkOnElement(target, element) {
	var isTrulyThisElement = true;
	if (target === element) {
		return isTrulyThisElement;
	} else if (~[document, document.body, null].indexOf(target)) {
		return !isTrulyThisElement;
	}
	return checkOnElement(target.parentNode, element);
}

},{"../template.html":16,"./StateIterator":14,"component":7,"dispatcher":"dispatcher","iscroll":13,"touch":"touch","utils":"utils"}],16:[function(require,module,exports){
module.exports = '<co-container class="iScrollScrollbar iScrollVerticalScrollbar" rv-class-show="showVerticalScrollbar &lt; scrollbars scrollY" container="false" user-label="Vertical scrollbar" fixed="action, animation, monitoring, property, removing" co-iscroll=""><div class="iScrollVertical" co-iscroll=""><co-container class="iScrollIndicator" user-label="Indicator" container="false" fixed="action, animation, monitoring, position, property, removing" co-iscroll=""></co-container></div></co-container><co-container class="iScrollScrollbar iScrollHorizontalScrollbar" rv-class-show="showHorizontalScrollbar &lt; scrollbars scrollX" container="false" user-label="Horizontal scrollbar" fixed="action, animation, monitoring, property, removing" co-iscroll=""><div class="iScrollHorizontal" co-iscroll=""><co-container class="iScrollIndicator" user-label="Indicator" container="false" fixed="action, animation, monitoring, position, property, removing" co-iscroll=""></co-container></div></co-container><co-container class="scroll-wrapper" user-label="Scroll content" container="false" fixed="action, animation, monitoring, position, property, removing, size" co-iscroll=""><div class="scroller" rv-on-activate="activateElement" rv-on-deactivate="deactivateElement" co-iscroll=""><content co-iscroll=""></content></div></co-container>'
},{}]},{},[1]);
