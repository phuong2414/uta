import {Component} from "component";
import IScroll from "iscroll";
import dispatcher from "dispatcher";
import utils from "utils";
import {events} from "touch";
import StateIterator from './StateIterator';

export class Iscroller extends Component {
	constructor(element){
		super(...arguments)
		element.style.opacity = 0
		this.indicators = [];

		this.activateElement = (event) =>{
			this.scroller.scrollToElement(event.target, 0)
		}

		this.deactivateElement = () =>{
			this.scroller.x = this.xBeforeEditing
			this.scroller.y = this.yBeforeEditing
			this.refresh()
		}
	}

	addCheckOnElementListener(){
		document.addEventListener(events.move, event =>{
			if (!checkOnElement(event.target, this.element)) {
				this.scroller.initiated = 0
			}
		}, false)
	}

	ready(){
		this.init();

		var intervalHandler

		dispatcher.subscribeAction(action =>{
			if (action.type === dispatcher.ActionType.EDIT_PRESENTATION) {
				this.isEditing = true
				this.xBeforeEditing = this.scroller.x
				this.yBeforeEditing = this.scroller.y
				if (!intervalHandler) {
					clearInterval(intervalHandler)
				}
				intervalHandler = setInterval(() =>{
					this.scroller.refresh()
					utils.dispatchEvent(this.element, "resize-scroll")
				}, 1000)
			}
			if (action.type === dispatcher.ActionType.VIEW_PRESENTATION) {
				this.isEditing = false
				clearInterval(intervalHandler)
			}
		})
	}

	init(){
		this.scroller = this.createScroller();
		this.scrollToElement(this.scrollToSelector, 0)
		this.scroller.on('beforeScrollStart', () =>{
			this.scrollToSelector = ''
		})
		this.observe()
		this.element.style.removeProperty('opacity')
		this.addCheckOnElementListener()
		this.refreshScroll()
	}

	createScroller(){
		this.createIndicators();
		const options = Object.assign(
			{},
			this,
			{scrollbars: false} // disable default scrollbars
		)

		return new IScroll(this.getElement('.scroll-wrapper'), options)
	}

	createIndicators(){
		if (this.scrollbars) {
			this.indicators = [
				{
					el: this.getElement('.iScrollVertical'),
					listenX: false
				},
				{
					el: this.getElement('.iScrollHorizontal'),
					listenY: false
				}
			]
		} else {
			this.indicators = []
		}
		this.indicators.forEach(this.updateScrollbar, this);
	}

	updateScrollbar(scrollbar){
		scrollbar.fade = this.fadeScrollbars;
		scrollbar.interactive = this.interactiveScrollbars;
		scrollbar.resize = !this.fixedSizeScrollbars;
		// clean styles
		if (!scrollbar.resize) {
			const indicatorStyle = scrollbar.el.children[0].style;
			indicatorStyle.width = "";
			indicatorStyle.height = "";
		}
		if (!scrollbar.fade) {
			scrollbar.el.style.opacity = "";
		}
	}

	showVerticalScrollbar(){
		return this.scrollbars && this.scrollY;
	}

	showHorizontalScrollbar(){
		return this.scrollbars && this.scrollX;
	}

	get defaults(){
		return {
			'fade-scrollbars': {
				value: false,
				type: Boolean,
				refresh: true,
				optional: true
			},
			'fixed-size-scrollbars': {
				value: false,
				type: Boolean,
				refresh: true,
				optional: true
			},
			'scrollbars': {
				value: true,
				type: Boolean,
				refresh: true
			},
			'scroll-x': {
				value: true,
				type: Boolean,
				refresh: true
			},
			'scroll-y': {
				value: true,
				type: Boolean,
				refresh: true
			},
			'start-x': {
				value: 0,
				type: Number,
				refresh: true,
				optional: true,
				units: 'px'
			},
			'start-y': {
				value: 0,
				type: Number,
				refresh: true,
				optional: true,
				units: 'px'
			},
			'mouse-wheel': {
				value: true,
				type: Boolean,
				refresh: true
			},
			'mouse-wheel-speed': {
				value: 20,
				type: Number,
				refresh: true,
				optional: true,
				units: 'px'
			},
			'interactive-scrollbars': {
				value: true,
				type: Boolean,
				refresh: true,
				optional: true
			},
			'momentum': {
				value: true,
				type: Boolean,
				refresh: true
			},
			'use-transition': {
				value: true,
				type: Boolean,
				refresh: true,
				optional: true
			},
			'bounce': {
				value: true,
				type: Boolean,
				refresh: true
			},
			'bounce-easing': {
				value: '',
				values: ['quadratic', 'circular', 'back', 'bounce', 'elastic', ''],
				type: String,
				refresh: true,
				optional: true
			},
			'bounce-time': {
				value: 600,
				type: Number,
				refresh: true,
				optional: true,
				units: 'ms'
			},
			'scroll-to-selector': {
				value: '',
				type: String,
				refresh: true,
				optional: true
			},
			'snap': {
				value: '',
				type: String,
				refresh: true,
				optional: true
      },
      "snapThreshold": {
        value: 0.334, //default value in IScroll
        type: Boolean,
        refresh: true
      },
			'stop-propagation-swipe': {
				value: 'all',
				values: ['all', 'horizontal', 'vertical', ''],
				type: String,
				refresh: true,
				optional: true
			},
			'preventDefault': {
				value: true,
				type: Boolean,
				refresh: false,
				optional: true
			},
			'bindToWrapper': {
				value: true,
				type: Boolean,
				refresh: false,
				optional: true
			},
			'currentPosition': { //need to screenshoter states
				value: {
					x: 0,
					y: 0
				},
				type: Object,
				sealed: true
			}
		}
	}

	template(){
		return require('../template.html')
	};

	refresh(property){
		switch (property) {
			case 'scrollToSelector':
				this.scrollToElement(this.scrollToSelector)
				break
			case 'stopPropagationSwipe':
				this.unlockSwipeEvents('all')
				this.lockSwipeEvents(this.stopPropagationSwipe)
				break
			default:
				let x = this.scroller.x;
				let y = this.scroller.y;

				this.scroller.destroy();
				this.scroller = this.createScroller();

				if (property === 'scrollX' || property === 'scrollY') {
					this.scrollToElement(this.scrollToSelector, 0)
				} else if (property !== 'startX' && property !== 'startY') {
					this.scroller.scrollTo(x, y)
				}

				this.scroller.refresh()
		}
	}

	_toggleEvents(eventsType, actionType){
		const events = {
			'all': []
		}
		if(this.scroller.hasHorizontalScroll) {
			events.all.push('left', 'right')
		}
		if(this.scroller.hasVerticalScroll) {
			events.all.push('up', 'down')
		}

		eventsType && events[eventsType].forEach(side =>{
			this.element[actionType + 'EventListener']('swipe' + side, stopSwipeEvent)
		})
	}

	lockSwipeEvents(type){
		this._toggleEvents(type, 'add')
	}

	unlockSwipeEvents(type){
		this._toggleEvents(type, 'remove')
	}

	observe(){
		new window.MutationObserver(() => this.refreshScroll())
			.observe(this.getElement('.scroller'), { childList: true, subtree: true })
	}

	refreshScroll(){
		setTimeout(() => {
			this.scroller.refresh()
			this.refresh('stopPropagationSwipe')
		});
	}

	scrollToElement(selector, time = this.isEditing ? 0 : 200, offsetX = true, offsetY = true){
		if (selector) {
			let element = getDOMElement(this.element, selector)
			this.element.contains(element) && this.scroller.scrollToElement(element, time, offsetX, offsetY)
		}
	}

	getElement(selector){
		return this.element.querySelector(selector)
	}

	scrollTo(x, y, time = 0, easing) {
		this.scroller.scrollTo(x, y, time, easing);
	}

	nextState() {
		if (!this.stateIterator) {
			this.stateIterator = new StateIterator(this.scroller);
		}

		return this.stateIterator.next()
			.then((state) => {
				if (!state.done) {
					const { x, y } = state.value;
					this.currentPosition = state.value;
					this.scrollTo(x, y);
				}
				return state;
			})
	}
}

function stopSwipeEvent(event){
	event.stopPropagation()
}

function getDOMElement(parentElement, selector){
	return parentElement.querySelector(selector)
}

function checkOnElement(target, element){
	const isTrulyThisElement = true
	if (target === element) {
		return isTrulyThisElement
	} else if (~[document, document.body, null].indexOf(target)) {
		return !isTrulyThisElement
	}
	return checkOnElement(target.parentNode, element)
}
