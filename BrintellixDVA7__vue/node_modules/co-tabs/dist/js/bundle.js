(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
(function (resolve){
'use strict';

var createComponent = require('component').createComponent;
var Tabs = require('./src/js/tabs').Tabs;

module.exports = createComponent({
  name: 'co-tabs',
  constructor: Tabs,
  localizationTemplate: resolve('i18n/{lang}.json'),
  localExtensions: {
    components: {
      'co-tab-group': require('co-tab-group'),
      'co-container': require('co-container'),
      'co-collection': require('co-collection'),
      'co-collection-item': require('co-collection-item'),
      'co-option': require('co-option'),
      'co-text': require('co-text'),
      'co-iscroll': require('co-iscroll'),
      'co-image': require('co-image')
    }
  }
});
require("rivets").components[module.exports.name] = module.exports;

}).call(this,function(relativePath){
			var settings = require('settings'),
				componentsDirecotry = settings.components,
				emptyString = '';

			  return componentsDirecotry.replace(new RegExp('/$'), emptyString) + '/co-tabs/' + relativePath.replace(new RegExp('^/'), emptyString);
		})
},{"./src/js/tabs":58,"co-collection":5,"co-collection-item":3,"co-container":8,"co-image":12,"co-iscroll":15,"co-option":32,"co-tab-group":41,"co-text":44,"component":48,"rivets":"rivets","settings":"settings"}],2:[function(require,module,exports){
"use strict";

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var Cache = function () {
  function Cache() {
    _classCallCheck(this, Cache);

    this.storage = {};
  }

  _createClass(Cache, [{
    key: "set",
    value: function set(key, data) {
      this.storage[key] = data;
    }
  }, {
    key: "get",
    value: function get(key) {
      return this.storage[key];
    }
  }, {
    key: "isCache",
    value: function isCache(key) {
      return Object.prototype.hasOwnProperty.call(this.storage, key);
    }
  }]);

  return Cache;
}();

module.exports = Cache;

},{}],3:[function(require,module,exports){
(function (resolve){
'use strict';

var CollectionItem = require('./src/js/collection-item.js').CollectionItem,
    createComponent = require("component").createComponent;

module.exports = createComponent({
	name: 'co-collection-item',
	constructor: CollectionItem,
	localizationTemplate: resolve('i18n/{lang}.json')
});

}).call(this,function(relativePath){
			var settings = require('settings'),
				componentsDirecotry = settings.components,
				emptyString = '';

			  return componentsDirecotry.replace(new RegExp('/$'), emptyString) + '/co-tabs/_assets/co-collection-item/' + relativePath.replace(new RegExp('^/'), emptyString);
		})
},{"./src/js/collection-item.js":4,"component":48,"settings":"settings"}],4:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.CollectionItem = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _component = require('component');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var CollectionItem = exports.CollectionItem = function (_Component) {
	_inherits(CollectionItem, _Component);

	function CollectionItem() {
		_classCallCheck(this, CollectionItem);

		var _this = _possibleConstructorReturn(this, (CollectionItem.__proto__ || Object.getPrototypeOf(CollectionItem)).apply(this, arguments));

		_this.refresh();
		return _this;
	}

	_createClass(CollectionItem, [{
		key: 'template',
		value: function template() {
			return '<content></content>';
		}
	}, {
		key: 'refresh',
		value: function refresh() {
			this.element.setAttribute('data-eid', this.dataEid);
		}
	}, {
		key: 'defaults',
		get: function get() {
			return {
				'data-eid': {
					value: '',
					type: String,
					sealed: true,
					refresh: true
				}
			};
		}
	}]);

	return CollectionItem;
}(_component.Component);

},{"component":48}],5:[function(require,module,exports){
(function (resolve){
'use strict';

var Collection = require('./src/js/collection.js').Collection,
    createComponent = require("component").createComponent;

module.exports = createComponent({
	name: 'co-collection',
	constructor: Collection,
	localizationTemplate: resolve('i18n/{lang}.json')
});

}).call(this,function(relativePath){
			var settings = require('settings'),
				componentsDirecotry = settings.components,
				emptyString = '';

			  return componentsDirecotry.replace(new RegExp('/$'), emptyString) + '/co-tabs/_assets/co-collection/' + relativePath.replace(new RegExp('^/'), emptyString);
		})
},{"./src/js/collection.js":6,"component":48,"settings":"settings"}],6:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.Collection = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _utils = require('utils');

var _component = require('component');

var _rivets = require('rivets');

var _rivets2 = _interopRequireDefault(_rivets);

var _sightglass = require('sightglass');

var _sightglass2 = _interopRequireDefault(_sightglass);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function configureSightglass() {
	_sightglass2.default.adapters = _rivets2.default.adapters;
	_sightglass2.default.root = _rivets2.default.rootInterface;
}

var Collection = exports.Collection = function (_Component) {
	_inherits(Collection, _Component);

	function Collection(element, model, parentScope) {
		_classCallCheck(this, Collection);

		var _this = _possibleConstructorReturn(this, (Collection.__proto__ || Object.getPrototypeOf(Collection)).apply(this, arguments));

		_this.iterated = [];
		_this.observers = [];
		configureSightglass();
		return _this;
	}

	_createClass(Collection, [{
		key: 'init',
		value: function init() {
			if (this.isPrerenderedCollection()) {
				this.bindPrerenderedCollectionItems();
			} else {
				this.collectionItem = this.element.getElementsByTagName("co-collection-item")[0];
				this.element.removeChild(this.collectionItem);
				this.refresh();
			}
		}
	}, {
		key: 'isPrerenderedCollection',
		value: function isPrerenderedCollection() {
			return this.element.hasAttribute('prerendered');
		}
	}, {
		key: 'ready',
		value: function ready(view) {
			var localExtensions = {};

			_rivets2.default._.extensions.forEach(function (extensionName) {
				localExtensions[extensionName] = view[extensionName];
			});

			this.localExtensions = localExtensions;

			this.init();
		}
	}, {
		key: 'insert',
		value: function insert(data, index) {
			this.checkPrerenderdMode();

			var scope = Object.create(this.parentScope);

			Object.defineProperty(scope, 'index', {
				enumerable: true,
				configurable: true,
				writable: true,
				value: index
			});
			scope[this.as] = data;

			scope.keypath = this.getKeypath(function (keypath) {
				return keypath + '.items';
			}) + '.' + index;

			var template = cloneNode(this.collectionItem);

			setCollectionItemModel(template, data, scope.keypath);

			this.element.insertBefore(template, this.element.children[index]);

			this.items.splice(index, 0, data);

			this.iterated.splice(index, 0, _rivets2.default.bind(template, scope, this.localExtensions));

			this.updateIteratedIndexes();
		}
	}, {
		key: 'remove',
		value: function remove(index) {
			this.checkPrerenderdMode();

			var elementToDelete = this.element.children[index];
			this.iterated.splice(index, 1);
			this.items.splice(index, 1);
			if (elementToDelete) {
				this.element.removeChild(elementToDelete);
			}

			this.updateIteratedIndexes();
		}
	}, {
		key: 'checkPrerenderdMode',
		value: function checkPrerenderdMode() {
			if (this.isPrerenderedCollection()) {
				console.warn(this.element, 'Was prerendered while build and can not be chaned dynamically. Please set dynamic="true" attribute to enable runtime editing.');
				return;
			}
		}
	}, {
		key: 'updateIteratedIndexes',
		value: function updateIteratedIndexes() {
			var _this2 = this;

			this.items.forEach(function (item, index) {
				if (_this2.iterated[index].models.index !== index) {
					_this2.iterated[index].models.index = index;
				}
			});
		}
	}, {
		key: 'template',
		value: function template() {
			return require('../template.html');
		}
	}, {
		key: 'refresh',
		value: function refresh() {
			this.buildCollectionElements();
			this.buildIteratedViews();
		}
	}, {
		key: 'buildCollectionElements',
		value: function buildCollectionElements() {
			this.refreshObjectCollection();
		}
	}, {
		key: 'buildIteratedViews',
		value: function buildIteratedViews() {
			var index = 0;
			if (this.iterated.length <= this.items.length && !this.isNormalChildrenCount() && this.collectionItem) {
				for (; index < this.items.length; index++) {
					//TODO: "for" loop for iterated through new Array(length)
					var model = this.items[index];
					var keypath = this.getKeypath(function (keypath) {
						return keypath + '.items';
					}) + '.' + index;
					var data = this.buildCollectionItemModel(index, model);

					if (data.keypath) {
						data.keypath = data.keypath + '.' + this.removeAlias(keypath);
					} else {
						data.keypath = keypath;
					}

					if (!defined(this.iterated[index])) {
						var template = cloneNode(this.collectionItem);

						this.buildObservations(this.parentScope, data);
						setCollectionItemModel(template, model, keypath);
						this.iterated.push(_rivets2.default.bind(template, data, this.localExtensions));

						this.element.appendChild(template);
					} else if (this.iterated[index].models[this.as] !== model) {
						this.buildObservations(this.parentScope, data);
						this.iterated[index].update(data);
					} else if (this.iterated[index].models.index !== index) {
						this.iterated[index].models.index = index;
					}
				};
			}
		}
	}, {
		key: 'bindPrerenderedCollectionItems',
		value: function bindPrerenderedCollectionItems() {
			var index = 0;
			for (; index < this.items.length; index++) {
				//TODO: "for" loop for iterated through new Array(length)
				var model = this.items[index];
				var data = this.buildCollectionItemModel(index, model);

				this.buildObservations(this.parentScope, data);
				this.iterated.push(_rivets2.default.bind(this.element.children[index], data, this.localExtensions));
			};
		}
	}, {
		key: 'buildCollectionItemModel',
		value: function buildCollectionItemModel(index, model) {
			var data = Object.create(this.parentScope);

			Object.defineProperty(data, 'index', {
				enumerable: true,
				configurable: true,
				writable: true,
				value: index
			});

			data[this.as] = model;
			data.iteratedAlias = this.as;
			return data;
		}
	}, {
		key: 'buildObservations',
		value: function buildObservations(model, data) {
			var _this3 = this;

			var observers = Object.keys(model).filter(function (key) {
				return !!_this3.getDescriptor(model, key).get;
			}).filter(function (key) {
				return key !== _this3.as;
			}).map(function (key) {
				return (0, _sightglass2.default)(model, key, function () {
					data[key] = model[key];
				});
			});

			if (this.observers[data.index]) {
				this.unobserve(data.index);
			}
			this.observers[data.index] = observers;
		}
	}, {
		key: 'getDescriptor',
		value: function getDescriptor(object, key) {
			return Object.getOwnPropertyDescriptor(object, key) || {};
		}
	}, {
		key: 'unobserve',
		value: function unobserve(index) {
			this.observers[index].forEach(function (observer) {
				return observer.unobserve();
			});
		}
	}, {
		key: 'removeAlias',
		value: function removeAlias(keypath) {
			return keypath.split('.').slice(1).join('.');
		}
	}, {
		key: 'refreshObjectCollection',
		value: function refreshObjectCollection() {
			var _this4 = this;

			this.iterated.filter(function (iteratedItem, index) {
				return _this4.items.indexOf(iteratedItem.models[_this4.as]) === -1;
			}).map(function (iteratedItemToRemove) {
				return _this4.iterated.splice(_this4.iterated.indexOf(iteratedItemToRemove), 1)[0];
			}).forEach(function (viewToRemove) {
				_this4.unobserve(viewToRemove.models.index);
				viewToRemove.unbind();
				_this4.element.removeChild(viewToRemove.els[0]);
			});
		}

		// deprecated

	}, {
		key: 'refreshPrimitiveCollection',
		value: function refreshPrimitiveCollection() {
			var difference = new Array(this.iterated.length - this.items.length),
			    index = 0,
			    view = void 0;

			for (; index < difference.length; index++) {
				view = this.iterated.pop();
				view.unbind();
				this.element.removeChild(view.els[0]);
			}
		}
	}, {
		key: 'getKeypath',
		value: function getKeypath() {
			var keypathModifier = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function (keypath) {
				return keypath;
			};

			var modelKeypath = this.getAttribute('model');
			var itemsKeypath = this.getAttribute("items");

			return modelKeypath ? keypathModifier(modelKeypath) : itemsKeypath;
		}
	}, {
		key: 'isNormalChildrenCount',
		value: function isNormalChildrenCount() {
			return this.items.length === this.element.children.length;
		}
	}, {
		key: 'getAttribute',
		value: function getAttribute(attribute) {
			return this.element.getAttribute(attribute);
		}
	}, {
		key: 'defaults',
		get: function get() {
			return {
				items: {
					value: [],
					type: Array,
					refresh: true,
					sealed: true
				},
				as: {
					value: "item",
					type: String,
					static: true
				}
			};
		}
	}], [{
		key: 'block',
		get: function get() {
			return true;
		}
	}]);

	return Collection;
}(_component.Component);

function cloneNode(node) {
	return node.cloneNode(true);
}

function defined(value) {
	return value !== undefined && value !== null;
}

function isObjectCollection(collection) {
	return collection.every(function (collectionItem) {
		return (0, _utils.isObject)(collectionItem);
	});
}

function setCollectionItemModel(template, model, keypath) {
	if ((0, _utils.isObject)(model)) {
		template.setAttribute('model', keypath);
	}
}

},{"../template.html":7,"component":48,"rivets":"rivets","sightglass":"sightglass","utils":"utils"}],7:[function(require,module,exports){
module.exports = '<content co-collection></content>'
},{}],8:[function(require,module,exports){
(function (resolve){
'use strict';

var createComponent = require('component').createComponent,
    Container = require('./src/js/Container.js').Container;

module.exports = createComponent({
	name: 'co-container',
	constructor: Container,
	localizationTemplate: resolve('i18n/{lang}.json')
});

}).call(this,function(relativePath){
			var settings = require('settings'),
				componentsDirecotry = settings.components,
				emptyString = '';

			  return componentsDirecotry.replace(new RegExp('/$'), emptyString) + '/co-tabs/_assets/co-container/' + relativePath.replace(new RegExp('^/'), emptyString);
		})
},{"./src/js/Container.js":9,"component":48,"settings":"settings"}],9:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.Container = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _component = require("component");

var _dispatcher = require("dispatcher");

var _dispatcher2 = _interopRequireDefault(_dispatcher);

var _utils = require("./utils.js");

var localUtils = _interopRequireWildcard(_utils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var HIDDEN_ELEMENT = 'hidden-element';
var HIGHLIGHTED_CLASS = 'highlighted';
var EMPTY_CLASS = 'empty';

var Container = exports.Container = function (_Component) {
	_inherits(Container, _Component);

	function Container() {
		_classCallCheck(this, Container);

		var _this = _possibleConstructorReturn(this, (Container.__proto__ || Object.getPrototypeOf(Container)).apply(this, arguments));

		if (_this.element.getAttribute('container') === 'false') {
			_this.element.removeAttribute('container');
		} else {
			_this.element.setAttribute('container', 'true');
		}

		_this.subscribeAction = _dispatcher2.default.subscribeAction(function (action) {
			console.log(action.type);
			if (action.type === _dispatcher2.default.ActionType.EDIT_PRESENTATION) {
				//element.classList.add(HIGHLIGHTED_CLASS)
				_this.element.classList.add(HIGHLIGHTED_CLASS);
			} else if (action.type === _dispatcher2.default.ActionType.VIEW_PRESENTATION) {
				//element.classList.remove(HIGHLIGHTED_CLASS)
				_this.element.classList.remove(HIGHLIGHTED_CLASS);
			}
		});

		_this.addEmptyClass();
		localUtils.observe(_this.element, { childList: true, subtree: true }, _this.addEmptyClass.bind(_this));
		return _this;
	}

	_createClass(Container, [{
		key: "getChilds",
		value: function getChilds() {
			var children = this.element.children;

			return Array.from(children).filter(function (elem) {
				return elem.model;
			}).filter(function (elem) {
				return !elem.classList.contains(HIDDEN_ELEMENT);
			});
		}
	}, {
		key: "addEmptyClass",
		value: function addEmptyClass() {
			this.element.classList[!this.getChilds().length ? 'add' : 'remove'](EMPTY_CLASS);
		}
	}, {
		key: "unbind",
		value: function unbind() {
			this.subscribeAction.unsubscribe();
		}
	}, {
		key: "template",
		value: function template() {
			return require("../template.html");
		}
	}, {
		key: "defaults",
		get: function get() {
			return {};
		}
	}]);

	return Container;
}(_component.Component);

},{"../template.html":11,"./utils.js":10,"component":48,"dispatcher":"dispatcher"}],10:[function(require,module,exports){
'use strict';

var _utils = require('utils');

var utils = _interopRequireWildcard(_utils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

module.exports.observe = function (element, config, callback) {
	new MutationObserver(function (mutations) {
		callback(mutations);
	}).observe(element, config);
	callback([]);
};

},{"utils":"utils"}],11:[function(require,module,exports){
module.exports = '<content co-container></content>'
},{}],12:[function(require,module,exports){
(function (resolve){
'use strict';

var Image = require('./src/js/image').Image,
    createComponent = require("component").createComponent;

module.exports = createComponent({
	name: 'co-image',
	constructor: Image,
	localizationTemplate: resolve('i18n/{lang}.json')
});

}).call(this,function(relativePath){
			var settings = require('settings'),
				componentsDirecotry = settings.components,
				emptyString = '';

			  return componentsDirecotry.replace(new RegExp('/$'), emptyString) + '/co-tabs/_assets/co-image/' + relativePath.replace(new RegExp('^/'), emptyString);
		})
},{"./src/js/image":13,"component":48,"settings":"settings"}],13:[function(require,module,exports){
(function (resolve){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.Image = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _component = require('component');

var _settings = require('settings');

var _settings2 = _interopRequireDefault(_settings);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Image = exports.Image = function (_Component) {
	_inherits(Image, _Component);

	function Image() {
		_classCallCheck(this, Image);

		return _possibleConstructorReturn(this, (Image.__proto__ || Object.getPrototypeOf(Image)).apply(this, arguments));
	}

	_createClass(Image, [{
		key: 'template',
		value: function template() {
			return require('../template.html');
		}
	}, {
		key: 'formatSrc',
		value: function formatSrc() {
			return (/\/common\//.test(this.src) ? _settings2.default.media + this.src : this.src
			);
		}
	}, {
		key: 'getBackgroundStyles',
		value: function getBackgroundStyles() {
			return 'background: url(\'' + this.formatSrc() + '\') ' + this.position + ' no-repeat; background-size: ' + this.size + ';';
		}
	}, {
		key: 'defaults',
		get: function get() {
			return {
				src: {
					value: resolve("../../media/images/default.png"),
					type: "File",
					fileTypes: ["image"]
				},
				position: {
					value: "center center",
					values: ["left top", "left center", "left bottom", "right top", "right center", "right bottom", "center top", "center center", "center bottom"],
					type: String
				},
				size: {
					value: "contain",
					values: ["contain", "cover", "100% 100%"],
					type: String
				}
			};
		}
	}]);

	return Image;
}(_component.Component);

exports.default = Image;

}).call(this,function(relativePath){
			var settings = require('settings'),
				componentsDirecotry = settings.components,
				emptyString = '';

			  return componentsDirecotry.replace(new RegExp('/$'), emptyString) + '/co-tabs/_assets/co-image/src/js/' + relativePath.replace(new RegExp('^/'), emptyString);
		})
},{"../template.html":14,"component":48,"settings":"settings"}],14:[function(require,module,exports){
module.exports = '<div rv-style="getBackgroundStyles &lt; src position size" rv-show="src" co-image></div>'
},{}],15:[function(require,module,exports){
(function (resolve){
'use strict';

var Iscroller = require('./src/js/iscroller.js').Iscroller,
    createComponent = require("component").createComponent;

module.exports = createComponent({
	name: 'co-iscroll',
	constructor: Iscroller,
	localExtensions: {
		components: {
			'co-container': require('co-container')
		}
	},
	localizationTemplate: resolve('i18n/{lang}.json')
});

}).call(this,function(relativePath){
			var settings = require('settings'),
				componentsDirecotry = settings.components,
				emptyString = '';

			  return componentsDirecotry.replace(new RegExp('/$'), emptyString) + '/co-tabs/_assets/co-iscroll/' + relativePath.replace(new RegExp('^/'), emptyString);
		})
},{"./src/js/iscroller.js":20,"co-container":16,"component":48,"settings":"settings"}],16:[function(require,module,exports){
(function (resolve){
'use strict';

var createComponent = require('component').createComponent,
    Container = require('./src/js/Container.js').Container;

module.exports = createComponent({
	name: 'co-container',
	constructor: Container,
	localizationTemplate: resolve('i18n/{lang}.json')
});

}).call(this,function(relativePath){
			var settings = require('settings'),
				componentsDirecotry = settings.components,
				emptyString = '';

			  return componentsDirecotry.replace(new RegExp('/$'), emptyString) + '/co-tabs/_assets/co-iscroll/_assets/co-container/' + relativePath.replace(new RegExp('^/'), emptyString);
		})
},{"./src/js/Container.js":17,"component":48,"settings":"settings"}],17:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.Container = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _component = require('component');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Container = exports.Container = function (_Component) {
	_inherits(Container, _Component);

	function Container() {
		_classCallCheck(this, Container);

		var _this = _possibleConstructorReturn(this, (Container.__proto__ || Object.getPrototypeOf(Container)).apply(this, arguments));

		if (_this.element.getAttribute('container') === 'false') {
			_this.element.removeAttribute('container');
		} else {
			_this.element.setAttribute('container', 'true');
		}
		return _this;
	}

	_createClass(Container, [{
		key: 'template',
		value: function template() {
			return require("../template.html");
		}
	}, {
		key: 'defaults',
		get: function get() {
			return {};
		}
	}]);

	return Container;
}(_component.Component);

},{"../template.html":18,"component":48}],18:[function(require,module,exports){
arguments[4][11][0].apply(exports,arguments)
},{"dup":11}],19:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _Promise = typeof Promise === 'undefined' ? require('es6-promise').Promise : Promise;

var StateIterator = function () {
  function StateIterator(scroller) {
    _classCallCheck(this, StateIterator);

    var maxScrollY = scroller.maxScrollY,
        maxScrollX = scroller.maxScrollX,
        wrapperHeight = scroller.wrapperHeight,
        wrapperWidth = scroller.wrapperWidth;


    this.x = 0;
    this.y = 0;
    this.maxScrollY = maxScrollY;
    this.maxScrollX = maxScrollX;
    this.stepY = wrapperHeight;
    this.stepX = wrapperWidth;
  }

  _createClass(StateIterator, [{
    key: "next",
    value: function next() {
      if (this.hasScroll()) {
        if (this.hasScrollX()) {
          this.x = this.nextX();
          return this.resolveValue();
        } else {
          this.x = 0;
        }

        this.y = this.nextY();
        return this.resolveValue();
      }

      return this.done();
    }
  }, {
    key: "hasScroll",
    value: function hasScroll() {
      return this.hasScrollX() || this.hasScrollY();
    }
  }, {
    key: "hasScrollX",
    value: function hasScrollX() {
      return this.x > this.maxScrollX;
    }
  }, {
    key: "hasScrollY",
    value: function hasScrollY() {
      return this.y > this.maxScrollY;
    }
  }, {
    key: "nextX",
    value: function nextX() {
      return Math.max(this.x - this.stepX, this.maxScrollX);
    }
  }, {
    key: "nextY",
    value: function nextY() {
      return Math.max(this.y - this.stepY, this.maxScrollY);
    }
  }, {
    key: "resolveValue",
    value: function resolveValue() {
      var x = this.x,
          y = this.y;

      return _Promise.resolve({
        done: false,
        value: { x: x, y: y }
      });
    }
  }, {
    key: "done",
    value: function done() {
      return _Promise.resolve({ done: true, value: undefined });
    }
  }]);

  return StateIterator;
}();

exports.default = StateIterator;

},{"es6-promise":"es6-promise"}],20:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.Iscroller = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _component = require("component");

var _iscroll = require("iscroll");

var _iscroll2 = _interopRequireDefault(_iscroll);

var _dispatcher = require("dispatcher");

var _dispatcher2 = _interopRequireDefault(_dispatcher);

var _utils = require("utils");

var _utils2 = _interopRequireDefault(_utils);

var _touch = require("touch");

var _StateIterator = require("./StateIterator");

var _StateIterator2 = _interopRequireDefault(_StateIterator);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Iscroller = exports.Iscroller = function (_Component) {
	_inherits(Iscroller, _Component);

	function Iscroller(element) {
		_classCallCheck(this, Iscroller);

		var _this = _possibleConstructorReturn(this, (Iscroller.__proto__ || Object.getPrototypeOf(Iscroller)).apply(this, arguments));

		element.style.opacity = 0;
		_this.indicators = [];

		_this.activateElement = function (event) {
			_this.scroller.scrollToElement(event.target, 0);
		};

		_this.deactivateElement = function () {
			_this.scroller.x = _this.xBeforeEditing;
			_this.scroller.y = _this.yBeforeEditing;
			_this.refresh();
		};
		return _this;
	}

	_createClass(Iscroller, [{
		key: "addCheckOnElementListener",
		value: function addCheckOnElementListener() {
			var _this2 = this;

			document.addEventListener(_touch.events.move, function (event) {
				if (!checkOnElement(event.target, _this2.element)) {
					_this2.scroller.initiated = 0;
				}
			}, false);
		}
	}, {
		key: "ready",
		value: function ready() {
			var _this3 = this;

			this.init();

			var intervalHandler;

			_dispatcher2.default.subscribeAction(function (action) {
				if (action.type === _dispatcher2.default.ActionType.EDIT_PRESENTATION) {
					_this3.isEditing = true;
					_this3.xBeforeEditing = _this3.scroller.x;
					_this3.yBeforeEditing = _this3.scroller.y;
					if (!intervalHandler) {
						clearInterval(intervalHandler);
					}
					intervalHandler = setInterval(function () {
						_this3.scroller.refresh();
						_utils2.default.dispatchEvent(_this3.element, "resize-scroll");
					}, 1000);
				}
				if (action.type === _dispatcher2.default.ActionType.VIEW_PRESENTATION) {
					_this3.isEditing = false;
					clearInterval(intervalHandler);
				}
			});
		}
	}, {
		key: "init",
		value: function init() {
			var _this4 = this;

			this.scroller = this.createScroller();
			this.scrollToElement(this.scrollToSelector, 0);
			this.scroller.on('beforeScrollStart', function () {
				_this4.scrollToSelector = '';
			});
			this.observe();
			this.element.style.removeProperty('opacity');
			this.addCheckOnElementListener();
			this.refreshScroll();
		}
	}, {
		key: "createScroller",
		value: function createScroller() {
			this.createIndicators();
			var options = Object.assign({}, this, { scrollbars: false // disable default scrollbars
			});

			return new _iscroll2.default(this.getElement('.scroll-wrapper'), options);
		}
	}, {
		key: "createIndicators",
		value: function createIndicators() {
			if (this.scrollbars) {
				this.indicators = [{
					el: this.getElement('.iScrollVertical'),
					listenX: false
				}, {
					el: this.getElement('.iScrollHorizontal'),
					listenY: false
				}];
			} else {
				this.indicators = [];
			}
			this.indicators.forEach(this.updateScrollbar, this);
		}
	}, {
		key: "updateScrollbar",
		value: function updateScrollbar(scrollbar) {
			scrollbar.fade = this.fadeScrollbars;
			scrollbar.interactive = this.interactiveScrollbars;
			scrollbar.resize = !this.fixedSizeScrollbars;
			// clean styles
			if (!scrollbar.resize) {
				var indicatorStyle = scrollbar.el.children[0].style;
				indicatorStyle.width = "";
				indicatorStyle.height = "";
			}
			if (!scrollbar.fade) {
				scrollbar.el.style.opacity = "";
			}
		}
	}, {
		key: "showVerticalScrollbar",
		value: function showVerticalScrollbar() {
			return this.scrollbars && this.scrollY;
		}
	}, {
		key: "showHorizontalScrollbar",
		value: function showHorizontalScrollbar() {
			return this.scrollbars && this.scrollX;
		}
	}, {
		key: "template",
		value: function template() {
			return require('../template.html');
		}
	}, {
		key: "refresh",
		value: function refresh(property) {
			switch (property) {
				case 'scrollToSelector':
					this.scrollToElement(this.scrollToSelector);
					break;
				case 'stopPropagationSwipe':
					this.unlockSwipeEvents('all');
					this.lockSwipeEvents(this.stopPropagationSwipe);
					break;
				default:
					var x = this.scroller.x;
					var y = this.scroller.y;

					this.scroller.destroy();
					this.scroller = this.createScroller();

					if (property === 'scrollX' || property === 'scrollY') {
						this.scrollToElement(this.scrollToSelector, 0);
					} else if (property !== 'startX' && property !== 'startY') {
						this.scroller.scrollTo(x, y);
					}

					this.scroller.refresh();
			}
		}
	}, {
		key: "_toggleEvents",
		value: function _toggleEvents(eventsType, actionType) {
			var _this5 = this;

			var events = {
				'all': []
			};
			if (this.scroller.hasHorizontalScroll) {
				events.all.push('left', 'right');
			}
			if (this.scroller.hasVerticalScroll) {
				events.all.push('up', 'down');
			}

			eventsType && events[eventsType].forEach(function (side) {
				_this5.element[actionType + 'EventListener']('swipe' + side, stopSwipeEvent);
			});
		}
	}, {
		key: "lockSwipeEvents",
		value: function lockSwipeEvents(type) {
			this._toggleEvents(type, 'add');
		}
	}, {
		key: "unlockSwipeEvents",
		value: function unlockSwipeEvents(type) {
			this._toggleEvents(type, 'remove');
		}
	}, {
		key: "observe",
		value: function observe() {
			var _this6 = this;

			new window.MutationObserver(function () {
				return _this6.refreshScroll();
			}).observe(this.getElement('.scroller'), { childList: true, subtree: true });
		}
	}, {
		key: "refreshScroll",
		value: function refreshScroll() {
			var _this7 = this;

			setTimeout(function () {
				_this7.scroller.refresh();
				_this7.refresh('stopPropagationSwipe');
			});
		}
	}, {
		key: "scrollToElement",
		value: function scrollToElement(selector) {
			var time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.isEditing ? 0 : 200;
			var offsetX = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
			var offsetY = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

			if (selector) {
				var element = getDOMElement(this.element, selector);
				this.element.contains(element) && this.scroller.scrollToElement(element, time, offsetX, offsetY);
			}
		}
	}, {
		key: "getElement",
		value: function getElement(selector) {
			return this.element.querySelector(selector);
		}
	}, {
		key: "scrollTo",
		value: function scrollTo(x, y) {
			var time = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
			var easing = arguments[3];

			this.scroller.scrollTo(x, y, time, easing);
		}
	}, {
		key: "nextState",
		value: function nextState() {
			var _this8 = this;

			if (!this.stateIterator) {
				this.stateIterator = new _StateIterator2.default(this.scroller);
			}

			return this.stateIterator.next().then(function (state) {
				if (!state.done) {
					var _state$value = state.value,
					    x = _state$value.x,
					    y = _state$value.y;

					_this8.currentPosition = state.value;
					_this8.scrollTo(x, y);
				}
				return state;
			});
		}
	}, {
		key: "defaults",
		get: function get() {
			return {
				'fade-scrollbars': {
					value: false,
					type: Boolean,
					refresh: true,
					optional: true
				},
				'fixed-size-scrollbars': {
					value: false,
					type: Boolean,
					refresh: true,
					optional: true
				},
				'scrollbars': {
					value: true,
					type: Boolean,
					refresh: true
				},
				'scroll-x': {
					value: true,
					type: Boolean,
					refresh: true
				},
				'scroll-y': {
					value: true,
					type: Boolean,
					refresh: true
				},
				'start-x': {
					value: 0,
					type: Number,
					refresh: true,
					optional: true,
					units: 'px'
				},
				'start-y': {
					value: 0,
					type: Number,
					refresh: true,
					optional: true,
					units: 'px'
				},
				'mouse-wheel': {
					value: true,
					type: Boolean,
					refresh: true
				},
				'mouse-wheel-speed': {
					value: 20,
					type: Number,
					refresh: true,
					optional: true,
					units: 'px'
				},
				'interactive-scrollbars': {
					value: true,
					type: Boolean,
					refresh: true,
					optional: true
				},
				'momentum': {
					value: true,
					type: Boolean,
					refresh: true
				},
				'use-transition': {
					value: true,
					type: Boolean,
					refresh: true,
					optional: true
				},
				'bounce': {
					value: true,
					type: Boolean,
					refresh: true
				},
				'bounce-easing': {
					value: '',
					values: ['quadratic', 'circular', 'back', 'bounce', 'elastic', ''],
					type: String,
					refresh: true,
					optional: true
				},
				'bounce-time': {
					value: 600,
					type: Number,
					refresh: true,
					optional: true,
					units: 'ms'
				},
				'scroll-to-selector': {
					value: '',
					type: String,
					refresh: true,
					optional: true
				},
				'snap': {
					value: '',
					type: String,
					refresh: true,
					optional: true
				},
				"snapThreshold": {
					value: 0.334, //default value in IScroll
					type: Boolean,
					refresh: true
				},
				'stop-propagation-swipe': {
					value: 'all',
					values: ['all', 'horizontal', 'vertical', ''],
					type: String,
					refresh: true,
					optional: true
				},
				'preventDefault': {
					value: true,
					type: Boolean,
					refresh: false,
					optional: true
				},
				'bindToWrapper': {
					value: true,
					type: Boolean,
					refresh: false,
					optional: true
				},
				'currentPosition': { //need to screenshoter states
					value: {
						x: 0,
						y: 0
					},
					type: Object,
					sealed: true
				}
			};
		}
	}]);

	return Iscroller;
}(_component.Component);

function stopSwipeEvent(event) {
	event.stopPropagation();
}

function getDOMElement(parentElement, selector) {
	return parentElement.querySelector(selector);
}

function checkOnElement(target, element) {
	var isTrulyThisElement = true;
	if (target === element) {
		return isTrulyThisElement;
	} else if (~[document, document.body, null].indexOf(target)) {
		return !isTrulyThisElement;
	}
	return checkOnElement(target.parentNode, element);
}

},{"../template.html":21,"./StateIterator":19,"component":48,"dispatcher":"dispatcher","iscroll":55,"touch":"touch","utils":"utils"}],21:[function(require,module,exports){
module.exports = '<co-container class="iScrollScrollbar iScrollVerticalScrollbar" rv-class-show="showVerticalScrollbar &lt; scrollbars scrollY" container="false" user-label="Vertical scrollbar" fixed="action, animation, monitoring, property, removing" co-iscroll><div class="iScrollVertical" co-iscroll><co-container class="iScrollIndicator" user-label="Indicator" container="false" fixed="action, animation, monitoring, position, property, removing" co-iscroll></co-container></div></co-container><co-container class="iScrollScrollbar iScrollHorizontalScrollbar" rv-class-show="showHorizontalScrollbar &lt; scrollbars scrollX" container="false" user-label="Horizontal scrollbar" fixed="action, animation, monitoring, property, removing" co-iscroll><div class="iScrollHorizontal" co-iscroll><co-container class="iScrollIndicator" user-label="Indicator" container="false" fixed="action, animation, monitoring, position, property, removing" co-iscroll></co-container></div></co-container><co-container class="scroll-wrapper" user-label="Scroll content" container="false" fixed="action, animation, monitoring, position, property, removing, size" co-iscroll><div class="scroller" rv-on-activate="activateElement" rv-on-deactivate="deactivateElement" co-iscroll><content co-iscroll></content></div></co-container>'
},{}],22:[function(require,module,exports){
(function (resolve){
'use strict';

var Menu = require('./src/js/menu.js').Menu,
    createComponent = require("component").createComponent;

module.exports = createComponent({
	name: 'co-menu',
	constructor: Menu,
	localExtensions: {
		components: {
			'co-select': require('co-select'),
			'co-iscroll': require('co-iscroll')
		}
	},
	localizationTemplate: resolve('i18n/{lang}.json')
});

}).call(this,function(relativePath){
			var settings = require('settings'),
				componentsDirecotry = settings.components,
				emptyString = '';

			  return componentsDirecotry.replace(new RegExp('/$'), emptyString) + '/co-tabs/_assets/co-menu/' + relativePath.replace(new RegExp('^/'), emptyString);
		})
},{"./src/js/menu.js":30,"co-iscroll":26,"co-select":35,"component":48,"settings":"settings"}],23:[function(require,module,exports){
(function (resolve){
'use strict';

var createComponent = require('component').createComponent,
    Container = require('./src/js/Container.js').Container;

module.exports = createComponent({
	name: 'co-container',
	constructor: Container,
	localizationTemplate: resolve('i18n/{lang}.json')
});

}).call(this,function(relativePath){
			var settings = require('settings'),
				componentsDirecotry = settings.components,
				emptyString = '';

			  return componentsDirecotry.replace(new RegExp('/$'), emptyString) + '/co-tabs/_assets/co-menu/_assets/co-container/' + relativePath.replace(new RegExp('^/'), emptyString);
		})
},{"./src/js/Container.js":24,"component":48,"settings":"settings"}],24:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"../template.html":25,"component":48,"dup":17}],25:[function(require,module,exports){
arguments[4][11][0].apply(exports,arguments)
},{"dup":11}],26:[function(require,module,exports){
(function (resolve){
'use strict';

var Iscroller = require('./src/js/iscroller.js').Iscroller,
    createComponent = require("component").createComponent;

module.exports = createComponent({
	name: 'co-iscroll',
	constructor: Iscroller,
	localExtensions: {
		components: {
			'co-container': require('co-container')
		}
	},
	localizationTemplate: resolve('i18n/{lang}.json')
});

}).call(this,function(relativePath){
			var settings = require('settings'),
				componentsDirecotry = settings.components,
				emptyString = '';

			  return componentsDirecotry.replace(new RegExp('/$'), emptyString) + '/co-tabs/_assets/co-menu/_assets/co-iscroll/' + relativePath.replace(new RegExp('^/'), emptyString);
		})
},{"./src/js/iscroller.js":28,"co-container":23,"component":48,"settings":"settings"}],27:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _Promise = typeof Promise === 'undefined' ? require('es6-promise').Promise : Promise;

var StateIterator = function () {
  function StateIterator(scroller) {
    _classCallCheck(this, StateIterator);

    var maxScrollY = scroller.maxScrollY,
        maxScrollX = scroller.maxScrollX,
        wrapperHeight = scroller.wrapperHeight,
        wrapperWidth = scroller.wrapperWidth;


    this.x = 0;
    this.y = 0;
    this.maxScrollY = maxScrollY;
    this.maxScrollX = maxScrollX;
    this.stepY = wrapperHeight;
    this.stepX = wrapperWidth;
  }

  _createClass(StateIterator, [{
    key: "next",
    value: function next() {
      if (this.hasScroll()) {
        if (this.hasScrollX()) {
          this.x = this.nextX();
          return this.resolveValue();
        } else {
          this.x = 0;
        }

        this.y = this.nextY();
        return this.resolveValue();
      }

      return this.done();
    }
  }, {
    key: "hasScroll",
    value: function hasScroll() {
      return this.hasScrollX() || this.hasScrollY();
    }
  }, {
    key: "hasScrollX",
    value: function hasScrollX() {
      return this.x > this.maxScrollX;
    }
  }, {
    key: "hasScrollY",
    value: function hasScrollY() {
      return this.y > this.maxScrollY;
    }
  }, {
    key: "nextX",
    value: function nextX() {
      return Math.max(this.x - this.stepX, this.maxScrollX);
    }
  }, {
    key: "nextY",
    value: function nextY() {
      return Math.max(this.y - this.stepY, this.maxScrollY);
    }
  }, {
    key: "resolveValue",
    value: function resolveValue() {
      var x = this.x,
          y = this.y;

      return _Promise.resolve({
        done: false,
        value: { x: x, y: y }
      });
    }
  }, {
    key: "done",
    value: function done() {
      return _Promise.resolve({ done: true, value: undefined });
    }
  }]);

  return StateIterator;
}();

exports.default = StateIterator;

},{"es6-promise":"es6-promise"}],28:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.Iscroller = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _component = require("component");

var _iscrollProbe = require("iscroll/build/iscroll-probe");

var _iscrollProbe2 = _interopRequireDefault(_iscrollProbe);

var _dispatcher = require("dispatcher");

var _dispatcher2 = _interopRequireDefault(_dispatcher);

var _utils = require("utils");

var _utils2 = _interopRequireDefault(_utils);

var _touch = require("touch");

var _StateIterator = require("./StateIterator");

var _StateIterator2 = _interopRequireDefault(_StateIterator);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Iscroller = exports.Iscroller = function (_Component) {
	_inherits(Iscroller, _Component);

	function Iscroller(element) {
		_classCallCheck(this, Iscroller);

		var _this = _possibleConstructorReturn(this, (Iscroller.__proto__ || Object.getPrototypeOf(Iscroller)).apply(this, arguments));

		element.style.opacity = 0;
		_this.indicators = [];

		_this.activateElement = function (event) {
			_this.scroller.scrollToElement(event.target, 0);
		};

		_this.deactivateElement = function () {
			_this.scroller.x = _this.xBeforeEditing;
			_this.scroller.y = _this.yBeforeEditing;
			_this.refresh();
		};
		_this.init();
		return _this;
	}

	_createClass(Iscroller, [{
		key: "addCheckOnElementListener",
		value: function addCheckOnElementListener() {
			var _this2 = this;

			document.addEventListener(_touch.events.move, function (event) {
				if (!checkOnElement(event.target, _this2.element)) {
					_this2.scroller.initiated = 0;
				}
			}, false);
		}
	}, {
		key: "ready",
		value: function ready() {
			var _this3 = this;

			this.observe();
			var intervalHandler = void 0;

			_dispatcher2.default.subscribeAction(function (action) {
				if (action.type === _dispatcher2.default.ActionType.EDIT_PRESENTATION) {
					_this3.isEditing = true;
					_this3.xBeforeEditing = _this3.scroller.x;
					_this3.yBeforeEditing = _this3.scroller.y;

					if (!intervalHandler) {
						clearInterval(intervalHandler);
					}

					intervalHandler = setInterval(function () {

						var rect = _this3.element.getBoundingClientRect();

						if (_this3.prevRect && (rect.width !== _this3.prevRect.width || rect.height !== _this3.prevRect.height)) {
							_this3.scroller.refresh();

							_utils2.default.dispatchEvent(_this3.element, "resize-scroll");
						}
						_this3.prevRect = rect;
					}, 1000);
				}
				if (action.type === _dispatcher2.default.ActionType.VIEW_PRESENTATION) {
					_this3.isEditing = false;

					clearInterval(intervalHandler);
				}
			});
		}
	}, {
		key: "init",
		value: function init() {
			var _this4 = this;

			this.scroller = this.createScroller();
			this.scrollToElement(this.scrollToSelector, 0);
			this.scroller.on('beforeScrollStart', function () {
				_this4.scrollToSelector = '';
			});
			this.element.style.removeProperty('opacity');
			this.addCheckOnElementListener();
			this.refreshScroll();
		}
	}, {
		key: "createScroller",
		value: function createScroller() {
			this.createIndicators();
			var options = Object.assign({}, this, {
				scrollbars: false,
				probeType: 2 // disable default scrollbars
			});

			return new _iscrollProbe2.default(this.getElement('.scroll-wrapper'), options);
		}
	}, {
		key: "createIndicators",
		value: function createIndicators() {
			if (this.scrollbars) {
				this.indicators = [{
					el: this.getElement('.iScrollVertical'),
					listenX: false
				}, {
					el: this.getElement('.iScrollHorizontal'),
					listenY: false
				}];
			} else {
				this.indicators = [];
			}

			this.indicators.forEach(this.updateScrollbar, this);
		}
	}, {
		key: "updateScrollbar",
		value: function updateScrollbar(scrollbar) {
			scrollbar.fade = this.fadeScrollbars;
			scrollbar.interactive = this.interactiveScrollbars;
			scrollbar.resize = !this.fixedSizeScrollbars;

			// clean styles
			if (!scrollbar.resize) {
				var indicatorStyle = scrollbar.el.children[0].style;

				indicatorStyle.width = "";
				indicatorStyle.height = "";
			}

			if (!scrollbar.fade) {
				scrollbar.el.style.opacity = "";
			}
		}
	}, {
		key: "showVerticalScrollbar",
		value: function showVerticalScrollbar() {
			return this.scrollbars && this.scrollY && this.scroller && this.scroller.hasVerticalScroll;
		}
	}, {
		key: "showHorizontalScrollbar",
		value: function showHorizontalScrollbar() {
			return this.scrollbars && this.scrollX && this.scroller && this.scroller.hasHorizontalScroll;
		}
	}, {
		key: "activateScrollbar",
		value: function activateScrollbar() {
			if (this.classList.contains('iScrollIndicator')) {
				this.prevStateActivateIndicator = this.style.display;
				this.style = "display: block;";
			}

			this.closest('.iScrollScrollbar').style = 'visibility: visible;';
		}
	}, {
		key: "deactivateScrollbar",
		value: function deactivateScrollbar() {
			if (this.classList.contains('iScrollIndicator')) {
				this.style = "display: " + this.prevStateActivateIndicator + ";";
			}

			this.closest('.iScrollScrollbar').style = '';
		}
	}, {
		key: "template",
		value: function template() {
			return require('../template.html');
		}
	}, {
		key: "refresh",
		value: function refresh(property) {
			var _this5 = this;

			switch (property) {
				case 'scrollToSelector':
					this.scrollToElement(this.scrollToSelector);
					break;
				case 'stopPropagationSwipe':
					this.unlockSwipeEvents('all');
					break;
				default:
					var x = this.scroller.x;
					var y = this.scroller.y;

					this.scroller.destroy();
					this.scroller = this.createScroller();
					this.scroller.on('scroll', function () {
						_utils2.default.dispatchEvent(_this5.element, 'scroll');
					});

					if (property === 'scrollX' || property === 'scrollY') {
						this.scrollToElement(this.scrollToSelector, 0);
					} else if (property !== 'startX' && property !== 'startY') {
						this.scroller.scrollTo(x, y);
					}

					this.scroller.refresh();
			}
		}
	}, {
		key: "_toggleEvents",
		value: function _toggleEvents(eventsType, actionType) {
			var _this6 = this;

			var events = {
				'all': []
			};

			if (this.scroller.hasHorizontalScroll) {
				events.all.push('left', 'right');
			}
			if (this.scroller.hasVerticalScroll) {
				events.all.push('up', 'down');
			}

			eventsType && events[eventsType].forEach(function (side) {
				_this6.element[actionType + 'EventListener']('swipe' + side, stopSwipeEvent);
			});
		}
	}, {
		key: "lockSwipeEvents",
		value: function lockSwipeEvents(type) {
			this._toggleEvents(type, 'add');
		}
	}, {
		key: "unlockSwipeEvents",
		value: function unlockSwipeEvents(type) {
			this._toggleEvents(type, 'remove');
		}
	}, {
		key: "observe",
		value: function observe() {
			var _this7 = this;

			new window.MutationObserver(function () {
				return _this7.refreshScroll();
			}).observe(this.getElement('.scroller'), {
				childList: true,
				subtree: true
			});
		}
	}, {
		key: "refreshScroll",
		value: function refreshScroll() {
			this.scroller.refresh();
			this.refresh('stopPropagationSwipe');
		}
	}, {
		key: "scrollToElement",
		value: function scrollToElement(selector) {
			var time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.isEditing ? 0 : 200;
			var offsetX = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
			var offsetY = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

			if (selector) {
				var element = getDOMElement(this.element, selector);

				this.element.contains(element) && this.scroller.scrollToElement(element, time, offsetX, offsetY);
			}
		}
	}, {
		key: "getElement",
		value: function getElement(selector) {
			return this.element.querySelector(selector);
		}
	}, {
		key: "scrollTo",
		value: function scrollTo(x, y) {
			var time = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
			var easing = arguments[3];

			this.scroller.scrollTo(x, y, time, easing);
		}
	}, {
		key: "nextState",
		value: function nextState() {
			var _this8 = this;

			if (!this.stateIterator) {
				this.stateIterator = new _StateIterator2.default(this.scroller);
			}

			return this.stateIterator.next().then(function (state) {
				if (!state.done) {
					var _state$value = state.value,
					    x = _state$value.x,
					    y = _state$value.y;


					_this8.currentPosition = state.value;
					_this8.scrollTo(x, y);
				}
				return state;
			});
		}
	}, {
		key: "defaults",
		get: function get() {
			return {
				'fade-scrollbars': {
					value: false,
					type: Boolean,
					refresh: true,
					optional: true
				},
				'fixed-size-scrollbars': {
					value: false,
					type: Boolean,
					refresh: true,
					optional: true
				},
				'scrollbars': {
					value: true,
					type: Boolean,
					refresh: true
				},
				'scroll-x': {
					value: true,
					type: Boolean,
					refresh: true
				},
				'scroll-y': {
					value: true,
					type: Boolean,
					refresh: true
				},
				'start-x': {
					value: 0,
					type: Number,
					refresh: true,
					optional: true,
					units: 'px'
				},
				'start-y': {
					value: 0,
					type: Number,
					refresh: true,
					optional: true,
					units: 'px'
				},
				'mouse-wheel': {
					value: true,
					type: Boolean,
					refresh: true
				},
				'mouse-wheel-speed': {
					value: 20,
					type: Number,
					refresh: true,
					optional: true,
					units: 'px'
				},
				'interactive-scrollbars': {
					value: true,
					type: Boolean,
					refresh: true,
					optional: true
				},
				'momentum': {
					value: true,
					type: Boolean,
					refresh: true
				},
				'use-transition': {
					value: true,
					type: Boolean,
					refresh: true,
					optional: true
				},
				'bounce': {
					value: true,
					type: Boolean,
					refresh: true
				},
				'bounce-easing': {
					value: '',
					values: ['quadratic', 'circular', 'back', 'bounce', 'elastic', ''],
					type: String,
					refresh: true,
					optional: true
				},
				'bounce-time': {
					value: 600,
					type: Number,
					refresh: true,
					optional: true,
					units: 'ms'
				},
				'scroll-to-selector': {
					value: '',
					type: String,
					refresh: true,
					optional: true
				},
				'snap': {
					value: '',
					type: String,
					refresh: true,
					optional: true
				},
				"snapThreshold": {
					value: 0.334, //default value in IScroll
					type: Boolean,
					refresh: true
				},
				'stop-propagation-swipe': {
					value: 'all',
					values: ['all', 'horizontal', 'vertical', ''],
					type: String,
					refresh: true,
					optional: true
				},
				'preventDefault': {
					value: true,
					type: Boolean,
					refresh: false,
					optional: true
				},
				'bindToWrapper': {
					value: true,
					type: Boolean,
					refresh: false,
					optional: true
				},
				'currentPosition': { //need to screenshoter states
					value: {
						x: 0,
						y: 0
					},
					type: Object,
					sealed: true
				}
			};
		}
	}]);

	return Iscroller;
}(_component.Component);

function stopSwipeEvent(event) {
	event.stopPropagation();
}

function getDOMElement(parentElement, selector) {
	return parentElement.querySelector(selector);
}

function checkOnElement(target, element) {
	var isTrulyThisElement = true;

	if (target === element) {
		return isTrulyThisElement;
	} else if (~[document, document.body, null].indexOf(target)) {
		return !isTrulyThisElement;
	}

	return checkOnElement(target.parentNode, element);
}

},{"../template.html":29,"./StateIterator":27,"component":48,"dispatcher":"dispatcher","iscroll/build/iscroll-probe":54,"touch":"touch","utils":"utils"}],29:[function(require,module,exports){
module.exports = '<co-container class="iScrollScrollbar iScrollVerticalScrollbar" rv-class-show="showVerticalScrollbar &lt; scrollbars scrollY scroller.hasVerticalScroll" container="false" user-label="Vertical scrollbar" fixed="action, animation, monitoring, property, removing" rv-on-activate="activateScrollbar" rv-on-deactivate="deactivateScrollbar" co-iscroll><div class="iScrollVertical" co-iscroll><co-container class="iScrollIndicator" user-label="Indicator" container="false" fixed="action, animation, monitoring, position, property, removing" rv-on-activate="activateScrollbar" rv-on-deactivate="deactivateScrollbar" co-iscroll></co-container></div></co-container><co-container class="iScrollScrollbar iScrollHorizontalScrollbar" rv-class-show="showHorizontalScrollbar &lt; scrollbars scrollX scroller.hasHorizontalScroll" container="false" user-label="Horizontal scrollbar" fixed="action, animation, monitoring, property, removing" rv-on-activate="activateScrollbar" rv-on-deactivate="deactivateScrollbar" co-iscroll><div class="iScrollHorizontal" co-iscroll><co-container class="iScrollIndicator" user-label="Indicator" container="false" fixed="action, animation, monitoring, position, property, removing" rv-on-activate="activateScrollbar" rv-on-deactivate="deactivateScrollbar" co-iscroll></co-container></div></co-container><co-container class="scroll-wrapper" user-label="Scroll content" container="false" fixed="action, animation, monitoring, position, property, removing, size" co-iscroll><div class="scroller" rv-on-activate="activateElement" rv-on-deactivate="deactivateElement" co-iscroll><content co-iscroll></content></div></co-container>'
},{}],30:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.Menu = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _component = require('component');

var _utils = require('utils');

var utils = _interopRequireWildcard(_utils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var scrollerSelector = 'co-select .selected';

var Menu = exports.Menu = function (_Component) {
	_inherits(Menu, _Component);

	function Menu() {
		_classCallCheck(this, Menu);

		return _possibleConstructorReturn(this, (Menu.__proto__ || Object.getPrototypeOf(Menu)).apply(this, arguments));
	}

	_createClass(Menu, [{
		key: 'ready',
		value: function ready() {
			this.refresh();
		}
	}, {
		key: 'template',


		// TODO: prevent swipes
		value: function template() {
			return require('../template.html');
		}
	}, {
		key: 'refresh',
		value: function refresh(property) {
			var _this2 = this;

			var isVertical = this.orientation === 'vertical';
			this.element.classList[isVertical ? 'add' : 'remove']('vertical');
			setTimeout(function () {
				_this2.scrollerModel.scrollX = !isVertical;
				_this2.scrollerModel.scrollY = isVertical;
				setTimeout(function () {
					// for slow browsers(safari)
					_this2.element.querySelector('co-iscroll').model.refresh();
				}, 500);
				utils.dispathEvent(_this2.element, 'orientation-change', { detail: _this2 });
			}, 0);
			if (property === 'selected') {
				this.scrollerModel.scrollToSelector = '';
				setTimeout(function () {
					// fix for property editing eWizard
					_this2.scrollerModel.scrollToSelector = scrollerSelector;
				}, 0);
			}
		}
	}, {
		key: 'defaults',
		get: function get() {
			return {
				'orientation': {
					value: 'horizontal',
					values: ['horizontal', 'vertical'],
					type: String,
					refresh: true
				},
				'selected': {
					value: '',
					type: String,
					refresh: true
				},
				scrollerModel: {
					type: Object,
					value: {
						scrollbars: false,
						bounce: false,
						scrollToSelector: scrollerSelector,
						scrollX: true,
						scrollY: false,
						preventDefault: false
					}
				}
			};
		}
	}]);

	return Menu;
}(_component.Component);

},{"../template.html":31,"component":48,"utils":"utils"}],31:[function(require,module,exports){
module.exports = '<co-iscroll fixed="size,postition,styles,animation,action" model="scrollerModel" co-menu><co-select sealed selected="selected" rv-class="orientation" co-menu><content co-menu></content></co-select></co-iscroll>'
},{}],32:[function(require,module,exports){
(function (resolve){
'use strict';

var Option = require('./src/js/Option.js').Option,
    createComponent = require('component').createComponent;

module.exports = createComponent({
	name: 'co-option',
	constructor: Option,
	localizationTemplate: resolve('i18n/{lang}.json')
});

}).call(this,function(relativePath){
			var settings = require('settings'),
				componentsDirecotry = settings.components,
				emptyString = '';

			  return componentsDirecotry.replace(new RegExp('/$'), emptyString) + '/co-tabs/_assets/co-option/' + relativePath.replace(new RegExp('^/'), emptyString);
		})
},{"./src/js/Option.js":33,"component":48,"settings":"settings"}],33:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.Option = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _utils = require('utils');

var utils = _interopRequireWildcard(_utils);

var _component = require('component');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Option = exports.Option = function (_Component) {
	_inherits(Option, _Component);

	function Option(element) {
		_classCallCheck(this, Option);

		var _this = _possibleConstructorReturn(this, (Option.__proto__ || Object.getPrototypeOf(Option)).apply(this, arguments));

		_this.element.addEventListener("tap", function () {
			utils.dispatchEvent(element, 'option-tap', { detail: _this });
		});
		return _this;
	}

	_createClass(Option, [{
		key: 'template',
		value: function template() {
			return require('../template.html');
		}
	}, {
		key: 'refresh',
		value: function refresh(attrName) {
			switch (attrName) {
				case 'selected':
					this.element.classList[this.selected ? 'add' : 'remove']('selected');
					utils.dispatchEvent(this.element, 'option-change', { detail: this });
					break;
			}
		}
	}, {
		key: 'select',
		value: function select() {
			this.selected = true;
		}
	}, {
		key: 'unselect',
		value: function unselect() {
			this.selected = false;
		}
	}, {
		key: 'toggle',
		value: function toggle() {
			return this.selected = !this.selected;
		}
	}, {
		key: 'defaults',
		get: function get() {
			return {
				"value": {
					value: "",
					type: String
				},
				"displayed-value": {
					value: "",
					type: String
				},
				"selected": {
					value: false,
					type: Boolean,
					refresh: true,
					sealed: true
				}
			};
		}
	}]);

	return Option;
}(_component.Component);

},{"../template.html":34,"component":48,"utils":"utils"}],34:[function(require,module,exports){
module.exports = '<!-- TODO: remove first line and file src/css/option.css --><content co-option></content>'
},{}],35:[function(require,module,exports){
(function (resolve){
'use strict';

var Select = require('./src/js/Select.js').Select,
    single = require('./src/js/Select.js').single,
    multiple = require('./src/js/Select.js').multiple,
    createComponent = require("component").createComponent;

module.exports = createComponent({
	name: 'co-select',
	constructor: Select,
	localizationTemplate: resolve('i18n/{lang}.json')
});

module.exports.single = single;
module.exports.multiple = multiple;

}).call(this,function(relativePath){
			var settings = require('settings'),
				componentsDirecotry = settings.components,
				emptyString = '';

			  return componentsDirecotry.replace(new RegExp('/$'), emptyString) + '/co-tabs/_assets/co-select/' + relativePath.replace(new RegExp('^/'), emptyString);
		})
},{"./src/js/Select.js":36,"component":48,"settings":"settings"}],36:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.multiple = exports.single = exports.Select = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _component = require('component');

var _multiple = require('./multiple.js');

var multiple = _interopRequireWildcard(_multiple);

var _single = require('./single.js');

var single = _interopRequireWildcard(_single);

var _utils = require('utils');

var utils = _interopRequireWildcard(_utils);

var _utils2 = require('./utils.js');

var selectUtils = _interopRequireWildcard(_utils2);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Select = function (_Component) {
  _inherits(Select, _Component);

  function Select(element, model) {
    _classCallCheck(this, Select);

    var _this = _possibleConstructorReturn(this, (Select.__proto__ || Object.getPrototypeOf(Select)).apply(this, arguments));

    utils.mixin(_this, _this.multiple ? multiple : single);
    return _this;
  }

  _createClass(Select, [{
    key: 'addEventListeners',
    value: function addEventListeners() {
      var _this2 = this;

      setTimeout(function () {
        _this2.init();
        if (!selectUtils.isThisComponentInCheckbox(_this2.element)) {
          _this2.element.addEventListener('option-tap', _this2.onOptionTapLocalListener.bind(_this2));
        }
        _this2.element.addEventListener('option-change', _this2.onOptionChangeLocalListener.bind(_this2));
      }, 0);
    }
  }, {
    key: 'ready',
    value: function ready() {
      selectUtils.observe(this.element, { childList: true, subtree: true }, this.reInitSelect.bind(this));
      this.addEventListeners();
    }
  }, {
    key: 'reInitSelect',
    value: function reInitSelect(mutations) {
      if (mutations.length >= 1 && this.options) {
        var removedOption = selectUtils.getCoOptionFromCollectionItemInMutations(mutations[0].removedNodes);
        var addedOption = selectUtils.getCoOptionFromCollectionItemInMutations(mutations[0].addedNodes);
        var indexRemovedOption = removedOption ? this.getIndexActiveOption(removedOption.model) : -1;

        this.options = selectUtils.getOptions(this.element);

        this.optionsRefresh(this.selected || this.selectedValues, this.options, addedOption, removedOption, indexRemovedOption);
      } else {
        this.options = selectUtils.getOptions(this.element);
      }
    }
  }, {
    key: 'getIndexActiveOption',
    value: function getIndexActiveOption(optionModel) {
      return this.options.indexOf(optionModel);
    }
  }, {
    key: 'template',
    value: function template() {
      return require('../template.html');
    }
  }, {
    key: 'dispatchEvent',
    value: function dispatchEvent(eventName, options) {
      utils.dispatchEvent(this.element, eventName, options);
    }
  }, {
    key: 'onOptionChangeLocalListener',
    value: function onOptionChangeLocalListener() {
      this.onOptionChange.apply(this, arguments);
    }
  }, {
    key: 'onOptionTapLocalListener',
    value: function onOptionTapLocalListener() {
      this.onOptionTap.apply(this, arguments);
    }
  }, {
    key: 'refresh',
    value: function refresh(attrName) {
      switch (attrName) {
        case 'multiple':
          this.clearAllData();
          utils.mixin(this, this.multiple ? multiple : single);
          break;
        default:
          this._refresh(attrName);
      }
    }
  }, {
    key: 'getOptionByValue',
    value: function getOptionByValue(value) {
      var optionFound = void 0;
      if (this.options) {
        this.options.some(function (option) {
          return option && option.value === value && (optionFound = option);
        });
      }
      return optionFound || null;
    }
  }, {
    key: 'clearAllData',
    value: function clearAllData() {
      var _this3 = this;

      Object.keys(this.defaults).forEach(function (el) {
        if (el !== 'multiple') {
          _this3[utils.toCamelCase(el)] = _this3.defaults[el].value;
        }
      });
    }
  }, {
    key: 'defaults',
    get: function get() {
      return {
        'multiple': {
          type: Boolean,
          value: false,
          refresh: true
        },
        'selected-values': {
          type: Array,
          value: [],
          refresh: true
        },
        'selected': {
          type: String,
          value: '',
          refresh: true
        },
        'index': {
          type: Number,
          value: -1,
          refresh: true
        },
        'options-index': {
          type: Array,
          value: [],
          refresh: true,
          sealed: true
        }
      };
    }
  }]);

  return Select;
}(_component.Component);

exports.Select = Select;
exports.single = single;
exports.multiple = multiple;

},{"../template.html":40,"./multiple.js":37,"./single.js":38,"./utils.js":39,"component":48,"utils":"utils"}],37:[function(require,module,exports){
'use strict';

exports.init = function () {
  if (this.optionsIndex.length > 0) {
    this._refresh('optionsIndex');
  } else {
    this._refresh('selectedValues');
  }
};

exports.optionsRefresh = function (selected, options, addedOption, removedOption, indexRemovedOption) {
  var indexAdded = void 0;

  if (removedOption) {
    this.removeActiveOption(indexRemovedOption);
  }

  if (addedOption) {
    indexAdded = this.options.indexOf(addedOption.model);
    this.addedNewCollectionUpper(indexAdded);

    /* if(~indexAdded){ // after added on ewizard this co-select marked as checked
        this.optionsIndex.push(indexAdded)
    } */
  }
};

exports.removeActiveOption = function (indexRemovedOption) {
  var newOptionsIndex = this.optionsIndex.filter(function (indexVal) {
    return indexRemovedOption !== indexVal;
  }).map(function (indexVal, index) {
    return indexRemovedOption > -1 && indexVal > indexRemovedOption ? --indexVal : indexVal;
  });

  this.optionsIndex = newOptionsIndex;
};

exports.addedNewCollectionUpper = function (indexAdded) {
  var isChanged,
      newOptionsIndex = this.optionsIndex.map(function (activeIndex) {
    if (indexAdded <= activeIndex) {
      isChanged = true;
      return ++activeIndex;
    } else {
      return activeIndex;
    }
  });

  if (isChanged) {
    this.optionsIndex = newOptionsIndex;
  }
};

exports.onOptionTap = function (event) {
  var option = event.detail;
  option.toggle();
  event.stopPropagation();
};

exports.onOptionChange = function (event) {
  var option = event.detail,
      index = this.options.indexOf(option),
      indexInSelect = void 0;

  if (!this.optionsIndexStateLocalChange) {
    indexInSelect = this.optionsIndex.indexOf(index);

    if (~indexInSelect) {
      this.optionsIndex.splice(indexInSelect, 1);
    } else {
      this.optionsIndex.push(index);
    }
  }
  this.optionsIndexStateLocalChange = false;
  event.stopPropagation();
};

exports._refresh = function (attrName, isModel) {
  var _this = this;

  switch (attrName) {
    case 'optionsIndex':
      {

        var isChanges = void 0,
            selectedValues = [];

        this.options.forEach(function (option, index) {
          _this.optionsIndexStateLocalChange = true;

          if (~_this.optionsIndex.indexOf(index)) {
            option.select();
            if (!~_this.selectedValues.indexOf(option.value)) {
              isChanges = true;
            }
            selectedValues.push(option.value);
          } else {
            option.unselect();
            if (~_this.selectedValues.indexOf(option.value)) {
              isChanges = true;
            }
          }
        });

        if (isChanges || this.selectedValues.length !== this.optionsIndex.length) {
          this.selectedValues = selectedValues;
          this.dispatchEvent('change', { detail: this.selectedValues });
        }

        this.optionsIndexStateLocalChange = false;
        break;
      }
    case 'selectedValues':
      {
        var _isChanges = void 0,
            newIndexArray = [],
            currentInd = void 0,
            indexInAll = void 0,
            values = this.getValuesByIndexAll();

        this.selectedValues.forEach(function (value, index) {

          currentInd = values.indexOf(value);

          if (!~currentInd) {
            _isChanges = true;
          }

          indexInAll = _this.options.indexOf(_this.getOptionByValue(value));

          if (~indexInAll) {
            newIndexArray.push(indexInAll);
          }
        });

        if (!_isChanges) {
          _isChanges = values.some(function (activeValue) {
            return !~_this.selectedValues.indexOf(activeValue);
          });
        }

        if (_isChanges) {
          this.optionsIndex = newIndexArray;
        }
      }
  }
};

exports.getValuesByIndexAll = function () {
  var _this2 = this;

  return this.optionsIndex.map(function (option) {
    return _this2.options[option].value;
  });
};

},{}],38:[function(require,module,exports){
'use strict';

var _utils = require('utils');

var utils = _interopRequireWildcard(_utils);

var _utils2 = require('./utils.js');

var selectUtils = _interopRequireWildcard(_utils2);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

exports.init = function () {
	allOptionOff(this.options);
	if (~this.index) {
		this._refresh('index');
	} else if (this.selected) {
		this._refresh('selected');
	}
};

function allOptionOff(options) {
	options.forEach(function (elem) {
		elem.unselect();
	});
}
exports.optionsRefresh = function (selected, options, addedOption, removedOption, currentActiveIndex) {

	if (addedOption) {
		addedOption.model.unselect();
		if (this.index > -1 && this.options.indexOf(addedOption.model) <= this.index) {
			this.index++;
		}
	} else if (this.index > -1 && currentActiveIndex > -1 && currentActiveIndex === this.index) {
		this.index = this.lastIndex = -1;
		this.selected = '';
	}
};

exports.onOptionTap = function (event) {
	var option = event.detail;
	this.tap = true;

	if (!option.selected) {
		option.select();
	}
};

exports.onOptionChange = function (event) {
	var option = event.detail,
	    index = this.options.indexOf(option);

	if (!this.tap) {
		if (this.index == index) {
			this.index = this.lastIndex = -1;
			this.selected = '';
		}
	}

	if (this.lastIndex != index && !this.options[index].model.selected) {
		this.lastIndex = this.index;
		this.index = index;
	}

	this.tap = false;
	event.stopPropagation();
};

exports._refresh = function (attrName) {
	switch (attrName) {
		case 'index':
			{
				this.unselectLastActive(this.lastIndex);
				this.selectNewItemByIndex(this.index);
				break;
			}
		case 'selected':
			{
				if (this.index >= 0 && this.index < this.options.length && this.options[this.index].value == this.selected) {
					return;
				} else {
					var newOptionSelected = this.getOptionByValue(this.selected);
					this.index = this.options.indexOf(newOptionSelected);
				}
				break;
			}
	}
};

exports.unselectLastActive = function () {
	if (this.lastIndex > -1 && this.options[this.lastIndex]) {
		this.options[this.lastIndex].unselect();
	}
};

exports.selectNewItemByIndex = function (index) {
	if (index > -1 && index < this.options.length) {
		this.options[index].select();
		this.selected = this.options[index].value;
		this.dispatchEvent('change', { detail: this.selected });

		this.lastIndex = index;
	} else {
		this.lastIndex = -1;
	}
};

},{"./utils.js":39,"utils":"utils"}],39:[function(require,module,exports){
'use strict';

var _utils = require('utils');

var utils = _interopRequireWildcard(_utils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

module.exports.observe = function (element, config, callback) {
	new MutationObserver(function (mutations) {
		callback(mutations);
	}).observe(element, config);
	callback([]);
};

module.exports.getOptions = function (element) {
	return utils.toArray(element.getElementsByTagName('co-option')).map(function (optionElement) {
		return optionElement.model;
	}).filter(function (optionElementModel) {
		return optionElementModel;
	});
};

module.exports.isThisComponentInCheckbox = function (element) {
	return element.parentElement.tagName == "CO-CHECKBOX-GROUP" || element.parentElement.tagName == "CO-CHECKBOXES";
};

module.exports.getCoOptionFromCollectionItemInMutations = function (mutation) {
	if (mutation.length && mutation[0].tagName == 'CO-COLLECTION-ITEM') {
		return mutation[0].querySelector('co-option');
	}
	return false;
};

function isComponentLoad(component) {
	return component.hasAttribute('co-component');
}
module.exports.isCollectionLoad = function (collection) {
	if (collection && collection.children.length > 0) {
		return isComponentLoad(collection.children[0]);
	} else {
		return true;
	}
};

},{"utils":"utils"}],40:[function(require,module,exports){
module.exports = '<content co-select></content>'
},{}],41:[function(require,module,exports){
(function (resolve){
'use strict';

var TabGroup = require('./src/js/Tab-group.js').TabGroup,
    createComponent = require("component").createComponent;

module.exports = createComponent({
	name: 'co-tab-group',
	constructor: TabGroup,
	localExtensions: {
		components: {
			'co-menu': require('co-menu'),
			'co-container': require('co-container')
		}
	},
	localizationTemplate: resolve('i18n/{lang}.json')
});

}).call(this,function(relativePath){
			var settings = require('settings'),
				componentsDirecotry = settings.components,
				emptyString = '';

			  return componentsDirecotry.replace(new RegExp('/$'), emptyString) + '/co-tabs/_assets/co-tab-group/' + relativePath.replace(new RegExp('^/'), emptyString);
		})
},{"./src/js/Tab-group.js":42,"co-container":8,"co-menu":22,"component":48,"settings":"settings"}],42:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.TabGroup = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _component = require("component");

var _utils = require("utils");

var utils = _interopRequireWildcard(_utils);

var _touch = require("touch");

var touch = _interopRequireWildcard(_touch);

var _nav = require("nav");

var nav = _interopRequireWildcard(_nav);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var TabGroup = exports.TabGroup = function (_Component) {
	_inherits(TabGroup, _Component);

	function TabGroup(element, model) {
		_classCallCheck(this, TabGroup);

		var _this = _possibleConstructorReturn(this, (TabGroup.__proto__ || Object.getPrototypeOf(TabGroup)).apply(this, arguments));

		_this.tabElements = [];

		nav.onenter(function () {
			if (_this.firstHidden && _this.defaultIndex === 0) {
				_this.index = _this.defaultIndex + 1;
			} else {
				_this.index = _this.defaultIndex;
			}
		});

		_this.observe(_this.element, { childList: true, subtree: true }, _this.reInitTabs.bind(_this));
		return _this;
	}

	_createClass(TabGroup, [{
		key: "ready",
		value: function ready() {
			var _this2 = this;

			setTimeout(function () {
				//fix co-collection
				_this2.refreshComponent({ element: _this2.element, searchElem: 'co-collection' });
				//fix scroller on the first tab
				_this2.initScrollersRefresh();
			}, 100);
			this.iscrolls = this.element.querySelectorAll('co-iscroll');
		}
	}, {
		key: "refreshComponent",
		value: function refreshComponent(option) {
			utils.toArray(option.nodeList || option.element.querySelectorAll(option.searchElem)).forEach(function (elem) {
				elem.model ? elem.model.refresh() : false;
			});
		}
	}, {
		key: "initScrollersRefresh",
		value: function initScrollersRefresh() {
			this.refreshScrollers();
			this.initScrollersRefresh = function () {};
		}
	}, {
		key: "refreshScrollers",
		value: function refreshScrollers() {
			this.refreshComponent({ nodeList: this.iscrolls });
		}
	}, {
		key: "template",
		value: function template() {
			return require('../template.html');
		}
	}, {
		key: "activate",
		value: function activate(activatedElement) {
			var activatedTab = void 0,
			    activetedElementInTabGroupContext = void 0;

			activetedElementInTabGroupContext = this.getActivetedElementInTabGroupContext(activatedElement);

			activatedTab = this.tabElements.find(function (tabElement) {
				return tabElement.tabs.contains(activetedElementInTabGroupContext) || tabElement.button.contains(activetedElementInTabGroupContext);
			});

			if (activatedTab) {
				this.index = activatedTab.index;
			}
		}
	}, {
		key: "getActivetedElementInTabGroupContext",
		value: function getActivetedElementInTabGroupContext(activatedElement) {
			var activetedElementInTabGroupContext;

			if (activatedElement.tagName === 'CO-COLLECTION-ITEM' || activatedElement.parentElement.tagName === 'CO-COLLECTION-ITEM') {
				activetedElementInTabGroupContext = this.tabElements.find(function (tabElement) {
					return activatedElement.contains(tabElement.tabs) || activatedElement.contains(tabElement.button);
				});
			}

			return activetedElementInTabGroupContext && activetedElementInTabGroupContext.button || activatedElement;
		}
	}, {
		key: "getTabsWithContent",
		value: function getTabsWithContent() {
			var collectionItems = this.element.querySelectorAll(".tabs > co-collection > co-collection-item");
			return collectionItems.length ? collectionItems : this.element.querySelectorAll(".tabs > *");
		}
	}, {
		key: "getNodeTabElements",
		value: function getNodeTabElements() {
			return {
				navButtons: this.element.querySelectorAll("co-menu co-option"),
				tabsWithContent: this.getTabsWithContent()
			};
		}
	}, {
		key: "getCollection",
		value: function getCollection(objWithNodeElements) {
			return [].slice.call(objWithNodeElements.navButtons).map(function (element, index) {
				return {
					button: element,
					tabs: objWithNodeElements.tabsWithContent[index],
					index: index
				};
			});
		}
	}, {
		key: "hideFirstTab",
		value: function hideFirstTab() {
			var tabIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

			if (this.tabElements[tabIndex] && this.firstHidden) {
				this.element.classList.add("hidden-first");
			} else {
				this.element.classList.remove("hidden-first");
			}
		}
	}, {
		key: "openTab",
		value: function openTab(tab) {
			tab.button.model.selected = true;
			tab.tabs.classList.add("active");
			tab.tabs.classList.add("active-tab");
			utils.dispatchEvent(this.element, "tabenter", { detail: { tabIndex: tab.index } });
		}
	}, {
		key: "closeTab",
		value: function closeTab(tab) {
			tab.button.model.selected = false;
			tab.tabs.classList.remove("active");
			tab.tabs.classList.remove("active-tab");
			utils.dispatchEvent(this.element, "tableave", { detail: { tabIndex: tab.index } });
		}
	}, {
		key: "isTabActive",
		value: function isTabActive(tab) {
			return tab === this.activeTab;
		}
	}, {
		key: "selectTab",
		value: function selectTab(index) {
			var tab = this.tabElements[index] || this.activeTab;

			if (this.activeTab) {
				this.closeTab(this.activeTab);
			}
			this.openTab(tab);
			this.activeTab = tab;
		}
	}, {
		key: "setTabIndex",
		value: function setTabIndex(tab) {
			if (!this.isTabActive(tab)) {
				this.index = this.tabElements.indexOf(tab);
			} else {
				this.showHiddenTab(tab);
			}
		}
	}, {
		key: "showHiddenTab",
		value: function showHiddenTab(tab) {
			if (this.firstHidden) {
				tab.button.model.unselect();
				this.index = 0;
			}
		}
	}, {
		key: "removeLitenersForTabNavigationButtons",
		value: function removeLitenersForTabNavigationButtons(tabElements) {
			tabElements.forEach(function (tab) {
				tab.button.removeEventListener("tap", tab.listen);
			});
		}
	}, {
		key: "addLitenersForTabNavigationButtons",
		value: function addLitenersForTabNavigationButtons(tabElements) {
			var _this3 = this;

			tabElements.forEach(function (tab, ind) {
				if (tab.tabs) {
					tabElements[ind]["listen"] = _this3.setTabIndex.bind(_this3, tab);
					tab.button.addEventListener("tap", tabElements[ind]["listen"]);
					_this3.closeTab(tab);
				}
			});
		}
	}, {
		key: "reInitTabs",
		value: function reInitTabs() {
			var nodeTabElements = this.getNodeTabElements();

			this.removeLitenersForTabNavigationButtons(this.tabElements);
			this.tabElements = this.getCollection(nodeTabElements);
			this.addLitenersForTabNavigationButtons(this.tabElements);

			if (this.tabElements && this.tabElements.length > 0 && this.tabElements[this.index] && this.tabElements[this.index].button) {
				this.tabElements[this.index].button.model.select();
			} else if (this.tabElements.length > 0) {
				this.index = this.tabElements.length - 1;
			}

			this.selectTab(this.index);
			this.setOrientation();
			this.hideFirstTab();
			this.changeZIndexReverse();
			this.ready();
		}
	}, {
		key: "observe",
		value: function observe(nodeTarget, config, callback) {
			var _this4 = this;

			var observer = new MutationObserver(function (el) {
				setTimeout(function () {
					callback();
				}, 0);
			});
			observer.observe(nodeTarget, config);
			setTimeout(function () {
				_this4.reInitTabs();
			}, 105);
		}
	}, {
		key: "setOrientation",
		value: function setOrientation() {
			var isVertical = this.orientation === "vertical";
			this.element.classList[isVertical ? "add" : "remove"]("vertical");
		}
	}, {
		key: "refresh",
		value: function refresh(attrName) {
			switch (attrName) {
				case "orientation":
					this.setOrientation();
					break;
				case "index":
					if (this.index < 0) {
						this.index = 0;
					}
					this.selectTab(this.index);
					break;
				case "firstHidden":
					this.hideFirstTab(this.index);
					break;
			}
			this.refreshScrollers();
		}
	}, {
		key: "changeZIndexReverse",
		value: function changeZIndexReverse() {
			var length = this.tabElements.length;

			this.tabElements.forEach(function (tab, ind) {
				tab.button.style.zIndex = length - ind;
			});
		}
	}, {
		key: "defaults",
		get: function get() {
			return {
				"orientation": {
					type: String,
					value: "horizontal",
					values: ["horizontal", "vertical"],
					refresh: true
				},
				"index": {
					value: 0,
					type: Number,
					refresh: true
				},
				"first-hidden": {
					type: Boolean,
					value: false,
					refresh: true
				},
				"menuModel": {
					type: Object,
					sealed: true,
					refresh: true,
					value: {}
				},
				"defaultIndex": {
					value: 0,
					type: Number,
					optional: true,
					refresh: true
				}
			};
		}
	}]);

	return TabGroup;
}(_component.Component);

},{"../template.html":43,"component":48,"nav":"nav","touch":"touch","utils":"utils"}],43:[function(require,module,exports){
module.exports = '<co-container user-label="Navigation buttons" class="navigation-menu-buttons" fixed="position, size, action, animation" co-tab-group><co-menu model="menuModel" orientation="orientation" sealed fixed co-tab-group><content select=".tab-group-buttons &gt; co-option, .tab-group-buttons &gt; co-collection" co-tab-group></content></co-menu></co-container><co-container user-label="Tabs content" class="tabs" fixed="position, size, action, animation" co-tab-group><content select=".tabs &gt; co-collection, .tabs &gt; *" co-tab-group></content></co-container>'
},{}],44:[function(require,module,exports){
(function (resolve){
'use strict';

var Text = require('./src/js/text.js').Text,
    createComponent = require("component").createComponent;

module.exports = createComponent({
	name: 'co-text',
	constructor: Text,
	localizationTemplate: resolve('i18n/{lang}.json')
});

}).call(this,function(relativePath){
			var settings = require('settings'),
				componentsDirecotry = settings.components,
				emptyString = '';

			  return componentsDirecotry.replace(new RegExp('/$'), emptyString) + '/co-tabs/_assets/co-text/' + relativePath.replace(new RegExp('^/'), emptyString);
		})
},{"./src/js/text.js":45,"component":48,"settings":"settings"}],45:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.Text = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _textableComponent = require('textable-component');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Text = exports.Text = function (_TextableComponent) {
	_inherits(Text, _TextableComponent);

	function Text() {
		_classCallCheck(this, Text);

		return _possibleConstructorReturn(this, (Text.__proto__ || Object.getPrototypeOf(Text)).apply(this, arguments));
	}

	_createClass(Text, [{
		key: 'template',
		value: function template() {
			return require('../template.html');
		}
	}, {
		key: 'refresh',
		value: function refresh() {}
	}, {
		key: 'defaults',
		get: function get() {
			return {
				html: {
					value: 'Text',
					type: Text,
					refresh: true
				}
			};
		}
	}]);

	return Text;
}(_textableComponent.TextableComponent);

},{"../template.html":46,"textable-component":56}],46:[function(require,module,exports){
module.exports = '<span rv-html="html" sealed co-text></span>'
},{}],47:[function(require,module,exports){
module.exports={
	"localizationPath": "components/{name}/i18n/{lang}.json"
}
},{}],48:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var rivets = require('rivets');
var utils = require('utils');
var ComponentConstructor = require('./src/js/ComponentConstructor.js').ComponentConstructor;
var buildModel = require('./src/js/buildModel.js');
var buildObservations = require('./src/js/buildObservations.js');
var config = require('./config.json');

function registerComponent(name, Constructor, localExtensions) {
  rivets.components[name] = createComponent(name, Constructor, localExtensions);
}

function createComponent(options, Constructor, localExtensions) {
  var name;

  if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object') {
    name = options.name;
    Constructor = options.constructor;
    localExtensions = options.localExtensions;
  } else {
    name = options;
  }

  Constructor.prototype.localizationTemplate = options.localizationTemplate || config.localizationPath;

  var descriptor = {
    name: name,
    block: Constructor.block,
    static: getStaticProperties(Constructor.prototype.defaults),
    template: Constructor.prototype.template,
    constructor: Constructor,
    initialize: function initialize(element, data) {
      var defaultProperties = utils.toCamelCaseObject(Constructor.prototype.defaults);
      var model = buildModel(defaultProperties, data, name);
      var componentInstance = new Constructor(element, model, this.view, this);

      Constructor.prototype.name = name;

      buildObservations.call(this, componentInstance, defaultProperties, data.model || {});

      return componentInstance;
    },
    unbind: function unbind() {
      // TODO: make unobserve..
    }
  };

  if (localExtensions) {
    rivets._.extensions.forEach(function (extensionName) {
      var extension = localExtensions[extensionName];

      if (extension) {
        descriptor[extensionName] = extension;
      }
    });
  }

  return descriptor;
}

function getStaticProperties(properties) {
  return Object.keys(properties).filter(function (property) {
    return isStaticProperty(properties, property);
  }).map(function (property) {
    return utils.toCamelCase(property);
  });
}

function isStaticProperty(properties, property) {
  return properties[property] && properties[property].static;
}

module.exports = registerComponent;
module.exports.createComponent = createComponent;
module.exports.Component = ComponentConstructor;

},{"./config.json":47,"./src/js/ComponentConstructor.js":49,"./src/js/buildModel.js":52,"./src/js/buildObservations.js":53,"rivets":"rivets","utils":"utils"}],49:[function(require,module,exports){
'use strict';

var _Promise = typeof Promise === 'undefined' ? require('es6-promise').Promise : Promise;

var utils = require('utils');
var builKeypath = require('./buildKeypath.js');
var getLocalizationByConstructor = require('./buildLocalization.js');
var generalModel = require('general-model');
var dispatcher = require('dispatcher');

function ComponentConstructor(element, model, view, binding) {
  this.element = element;
  this.parentScope = view.models;
  utils.mixin(this, model);
  this.element.model = this;
  this.element.view = {
    subscribe: subscribeToView.bind(this)
  };
  this.element.setAttribute('co-component', '');
  this.model = model;
  this.view = view;
  this.binding = binding;
  this.element.addEventListener('activate', handleActivation.bind(this));
  this.element.addEventListener('deactivate', handleDeactivation.bind(this));

  this.setIsConfigurable();
}

ComponentConstructor.prototype.isCommon = function () {
  return isCommonModel(this) || isCommonBinders(this);
};

ComponentConstructor.prototype.getTextElementsByProperty = function (property) {
  return utils.toArray(this.element.querySelectorAll('[rv-html]')).filter(function (element) {
    return element.getAttribute('rv-html') === property;
  }).filter(function (element) {
    return element.scope === this;
  }, this);
};

ComponentConstructor.prototype.getLocalization = function (lang) {
  return getLocalizationByConstructor(this.__proto__.constructor, lang);
};

ComponentConstructor.prototype.getAbsoluteKeypath = function () {
  return builKeypath(this.parentScope, this.getKeypath());
};

ComponentConstructor.prototype.getKeypath = function () {
  return this.element.getAttribute('model') || '';
};

ComponentConstructor.prototype.toJSON = function () {
  var that = this;
  return Object.keys(this).reduce(function (acc, property) {
    if (that.model.hasOwnProperty(property)) {
      acc[property] = that[property];
    }
    return acc;
  }, {});
};

ComponentConstructor.prototype.setIsConfigurable = function () {
  var keypath = this.getKeypath();
  Object.defineProperty(this, 'isConfigurable', {
    value: utils.startsWith(keypath, 'm.'),
    enumerable: true,
    configurable: false,
    writable: true
  });
};

ComponentConstructor.prototype.getLabel = function (lang) {
  return new _Promise(function (resolve, reject) {
    var label = getLabelFromElement(this.element);

    if (label) {
      resolve(label);
    } else {
      getLocalizationByConstructor(this.__proto__.constructor, lang).then(function (localization) {
        resolve(localization.name);
      }).catch(function (err) {
        resolve(getNameFromTagNameComponent(this.name || this.element.tagName.toLowerCase()));
      }.bind(this));
    }
  }.bind(this));
};

ComponentConstructor.prototype.setLabel = function (label) {
  this.element.setAttribute('user-label', label);
};

ComponentConstructor.prototype.subscribe = function (callback) {
  return new generalModel.ModelNotifier().observe(this.model).subscribe(function (model) {
    callback(model);
  }, true);
};

function getNameFromTagNameComponent(coTagName) {
  var normalName = coTagName.replace('co-', '').split('-').join(' ');

  return normalName[0].toUpperCase() + normalName.substring(1, normalName.lenght);
}

function handleActivation(event) {
  if (typeof this.activate === 'function' && isCobaltEvent(event)) {
    var prevModelState = utils.parse(this);
    this.activate(event.target);
    this.difference = utils.difference(prevModelState, utils.parse(this));
  }
}

function handleDeactivation(event) {
  if (typeof this.deactivate === 'function' && isCobaltEvent(event)) {
    this.deactivate(event.target);
  }

  utils.deepMixin(this, this.difference);
}

function isCobaltEvent(event) {
  return event.detail && !!event.detail.isCobaltEvent;
}

function isCommonModel(scope) {
  return getParentKeypathes(scope).some(function (keypath) {
    return isCommonKeypath(keypath);
  });
}

function isCommonBinders(scope) {
  var binders = scope.element && scope.element.binders;
  return binders && Object.keys(binders).some(function (binder) {
    return isCommonKeypath(binders[binder].keypath);
  });
}

function isCommonKeypath(keypath) {
  return utils.startsWith(keypath, 'm.common');
}

function getParentKeypathes(scope, keypathes) {
  keypathes = keypathes || [];
  if (scope && typeof scope.getKeypath === 'function') {
    keypathes.push(scope.getKeypath());
    getParentKeypathes(scope.parentScope, keypathes);
  }

  return keypathes;
}

function getLabelFromElement(element) {
  return element.getAttribute('user-label');
}

function subscribeToView(callback) {
  var _this = this;

  dispatcher.subscribeEvent(function (event) {
    if (event.type === dispatcher.EventType.DOM_REFRESHED && event.element === _this.element) {
      callback(_this.element);
    }
  });
}

exports.ComponentConstructor = ComponentConstructor;

},{"./buildKeypath.js":50,"./buildLocalization.js":51,"dispatcher":"dispatcher","es6-promise":"es6-promise","general-model":"general-model","utils":"utils"}],50:[function(require,module,exports){
'use strict';

function buildAbsoluteKeypath(parentPath, keypath) {
	var key = removeAlias(keypath);

	if (parentPath) {
		return key ? parentPath + '.' + removeAlias(keypath) : parentPath;
	} else {
		return keypath;
	}
}

function collectParentsKeypath(model, keypathes) {
	keypathes = keypathes || [];
	if (model && model.keypath) {
		keypathes.unshift(keypathModifier(model), model.index);
		collectParentsKeypath(model.__proto__, keypathes);
	}

	return keypathes;
}

function keypathModifier(model) {
	if (model.__proto__.keypath) {
		return removeAlias(model.keypath);
	}

	return model.keypath;
}

function removeAlias(keypath) {
	return keypath.split('.').slice(1).join('.');
}

module.exports = function (parentScope, keypath) {
	return buildAbsoluteKeypath(collectParentsKeypath(parentScope).join('.'), keypath);
};

},{}],51:[function(require,module,exports){
'use strict';

var _loader = require('loader');

var _utils = require('utils');

var _cache = require('cache');

var _cache2 = _interopRequireDefault(_cache);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _Promise = typeof Promise === 'undefined' ? require('es6-promise').Promise : Promise;

var cache = new _cache2.default();

module.exports = getLocalizationByConstructor;

function getLocalizationByConstructor(constructor, outsideLang) {
  var defaultLang = 'en';
  var lang = outsideLang || defaultLang;
  // TODO: works only if localizationTemplate and name were added to the prototype during component registration

  return getLocalization(constructor, lang, defaultLang).then(function (localization) {
    return extendLocalizationByScheme(localization.defaults, constructor.prototype.defaults, lang).then(function () {
      return localization;
    });
  });
}

function getLocalization(constructor, lang, defaultLang) {
  var localizationPath = getLocalizationPath(constructor, lang);

  return loadLocalizationData(localizationPath).then(function (localization) {
    if (isLocalization(localization)) {
      return localization;
    } else if (lang !== defaultLang) {
      var defaultLocalizationPath = getLocalizationPath(constructor, defaultLang);
      return loadLocalizationData(defaultLocalizationPath);
    }
    return _Promise.resolve({});
  });
}

function getLocalizationPath(constructor, lang) {
  return (0, _utils.template)(constructor.prototype.localizationTemplate, { name: constructor.prototype.name, lang: lang });
}

function loadLocalizationData(path) {
  var loadFromCache = true;
  var reviver = null;

  if (!cache.isCache(path)) {
    cache.set(path, (0, _loader.loadJSON)(path, reviver, loadFromCache));
  }

  return cache.get(path).then(function (data) {
    return Object.assign({}, data);
  });
}

function isLocalization(localization) {
  return localization && Object.keys(localization).length;
}

// if property described in scheme has 'base' defined, it's localization is extended with localization from 'base'
function extendLocalizationByScheme(localization, scheme, lang) {
  var localizationPromises = [];

  var _loop = function _loop(prop) {
    var propertyDescriptor = scheme[prop],
        localizationLoadingPromise = void 0;

    if (propertyDescriptor.sealed) {
      return 'continue';
    }

    if (propertyDescriptor.base) {
      localizationLoadingPromise = getLocalizationByConstructor(propertyDescriptor.base, lang).then(function (subLocalization) {
        return localization[prop].defaults = subLocalization.defaults;
      });
    } else if (propertyDescriptor.scheme) {
      localizationLoadingPromise = extendLocalizationByScheme(localization[prop].defaults, propertyDescriptor.scheme, lang);
    } else {
      return 'continue';
    }
    localizationPromises.push(localizationLoadingPromise);
  };

  for (var prop in scheme) {
    var _ret = _loop(prop);

    if (_ret === 'continue') continue;
  }

  return _Promise.all(localizationPromises);
}

},{"cache":2,"es6-promise":"es6-promise","loader":"loader","utils":"utils"}],52:[function(require,module,exports){
"use strict";

var utils = require("utils");

function buildModel(defaultProperties, data, name) {
	var defaultModel = getDefaultModel(defaultProperties),
	    elementModel = utils.toCamelCaseObject(data.model || {}),
	    attributesData = getDataFromAttributes(defaultProperties, data),
	    model = mixin(mixin(defaultModel, elementModel, defaultProperties), attributesData, defaultProperties);

	return model;
}

function mixin(target, source, defaultProperties) {
	Object.keys(source).forEach(function (property) {
		if (source.hasOwnProperty(property) && defined(source[property]) && defaultProperties.hasOwnProperty(property)) {
			if (target[property] && target[property].constructor === Object) {
				addMissingProperies(defaultProperties[property].value, source[property]); // add missing properties and keep reference for correct observing
			}
			target[property] = source[property];
		}
	});

	return target;
}

function addMissingProperies(defaultProperties, source) {
	return Object.keys(defaultProperties).forEach(function (property) {
		if (!source.hasOwnProperty(property)) {
			source[property] = defaultProperties[property];
		}
	});
}

function getDefaultModel(defaultProperties) {
	return Object.keys(defaultProperties).reduce(function (acc, property) {
		acc[property] = defaultProperties[property].value;
		return acc;
	}, {});
}

function getDataFromAttributes(defaultProperties, data) {
	return Object.keys(defaultProperties).reduce(function (acc, property) {
		if (data.hasOwnProperty(property)) {
			if (defaultProperties[property] && defaultProperties[property].static) {
				acc[property] = utils.revive(data[property]);
			} else {
				acc[property] = data[property];
			}
		}
		return acc;
	}, {});
}

function defined(value) {
	return value !== undefined && value !== null;
}

module.exports = buildModel;

},{"utils":"utils"}],53:[function(require,module,exports){
'use strict';

var generalModel = require('general-model');
var complexProperties = [Object, Array, DataView, 'Object', 'Array', 'DataView'];

module.exports = function buildObservations(componentInstance, defaultProperties, model) {
  Object.keys(defaultProperties).forEach(function (property) {
    model[property] = componentInstance[property];

    if (isRefreshableProperty(defaultProperties, property) && isComplexProperty(defaultProperties, property)) {
      observeComplexProperty(property, componentInstance);
    }

    this.observe(componentInstance, property, function () {
      if (isRefreshableProperty(defaultProperties, property)) {
        componentInstance.refresh(property);
      }
      componentInstance.model[property] = componentInstance[property];
      model[property] = componentInstance[property];
    });

    this.observe(componentInstance.model, property, function () {
      componentInstance[property] = componentInstance.model[property];
    });

    this.observe(model, property, function () {
      componentInstance[property] = model[property];
    });
  }, this);
};

function observeComplexProperty(property, componentInstance) {
  // setTimeout because nested bindings...
  setTimeout(function () {
    new generalModel.ModelNotifier().deepObserve(componentInstance, property).subscribe(function (model) {
      componentInstance.refresh(property);
    }, true);
  }, 50);
}

function isComplexProperty(defaultProperties, property) {
  var isComplexProp = complexProperties.indexOf(defaultProperties[property].type) !== -1;
  return !isComplexProp ? Array.isArray(defaultProperties[property].type) : isComplexProp;
}

function isRefreshableProperty(defaultProperties, property) {
  return !!defaultProperties[property].refresh;
}

},{"general-model":"general-model"}],54:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*! iScroll v5.2.0 ~ (c) 2008-2016 Matteo Spinelli ~ http://cubiq.org/license */
(function (window, document, Math) {
	var rAF = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) {
		window.setTimeout(callback, 1000 / 60);
	};

	var utils = function () {
		var me = {};

		var _elementStyle = document.createElement('div').style;
		var _vendor = function () {
			var vendors = ['t', 'webkitT', 'MozT', 'msT', 'OT'],
			    transform,
			    i = 0,
			    l = vendors.length;

			for (; i < l; i++) {
				transform = vendors[i] + 'ransform';
				if (transform in _elementStyle) return vendors[i].substr(0, vendors[i].length - 1);
			}

			return false;
		}();

		function _prefixStyle(style) {
			if (_vendor === false) return false;
			if (_vendor === '') return style;
			return _vendor + style.charAt(0).toUpperCase() + style.substr(1);
		}

		me.getTime = Date.now || function getTime() {
			return new Date().getTime();
		};

		me.extend = function (target, obj) {
			for (var i in obj) {
				target[i] = obj[i];
			}
		};

		me.addEvent = function (el, type, fn, capture) {
			el.addEventListener(type, fn, !!capture);
		};

		me.removeEvent = function (el, type, fn, capture) {
			el.removeEventListener(type, fn, !!capture);
		};

		me.prefixPointerEvent = function (pointerEvent) {
			return window.MSPointerEvent ? 'MSPointer' + pointerEvent.charAt(7).toUpperCase() + pointerEvent.substr(8) : pointerEvent;
		};

		me.momentum = function (current, start, time, lowerMargin, wrapperSize, deceleration) {
			var distance = current - start,
			    speed = Math.abs(distance) / time,
			    destination,
			    duration;

			deceleration = deceleration === undefined ? 0.0006 : deceleration;

			destination = current + speed * speed / (2 * deceleration) * (distance < 0 ? -1 : 1);
			duration = speed / deceleration;

			if (destination < lowerMargin) {
				destination = wrapperSize ? lowerMargin - wrapperSize / 2.5 * (speed / 8) : lowerMargin;
				distance = Math.abs(destination - current);
				duration = distance / speed;
			} else if (destination > 0) {
				destination = wrapperSize ? wrapperSize / 2.5 * (speed / 8) : 0;
				distance = Math.abs(current) + destination;
				duration = distance / speed;
			}

			return {
				destination: Math.round(destination),
				duration: duration
			};
		};

		var _transform = _prefixStyle('transform');

		me.extend(me, {
			hasTransform: _transform !== false,
			hasPerspective: _prefixStyle('perspective') in _elementStyle,
			hasTouch: 'ontouchstart' in window,
			hasPointer: !!(window.PointerEvent || window.MSPointerEvent), // IE10 is prefixed
			hasTransition: _prefixStyle('transition') in _elementStyle
		});

		/*
  This should find all Android browsers lower than build 535.19 (both stock browser and webview)
  - galaxy S2 is ok
     - 2.3.6 : `AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1`
     - 4.0.4 : `AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30`
    - galaxy S3 is badAndroid (stock brower, webview)
      `AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30`
    - galaxy S4 is badAndroid (stock brower, webview)
      `AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30`
    - galaxy S5 is OK
      `AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Mobile Safari/537.36 (Chrome/)`
    - galaxy S6 is OK
      `AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Mobile Safari/537.36 (Chrome/)`
   */
		me.isBadAndroid = function () {
			var appVersion = window.navigator.appVersion;
			// Android browser is not a chrome browser.
			if (/Android/.test(appVersion) && !/Chrome\/\d/.test(appVersion)) {
				var safariVersion = appVersion.match(/Safari\/(\d+.\d)/);
				if (safariVersion && (typeof safariVersion === 'undefined' ? 'undefined' : _typeof(safariVersion)) === "object" && safariVersion.length >= 2) {
					return parseFloat(safariVersion[1]) < 535.19;
				} else {
					return true;
				}
			} else {
				return false;
			}
		}();

		me.extend(me.style = {}, {
			transform: _transform,
			transitionTimingFunction: _prefixStyle('transitionTimingFunction'),
			transitionDuration: _prefixStyle('transitionDuration'),
			transitionDelay: _prefixStyle('transitionDelay'),
			transformOrigin: _prefixStyle('transformOrigin')
		});

		me.hasClass = function (e, c) {
			var re = new RegExp("(^|\\s)" + c + "(\\s|$)");
			return re.test(e.className);
		};

		me.addClass = function (e, c) {
			if (me.hasClass(e, c)) {
				return;
			}

			var newclass = e.className.split(' ');
			newclass.push(c);
			e.className = newclass.join(' ');
		};

		me.removeClass = function (e, c) {
			if (!me.hasClass(e, c)) {
				return;
			}

			var re = new RegExp("(^|\\s)" + c + "(\\s|$)", 'g');
			e.className = e.className.replace(re, ' ');
		};

		me.offset = function (el) {
			var left = -el.offsetLeft,
			    top = -el.offsetTop;

			// jshint -W084
			while (el = el.offsetParent) {
				left -= el.offsetLeft;
				top -= el.offsetTop;
			}
			// jshint +W084

			return {
				left: left,
				top: top
			};
		};

		me.preventDefaultException = function (el, exceptions) {
			for (var i in exceptions) {
				if (exceptions[i].test(el[i])) {
					return true;
				}
			}

			return false;
		};

		me.extend(me.eventType = {}, {
			touchstart: 1,
			touchmove: 1,
			touchend: 1,

			mousedown: 2,
			mousemove: 2,
			mouseup: 2,

			pointerdown: 3,
			pointermove: 3,
			pointerup: 3,

			MSPointerDown: 3,
			MSPointerMove: 3,
			MSPointerUp: 3
		});

		me.extend(me.ease = {}, {
			quadratic: {
				style: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)',
				fn: function fn(k) {
					return k * (2 - k);
				}
			},
			circular: {
				style: 'cubic-bezier(0.1, 0.57, 0.1, 1)', // Not properly "circular" but this looks better, it should be (0.075, 0.82, 0.165, 1)
				fn: function fn(k) {
					return Math.sqrt(1 - --k * k);
				}
			},
			back: {
				style: 'cubic-bezier(0.175, 0.885, 0.32, 1.275)',
				fn: function fn(k) {
					var b = 4;
					return (k = k - 1) * k * ((b + 1) * k + b) + 1;
				}
			},
			bounce: {
				style: '',
				fn: function fn(k) {
					if ((k /= 1) < 1 / 2.75) {
						return 7.5625 * k * k;
					} else if (k < 2 / 2.75) {
						return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;
					} else if (k < 2.5 / 2.75) {
						return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;
					} else {
						return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;
					}
				}
			},
			elastic: {
				style: '',
				fn: function fn(k) {
					var f = 0.22,
					    e = 0.4;

					if (k === 0) {
						return 0;
					}
					if (k == 1) {
						return 1;
					}

					return e * Math.pow(2, -10 * k) * Math.sin((k - f / 4) * (2 * Math.PI) / f) + 1;
				}
			}
		});

		me.tap = function (e, eventName) {
			var ev = document.createEvent('Event');
			ev.initEvent(eventName, true, true);
			ev.pageX = e.pageX;
			ev.pageY = e.pageY;
			e.target.dispatchEvent(ev);
		};

		me.click = function (e) {
			var target = e.target,
			    ev;

			if (!/(SELECT|INPUT|TEXTAREA)/i.test(target.tagName)) {
				ev = document.createEvent('MouseEvents');
				ev.initMouseEvent('click', true, true, e.view, 1, target.screenX, target.screenY, target.clientX, target.clientY, e.ctrlKey, e.altKey, e.shiftKey, e.metaKey, 0, null);

				ev._constructed = true;
				target.dispatchEvent(ev);
			}
		};

		return me;
	}();
	function IScroll(el, options) {
		this.wrapper = typeof el == 'string' ? document.querySelector(el) : el;
		this.scroller = this.wrapper.children[0];
		this.scrollerStyle = this.scroller.style; // cache style for better performance

		this.options = {

			resizeScrollbars: true,

			mouseWheelSpeed: 20,

			snapThreshold: 0.334,

			// INSERT POINT: OPTIONS
			disablePointer: !utils.hasPointer,
			disableTouch: utils.hasPointer || !utils.hasTouch,
			disableMouse: utils.hasPointer || utils.hasTouch,
			startX: 0,
			startY: 0,
			scrollY: true,
			directionLockThreshold: 5,
			momentum: true,

			bounce: true,
			bounceTime: 600,
			bounceEasing: '',

			preventDefault: true,
			preventDefaultException: { tagName: /^(INPUT|TEXTAREA|BUTTON|SELECT)$/ },

			HWCompositing: true,
			useTransition: true,
			useTransform: true,
			bindToWrapper: typeof window.onmousedown === "undefined"
		};

		for (var i in options) {
			this.options[i] = options[i];
		}

		// Normalize options
		this.translateZ = this.options.HWCompositing && utils.hasPerspective ? ' translateZ(0)' : '';

		this.options.useTransition = utils.hasTransition && this.options.useTransition;
		this.options.useTransform = utils.hasTransform && this.options.useTransform;

		this.options.eventPassthrough = this.options.eventPassthrough === true ? 'vertical' : this.options.eventPassthrough;
		this.options.preventDefault = !this.options.eventPassthrough && this.options.preventDefault;

		// If you want eventPassthrough I have to lock one of the axes
		this.options.scrollY = this.options.eventPassthrough == 'vertical' ? false : this.options.scrollY;
		this.options.scrollX = this.options.eventPassthrough == 'horizontal' ? false : this.options.scrollX;

		// With eventPassthrough we also need lockDirection mechanism
		this.options.freeScroll = this.options.freeScroll && !this.options.eventPassthrough;
		this.options.directionLockThreshold = this.options.eventPassthrough ? 0 : this.options.directionLockThreshold;

		this.options.bounceEasing = typeof this.options.bounceEasing == 'string' ? utils.ease[this.options.bounceEasing] || utils.ease.circular : this.options.bounceEasing;

		this.options.resizePolling = this.options.resizePolling === undefined ? 60 : this.options.resizePolling;

		if (this.options.tap === true) {
			this.options.tap = 'tap';
		}

		if (this.options.shrinkScrollbars == 'scale') {
			this.options.useTransition = false;
		}

		this.options.invertWheelDirection = this.options.invertWheelDirection ? -1 : 1;

		if (this.options.probeType == 3) {
			this.options.useTransition = false;
		}

		// INSERT POINT: NORMALIZATION

		// Some defaults
		this.x = 0;
		this.y = 0;
		this.directionX = 0;
		this.directionY = 0;
		this._events = {};

		// INSERT POINT: DEFAULTS

		this._init();
		this.refresh();

		this.scrollTo(this.options.startX, this.options.startY);
		this.enable();
	}

	IScroll.prototype = {
		version: '5.2.0',

		_init: function _init() {
			this._initEvents();

			if (this.options.scrollbars || this.options.indicators) {
				this._initIndicators();
			}

			if (this.options.mouseWheel) {
				this._initWheel();
			}

			if (this.options.snap) {
				this._initSnap();
			}

			if (this.options.keyBindings) {
				this._initKeys();
			}

			// INSERT POINT: _init
		},

		destroy: function destroy() {
			this._initEvents(true);
			clearTimeout(this.resizeTimeout);
			this.resizeTimeout = null;
			this._execEvent('destroy');
		},

		_transitionEnd: function _transitionEnd(e) {
			if (e.target != this.scroller || !this.isInTransition) {
				return;
			}

			this._transitionTime();
			if (!this.resetPosition(this.options.bounceTime)) {
				this.isInTransition = false;
				this._execEvent('scrollEnd');
			}
		},

		_start: function _start(e) {
			// React to left mouse button only
			if (utils.eventType[e.type] != 1) {
				// for button property
				// http://unixpapa.com/js/mouse.html
				var button;
				if (!e.which) {
					/* IE case */
					button = e.button < 2 ? 0 : e.button == 4 ? 1 : 2;
				} else {
					/* All others */
					button = e.button;
				}
				if (button !== 0) {
					return;
				}
			}

			if (!this.enabled || this.initiated && utils.eventType[e.type] !== this.initiated) {
				return;
			}

			if (this.options.preventDefault && !utils.isBadAndroid && !utils.preventDefaultException(e.target, this.options.preventDefaultException)) {
				e.preventDefault();
			}

			var point = e.touches ? e.touches[0] : e,
			    pos;

			this.initiated = utils.eventType[e.type];
			this.moved = false;
			this.distX = 0;
			this.distY = 0;
			this.directionX = 0;
			this.directionY = 0;
			this.directionLocked = 0;

			this.startTime = utils.getTime();

			if (this.options.useTransition && this.isInTransition) {
				this._transitionTime();
				this.isInTransition = false;
				pos = this.getComputedPosition();
				this._translate(Math.round(pos.x), Math.round(pos.y));
				this._execEvent('scrollEnd');
			} else if (!this.options.useTransition && this.isAnimating) {
				this.isAnimating = false;
				this._execEvent('scrollEnd');
			}

			this.startX = this.x;
			this.startY = this.y;
			this.absStartX = this.x;
			this.absStartY = this.y;
			this.pointX = point.pageX;
			this.pointY = point.pageY;

			this._execEvent('beforeScrollStart');
		},

		_move: function _move(e) {
			if (!this.enabled || utils.eventType[e.type] !== this.initiated) {
				return;
			}

			if (this.options.preventDefault) {
				// increases performance on Android? TODO: check!
				e.preventDefault();
			}

			var point = e.touches ? e.touches[0] : e,
			    deltaX = point.pageX - this.pointX,
			    deltaY = point.pageY - this.pointY,
			    timestamp = utils.getTime(),
			    newX,
			    newY,
			    absDistX,
			    absDistY;

			this.pointX = point.pageX;
			this.pointY = point.pageY;

			this.distX += deltaX;
			this.distY += deltaY;
			absDistX = Math.abs(this.distX);
			absDistY = Math.abs(this.distY);

			// We need to move at least 10 pixels for the scrolling to initiate
			if (timestamp - this.endTime > 300 && absDistX < 10 && absDistY < 10) {
				return;
			}

			// If you are scrolling in one direction lock the other
			if (!this.directionLocked && !this.options.freeScroll) {
				if (absDistX > absDistY + this.options.directionLockThreshold) {
					this.directionLocked = 'h'; // lock horizontally
				} else if (absDistY >= absDistX + this.options.directionLockThreshold) {
					this.directionLocked = 'v'; // lock vertically
				} else {
					this.directionLocked = 'n'; // no lock
				}
			}

			if (this.directionLocked == 'h') {
				if (this.options.eventPassthrough == 'vertical') {
					e.preventDefault();
				} else if (this.options.eventPassthrough == 'horizontal') {
					this.initiated = false;
					return;
				}

				deltaY = 0;
			} else if (this.directionLocked == 'v') {
				if (this.options.eventPassthrough == 'horizontal') {
					e.preventDefault();
				} else if (this.options.eventPassthrough == 'vertical') {
					this.initiated = false;
					return;
				}

				deltaX = 0;
			}

			deltaX = this.hasHorizontalScroll ? deltaX : 0;
			deltaY = this.hasVerticalScroll ? deltaY : 0;

			newX = this.x + deltaX;
			newY = this.y + deltaY;

			// Slow down if outside of the boundaries
			if (newX > 0 || newX < this.maxScrollX) {
				newX = this.options.bounce ? this.x + deltaX / 3 : newX > 0 ? 0 : this.maxScrollX;
			}
			if (newY > 0 || newY < this.maxScrollY) {
				newY = this.options.bounce ? this.y + deltaY / 3 : newY > 0 ? 0 : this.maxScrollY;
			}

			this.directionX = deltaX > 0 ? -1 : deltaX < 0 ? 1 : 0;
			this.directionY = deltaY > 0 ? -1 : deltaY < 0 ? 1 : 0;

			if (!this.moved) {
				this._execEvent('scrollStart');
			}

			this.moved = true;

			this._translate(newX, newY);

			/* REPLACE START: _move */
			if (timestamp - this.startTime > 300) {
				this.startTime = timestamp;
				this.startX = this.x;
				this.startY = this.y;

				if (this.options.probeType == 1) {
					this._execEvent('scroll');
				}
			}

			if (this.options.probeType > 1) {
				this._execEvent('scroll');
			}
			/* REPLACE END: _move */
		},

		_end: function _end(e) {
			if (!this.enabled || utils.eventType[e.type] !== this.initiated) {
				return;
			}

			if (this.options.preventDefault && !utils.preventDefaultException(e.target, this.options.preventDefaultException)) {
				e.preventDefault();
			}

			var point = e.changedTouches ? e.changedTouches[0] : e,
			    momentumX,
			    momentumY,
			    duration = utils.getTime() - this.startTime,
			    newX = Math.round(this.x),
			    newY = Math.round(this.y),
			    distanceX = Math.abs(newX - this.startX),
			    distanceY = Math.abs(newY - this.startY),
			    time = 0,
			    easing = '';

			this.isInTransition = 0;
			this.initiated = 0;
			this.endTime = utils.getTime();

			// reset if we are outside of the boundaries
			if (this.resetPosition(this.options.bounceTime)) {
				return;
			}

			this.scrollTo(newX, newY); // ensures that the last position is rounded

			// we scrolled less than 10 pixels
			if (!this.moved) {
				if (this.options.tap) {
					utils.tap(e, this.options.tap);
				}

				if (this.options.click) {
					utils.click(e);
				}

				this._execEvent('scrollCancel');
				return;
			}

			if (this._events.flick && duration < 200 && distanceX < 100 && distanceY < 100) {
				this._execEvent('flick');
				return;
			}

			// start momentum animation if needed
			if (this.options.momentum && duration < 300) {
				momentumX = this.hasHorizontalScroll ? utils.momentum(this.x, this.startX, duration, this.maxScrollX, this.options.bounce ? this.wrapperWidth : 0, this.options.deceleration) : { destination: newX, duration: 0 };
				momentumY = this.hasVerticalScroll ? utils.momentum(this.y, this.startY, duration, this.maxScrollY, this.options.bounce ? this.wrapperHeight : 0, this.options.deceleration) : { destination: newY, duration: 0 };
				newX = momentumX.destination;
				newY = momentumY.destination;
				time = Math.max(momentumX.duration, momentumY.duration);
				this.isInTransition = 1;
			}

			if (this.options.snap) {
				var snap = this._nearestSnap(newX, newY);
				this.currentPage = snap;
				time = this.options.snapSpeed || Math.max(Math.max(Math.min(Math.abs(newX - snap.x), 1000), Math.min(Math.abs(newY - snap.y), 1000)), 300);
				newX = snap.x;
				newY = snap.y;

				this.directionX = 0;
				this.directionY = 0;
				easing = this.options.bounceEasing;
			}

			// INSERT POINT: _end

			if (newX != this.x || newY != this.y) {
				// change easing function when scroller goes out of the boundaries
				if (newX > 0 || newX < this.maxScrollX || newY > 0 || newY < this.maxScrollY) {
					easing = utils.ease.quadratic;
				}

				this.scrollTo(newX, newY, time, easing);
				return;
			}

			this._execEvent('scrollEnd');
		},

		_resize: function _resize() {
			var that = this;

			clearTimeout(this.resizeTimeout);

			this.resizeTimeout = setTimeout(function () {
				that.refresh();
			}, this.options.resizePolling);
		},

		resetPosition: function resetPosition(time) {
			var x = this.x,
			    y = this.y;

			time = time || 0;

			if (!this.hasHorizontalScroll || this.x > 0) {
				x = 0;
			} else if (this.x < this.maxScrollX) {
				x = this.maxScrollX;
			}

			if (!this.hasVerticalScroll || this.y > 0) {
				y = 0;
			} else if (this.y < this.maxScrollY) {
				y = this.maxScrollY;
			}

			if (x == this.x && y == this.y) {
				return false;
			}

			this.scrollTo(x, y, time, this.options.bounceEasing);

			return true;
		},

		disable: function disable() {
			this.enabled = false;
		},

		enable: function enable() {
			this.enabled = true;
		},

		refresh: function refresh() {
			var rf = this.wrapper.offsetHeight; // Force reflow

			this.wrapperWidth = this.wrapper.clientWidth;
			this.wrapperHeight = this.wrapper.clientHeight;

			/* REPLACE START: refresh */

			this.scrollerWidth = this.scroller.offsetWidth;
			this.scrollerHeight = this.scroller.offsetHeight;

			this.maxScrollX = this.wrapperWidth - this.scrollerWidth;
			this.maxScrollY = this.wrapperHeight - this.scrollerHeight;

			/* REPLACE END: refresh */

			this.hasHorizontalScroll = this.options.scrollX && this.maxScrollX < 0;
			this.hasVerticalScroll = this.options.scrollY && this.maxScrollY < 0;

			if (!this.hasHorizontalScroll) {
				this.maxScrollX = 0;
				this.scrollerWidth = this.wrapperWidth;
			}

			if (!this.hasVerticalScroll) {
				this.maxScrollY = 0;
				this.scrollerHeight = this.wrapperHeight;
			}

			this.endTime = 0;
			this.directionX = 0;
			this.directionY = 0;

			this.wrapperOffset = utils.offset(this.wrapper);

			this._execEvent('refresh');

			this.resetPosition();

			// INSERT POINT: _refresh
		},

		on: function on(type, fn) {
			if (!this._events[type]) {
				this._events[type] = [];
			}

			this._events[type].push(fn);
		},

		off: function off(type, fn) {
			if (!this._events[type]) {
				return;
			}

			var index = this._events[type].indexOf(fn);

			if (index > -1) {
				this._events[type].splice(index, 1);
			}
		},

		_execEvent: function _execEvent(type) {
			if (!this._events[type]) {
				return;
			}

			var i = 0,
			    l = this._events[type].length;

			if (!l) {
				return;
			}

			for (; i < l; i++) {
				this._events[type][i].apply(this, [].slice.call(arguments, 1));
			}
		},

		scrollBy: function scrollBy(x, y, time, easing) {
			x = this.x + x;
			y = this.y + y;
			time = time || 0;

			this.scrollTo(x, y, time, easing);
		},

		scrollTo: function scrollTo(x, y, time, easing) {
			easing = easing || utils.ease.circular;

			this.isInTransition = this.options.useTransition && time > 0;
			var transitionType = this.options.useTransition && easing.style;
			if (!time || transitionType) {
				if (transitionType) {
					this._transitionTimingFunction(easing.style);
					this._transitionTime(time);
				}
				this._translate(x, y);
			} else {
				this._animate(x, y, time, easing.fn);
			}
		},

		scrollToElement: function scrollToElement(el, time, offsetX, offsetY, easing) {
			el = el.nodeType ? el : this.scroller.querySelector(el);

			if (!el) {
				return;
			}

			var pos = utils.offset(el);

			pos.left -= this.wrapperOffset.left;
			pos.top -= this.wrapperOffset.top;

			// if offsetX/Y are true we center the element to the screen
			if (offsetX === true) {
				offsetX = Math.round(el.offsetWidth / 2 - this.wrapper.offsetWidth / 2);
			}
			if (offsetY === true) {
				offsetY = Math.round(el.offsetHeight / 2 - this.wrapper.offsetHeight / 2);
			}

			pos.left -= offsetX || 0;
			pos.top -= offsetY || 0;

			pos.left = pos.left > 0 ? 0 : pos.left < this.maxScrollX ? this.maxScrollX : pos.left;
			pos.top = pos.top > 0 ? 0 : pos.top < this.maxScrollY ? this.maxScrollY : pos.top;

			time = time === undefined || time === null || time === 'auto' ? Math.max(Math.abs(this.x - pos.left), Math.abs(this.y - pos.top)) : time;

			this.scrollTo(pos.left, pos.top, time, easing);
		},

		_transitionTime: function _transitionTime(time) {
			time = time || 0;

			var durationProp = utils.style.transitionDuration;
			this.scrollerStyle[durationProp] = time + 'ms';

			if (!time && utils.isBadAndroid) {
				this.scrollerStyle[durationProp] = '0.0001ms';
				// remove 0.0001ms
				var self = this;
				rAF(function () {
					if (self.scrollerStyle[durationProp] === '0.0001ms') {
						self.scrollerStyle[durationProp] = '0s';
					}
				});
			}

			if (this.indicators) {
				for (var i = this.indicators.length; i--;) {
					this.indicators[i].transitionTime(time);
				}
			}

			// INSERT POINT: _transitionTime
		},

		_transitionTimingFunction: function _transitionTimingFunction(easing) {
			this.scrollerStyle[utils.style.transitionTimingFunction] = easing;

			if (this.indicators) {
				for (var i = this.indicators.length; i--;) {
					this.indicators[i].transitionTimingFunction(easing);
				}
			}

			// INSERT POINT: _transitionTimingFunction
		},

		_translate: function _translate(x, y) {
			if (this.options.useTransform) {

				/* REPLACE START: _translate */

				this.scrollerStyle[utils.style.transform] = 'translate(' + x + 'px,' + y + 'px)' + this.translateZ;

				/* REPLACE END: _translate */
			} else {
				x = Math.round(x);
				y = Math.round(y);
				this.scrollerStyle.left = x + 'px';
				this.scrollerStyle.top = y + 'px';
			}

			this.x = x;
			this.y = y;

			if (this.indicators) {
				for (var i = this.indicators.length; i--;) {
					this.indicators[i].updatePosition();
				}
			}

			// INSERT POINT: _translate
		},

		_initEvents: function _initEvents(remove) {
			var eventType = remove ? utils.removeEvent : utils.addEvent,
			    target = this.options.bindToWrapper ? this.wrapper : window;

			eventType(window, 'orientationchange', this);
			eventType(window, 'resize', this);

			if (this.options.click) {
				eventType(this.wrapper, 'click', this, true);
			}

			if (!this.options.disableMouse) {
				eventType(this.wrapper, 'mousedown', this);
				eventType(target, 'mousemove', this);
				eventType(target, 'mousecancel', this);
				eventType(target, 'mouseup', this);
			}

			if (utils.hasPointer && !this.options.disablePointer) {
				eventType(this.wrapper, utils.prefixPointerEvent('pointerdown'), this);
				eventType(target, utils.prefixPointerEvent('pointermove'), this);
				eventType(target, utils.prefixPointerEvent('pointercancel'), this);
				eventType(target, utils.prefixPointerEvent('pointerup'), this);
			}

			if (utils.hasTouch && !this.options.disableTouch) {
				eventType(this.wrapper, 'touchstart', this);
				eventType(target, 'touchmove', this);
				eventType(target, 'touchcancel', this);
				eventType(target, 'touchend', this);
			}

			eventType(this.scroller, 'transitionend', this);
			eventType(this.scroller, 'webkitTransitionEnd', this);
			eventType(this.scroller, 'oTransitionEnd', this);
			eventType(this.scroller, 'MSTransitionEnd', this);
		},

		getComputedPosition: function getComputedPosition() {
			var matrix = window.getComputedStyle(this.scroller, null),
			    x,
			    y;

			if (this.options.useTransform) {
				matrix = matrix[utils.style.transform].split(')')[0].split(', ');
				x = +(matrix[12] || matrix[4]);
				y = +(matrix[13] || matrix[5]);
			} else {
				x = +matrix.left.replace(/[^-\d.]/g, '');
				y = +matrix.top.replace(/[^-\d.]/g, '');
			}

			return { x: x, y: y };
		},
		_initIndicators: function _initIndicators() {
			var interactive = this.options.interactiveScrollbars,
			    customStyle = typeof this.options.scrollbars != 'string',
			    indicators = [],
			    indicator;

			var that = this;

			this.indicators = [];

			if (this.options.scrollbars) {
				// Vertical scrollbar
				if (this.options.scrollY) {
					indicator = {
						el: createDefaultScrollbar('v', interactive, this.options.scrollbars),
						interactive: interactive,
						defaultScrollbars: true,
						customStyle: customStyle,
						resize: this.options.resizeScrollbars,
						shrink: this.options.shrinkScrollbars,
						fade: this.options.fadeScrollbars,
						listenX: false
					};

					this.wrapper.appendChild(indicator.el);
					indicators.push(indicator);
				}

				// Horizontal scrollbar
				if (this.options.scrollX) {
					indicator = {
						el: createDefaultScrollbar('h', interactive, this.options.scrollbars),
						interactive: interactive,
						defaultScrollbars: true,
						customStyle: customStyle,
						resize: this.options.resizeScrollbars,
						shrink: this.options.shrinkScrollbars,
						fade: this.options.fadeScrollbars,
						listenY: false
					};

					this.wrapper.appendChild(indicator.el);
					indicators.push(indicator);
				}
			}

			if (this.options.indicators) {
				// TODO: check concat compatibility
				indicators = indicators.concat(this.options.indicators);
			}

			for (var i = indicators.length; i--;) {
				this.indicators.push(new Indicator(this, indicators[i]));
			}

			// TODO: check if we can use array.map (wide compatibility and performance issues)
			function _indicatorsMap(fn) {
				if (that.indicators) {
					for (var i = that.indicators.length; i--;) {
						fn.call(that.indicators[i]);
					}
				}
			}

			if (this.options.fadeScrollbars) {
				this.on('scrollEnd', function () {
					_indicatorsMap(function () {
						this.fade();
					});
				});

				this.on('scrollCancel', function () {
					_indicatorsMap(function () {
						this.fade();
					});
				});

				this.on('scrollStart', function () {
					_indicatorsMap(function () {
						this.fade(1);
					});
				});

				this.on('beforeScrollStart', function () {
					_indicatorsMap(function () {
						this.fade(1, true);
					});
				});
			}

			this.on('refresh', function () {
				_indicatorsMap(function () {
					this.refresh();
				});
			});

			this.on('destroy', function () {
				_indicatorsMap(function () {
					this.destroy();
				});

				delete this.indicators;
			});
		},

		_initWheel: function _initWheel() {
			utils.addEvent(this.wrapper, 'wheel', this);
			utils.addEvent(this.wrapper, 'mousewheel', this);
			utils.addEvent(this.wrapper, 'DOMMouseScroll', this);

			this.on('destroy', function () {
				clearTimeout(this.wheelTimeout);
				this.wheelTimeout = null;
				utils.removeEvent(this.wrapper, 'wheel', this);
				utils.removeEvent(this.wrapper, 'mousewheel', this);
				utils.removeEvent(this.wrapper, 'DOMMouseScroll', this);
			});
		},

		_wheel: function _wheel(e) {
			if (!this.enabled) {
				return;
			}

			e.preventDefault();

			var wheelDeltaX,
			    wheelDeltaY,
			    newX,
			    newY,
			    that = this;

			if (this.wheelTimeout === undefined) {
				that._execEvent('scrollStart');
			}

			// Execute the scrollEnd event after 400ms the wheel stopped scrolling
			clearTimeout(this.wheelTimeout);
			this.wheelTimeout = setTimeout(function () {
				if (!that.options.snap) {
					that._execEvent('scrollEnd');
				}
				that.wheelTimeout = undefined;
			}, 400);

			if ('deltaX' in e) {
				if (e.deltaMode === 1) {
					wheelDeltaX = -e.deltaX * this.options.mouseWheelSpeed;
					wheelDeltaY = -e.deltaY * this.options.mouseWheelSpeed;
				} else {
					wheelDeltaX = -e.deltaX;
					wheelDeltaY = -e.deltaY;
				}
			} else if ('wheelDeltaX' in e) {
				wheelDeltaX = e.wheelDeltaX / 120 * this.options.mouseWheelSpeed;
				wheelDeltaY = e.wheelDeltaY / 120 * this.options.mouseWheelSpeed;
			} else if ('wheelDelta' in e) {
				wheelDeltaX = wheelDeltaY = e.wheelDelta / 120 * this.options.mouseWheelSpeed;
			} else if ('detail' in e) {
				wheelDeltaX = wheelDeltaY = -e.detail / 3 * this.options.mouseWheelSpeed;
			} else {
				return;
			}

			wheelDeltaX *= this.options.invertWheelDirection;
			wheelDeltaY *= this.options.invertWheelDirection;

			if (!this.hasVerticalScroll) {
				wheelDeltaX = wheelDeltaY;
				wheelDeltaY = 0;
			}

			if (this.options.snap) {
				newX = this.currentPage.pageX;
				newY = this.currentPage.pageY;

				if (wheelDeltaX > 0) {
					newX--;
				} else if (wheelDeltaX < 0) {
					newX++;
				}

				if (wheelDeltaY > 0) {
					newY--;
				} else if (wheelDeltaY < 0) {
					newY++;
				}

				this.goToPage(newX, newY);

				return;
			}

			newX = this.x + Math.round(this.hasHorizontalScroll ? wheelDeltaX : 0);
			newY = this.y + Math.round(this.hasVerticalScroll ? wheelDeltaY : 0);

			this.directionX = wheelDeltaX > 0 ? -1 : wheelDeltaX < 0 ? 1 : 0;
			this.directionY = wheelDeltaY > 0 ? -1 : wheelDeltaY < 0 ? 1 : 0;

			if (newX > 0) {
				newX = 0;
			} else if (newX < this.maxScrollX) {
				newX = this.maxScrollX;
			}

			if (newY > 0) {
				newY = 0;
			} else if (newY < this.maxScrollY) {
				newY = this.maxScrollY;
			}

			this.scrollTo(newX, newY, 0);

			if (this.options.probeType > 1) {
				this._execEvent('scroll');
			}

			// INSERT POINT: _wheel
		},

		_initSnap: function _initSnap() {
			this.currentPage = {};

			if (typeof this.options.snap == 'string') {
				this.options.snap = this.scroller.querySelectorAll(this.options.snap);
			}

			this.on('refresh', function () {
				var i = 0,
				    l,
				    m = 0,
				    n,
				    cx,
				    cy,
				    x = 0,
				    y,
				    stepX = this.options.snapStepX || this.wrapperWidth,
				    stepY = this.options.snapStepY || this.wrapperHeight,
				    el;

				this.pages = [];

				if (!this.wrapperWidth || !this.wrapperHeight || !this.scrollerWidth || !this.scrollerHeight) {
					return;
				}

				if (this.options.snap === true) {
					cx = Math.round(stepX / 2);
					cy = Math.round(stepY / 2);

					while (x > -this.scrollerWidth) {
						this.pages[i] = [];
						l = 0;
						y = 0;

						while (y > -this.scrollerHeight) {
							this.pages[i][l] = {
								x: Math.max(x, this.maxScrollX),
								y: Math.max(y, this.maxScrollY),
								width: stepX,
								height: stepY,
								cx: x - cx,
								cy: y - cy
							};

							y -= stepY;
							l++;
						}

						x -= stepX;
						i++;
					}
				} else {
					el = this.options.snap;
					l = el.length;
					n = -1;

					for (; i < l; i++) {
						if (i === 0 || el[i].offsetLeft <= el[i - 1].offsetLeft) {
							m = 0;
							n++;
						}

						if (!this.pages[m]) {
							this.pages[m] = [];
						}

						x = Math.max(-el[i].offsetLeft, this.maxScrollX);
						y = Math.max(-el[i].offsetTop, this.maxScrollY);
						cx = x - Math.round(el[i].offsetWidth / 2);
						cy = y - Math.round(el[i].offsetHeight / 2);

						this.pages[m][n] = {
							x: x,
							y: y,
							width: el[i].offsetWidth,
							height: el[i].offsetHeight,
							cx: cx,
							cy: cy
						};

						if (x > this.maxScrollX) {
							m++;
						}
					}
				}

				this.goToPage(this.currentPage.pageX || 0, this.currentPage.pageY || 0, 0);

				// Update snap threshold if needed
				if (this.options.snapThreshold % 1 === 0) {
					this.snapThresholdX = this.options.snapThreshold;
					this.snapThresholdY = this.options.snapThreshold;
				} else {
					this.snapThresholdX = Math.round(this.pages[this.currentPage.pageX][this.currentPage.pageY].width * this.options.snapThreshold);
					this.snapThresholdY = Math.round(this.pages[this.currentPage.pageX][this.currentPage.pageY].height * this.options.snapThreshold);
				}
			});

			this.on('flick', function () {
				var time = this.options.snapSpeed || Math.max(Math.max(Math.min(Math.abs(this.x - this.startX), 1000), Math.min(Math.abs(this.y - this.startY), 1000)), 300);

				this.goToPage(this.currentPage.pageX + this.directionX, this.currentPage.pageY + this.directionY, time);
			});
		},

		_nearestSnap: function _nearestSnap(x, y) {
			if (!this.pages.length) {
				return { x: 0, y: 0, pageX: 0, pageY: 0 };
			}

			var i = 0,
			    l = this.pages.length,
			    m = 0;

			// Check if we exceeded the snap threshold
			if (Math.abs(x - this.absStartX) < this.snapThresholdX && Math.abs(y - this.absStartY) < this.snapThresholdY) {
				return this.currentPage;
			}

			if (x > 0) {
				x = 0;
			} else if (x < this.maxScrollX) {
				x = this.maxScrollX;
			}

			if (y > 0) {
				y = 0;
			} else if (y < this.maxScrollY) {
				y = this.maxScrollY;
			}

			for (; i < l; i++) {
				if (x >= this.pages[i][0].cx) {
					x = this.pages[i][0].x;
					break;
				}
			}

			l = this.pages[i].length;

			for (; m < l; m++) {
				if (y >= this.pages[0][m].cy) {
					y = this.pages[0][m].y;
					break;
				}
			}

			if (i == this.currentPage.pageX) {
				i += this.directionX;

				if (i < 0) {
					i = 0;
				} else if (i >= this.pages.length) {
					i = this.pages.length - 1;
				}

				x = this.pages[i][0].x;
			}

			if (m == this.currentPage.pageY) {
				m += this.directionY;

				if (m < 0) {
					m = 0;
				} else if (m >= this.pages[0].length) {
					m = this.pages[0].length - 1;
				}

				y = this.pages[0][m].y;
			}

			return {
				x: x,
				y: y,
				pageX: i,
				pageY: m
			};
		},

		goToPage: function goToPage(x, y, time, easing) {
			easing = easing || this.options.bounceEasing;

			if (x >= this.pages.length) {
				x = this.pages.length - 1;
			} else if (x < 0) {
				x = 0;
			}

			if (y >= this.pages[x].length) {
				y = this.pages[x].length - 1;
			} else if (y < 0) {
				y = 0;
			}

			var posX = this.pages[x][y].x,
			    posY = this.pages[x][y].y;

			time = time === undefined ? this.options.snapSpeed || Math.max(Math.max(Math.min(Math.abs(posX - this.x), 1000), Math.min(Math.abs(posY - this.y), 1000)), 300) : time;

			this.currentPage = {
				x: posX,
				y: posY,
				pageX: x,
				pageY: y
			};

			this.scrollTo(posX, posY, time, easing);
		},

		next: function next(time, easing) {
			var x = this.currentPage.pageX,
			    y = this.currentPage.pageY;

			x++;

			if (x >= this.pages.length && this.hasVerticalScroll) {
				x = 0;
				y++;
			}

			this.goToPage(x, y, time, easing);
		},

		prev: function prev(time, easing) {
			var x = this.currentPage.pageX,
			    y = this.currentPage.pageY;

			x--;

			if (x < 0 && this.hasVerticalScroll) {
				x = 0;
				y--;
			}

			this.goToPage(x, y, time, easing);
		},

		_initKeys: function _initKeys(e) {
			// default key bindings
			var keys = {
				pageUp: 33,
				pageDown: 34,
				end: 35,
				home: 36,
				left: 37,
				up: 38,
				right: 39,
				down: 40
			};
			var i;

			// if you give me characters I give you keycode
			if (_typeof(this.options.keyBindings) == 'object') {
				for (i in this.options.keyBindings) {
					if (typeof this.options.keyBindings[i] == 'string') {
						this.options.keyBindings[i] = this.options.keyBindings[i].toUpperCase().charCodeAt(0);
					}
				}
			} else {
				this.options.keyBindings = {};
			}

			for (i in keys) {
				this.options.keyBindings[i] = this.options.keyBindings[i] || keys[i];
			}

			utils.addEvent(window, 'keydown', this);

			this.on('destroy', function () {
				utils.removeEvent(window, 'keydown', this);
			});
		},

		_key: function _key(e) {
			if (!this.enabled) {
				return;
			}

			var snap = this.options.snap,
			    // we are using this alot, better to cache it
			newX = snap ? this.currentPage.pageX : this.x,
			    newY = snap ? this.currentPage.pageY : this.y,
			    now = utils.getTime(),
			    prevTime = this.keyTime || 0,
			    acceleration = 0.250,
			    pos;

			if (this.options.useTransition && this.isInTransition) {
				pos = this.getComputedPosition();

				this._translate(Math.round(pos.x), Math.round(pos.y));
				this.isInTransition = false;
			}

			this.keyAcceleration = now - prevTime < 200 ? Math.min(this.keyAcceleration + acceleration, 50) : 0;

			switch (e.keyCode) {
				case this.options.keyBindings.pageUp:
					if (this.hasHorizontalScroll && !this.hasVerticalScroll) {
						newX += snap ? 1 : this.wrapperWidth;
					} else {
						newY += snap ? 1 : this.wrapperHeight;
					}
					break;
				case this.options.keyBindings.pageDown:
					if (this.hasHorizontalScroll && !this.hasVerticalScroll) {
						newX -= snap ? 1 : this.wrapperWidth;
					} else {
						newY -= snap ? 1 : this.wrapperHeight;
					}
					break;
				case this.options.keyBindings.end:
					newX = snap ? this.pages.length - 1 : this.maxScrollX;
					newY = snap ? this.pages[0].length - 1 : this.maxScrollY;
					break;
				case this.options.keyBindings.home:
					newX = 0;
					newY = 0;
					break;
				case this.options.keyBindings.left:
					newX += snap ? -1 : 5 + this.keyAcceleration >> 0;
					break;
				case this.options.keyBindings.up:
					newY += snap ? 1 : 5 + this.keyAcceleration >> 0;
					break;
				case this.options.keyBindings.right:
					newX -= snap ? -1 : 5 + this.keyAcceleration >> 0;
					break;
				case this.options.keyBindings.down:
					newY -= snap ? 1 : 5 + this.keyAcceleration >> 0;
					break;
				default:
					return;
			}

			if (snap) {
				this.goToPage(newX, newY);
				return;
			}

			if (newX > 0) {
				newX = 0;
				this.keyAcceleration = 0;
			} else if (newX < this.maxScrollX) {
				newX = this.maxScrollX;
				this.keyAcceleration = 0;
			}

			if (newY > 0) {
				newY = 0;
				this.keyAcceleration = 0;
			} else if (newY < this.maxScrollY) {
				newY = this.maxScrollY;
				this.keyAcceleration = 0;
			}

			this.scrollTo(newX, newY, 0);

			this.keyTime = now;
		},

		_animate: function _animate(destX, destY, duration, easingFn) {
			var that = this,
			    startX = this.x,
			    startY = this.y,
			    startTime = utils.getTime(),
			    destTime = startTime + duration;

			function step() {
				var now = utils.getTime(),
				    newX,
				    newY,
				    easing;

				if (now >= destTime) {
					that.isAnimating = false;
					that._translate(destX, destY);

					if (!that.resetPosition(that.options.bounceTime)) {
						that._execEvent('scrollEnd');
					}

					return;
				}

				now = (now - startTime) / duration;
				easing = easingFn(now);
				newX = (destX - startX) * easing + startX;
				newY = (destY - startY) * easing + startY;
				that._translate(newX, newY);

				if (that.isAnimating) {
					rAF(step);
				}

				if (that.options.probeType == 3) {
					that._execEvent('scroll');
				}
			}

			this.isAnimating = true;
			step();
		},

		handleEvent: function handleEvent(e) {
			switch (e.type) {
				case 'touchstart':
				case 'pointerdown':
				case 'MSPointerDown':
				case 'mousedown':
					this._start(e);
					break;
				case 'touchmove':
				case 'pointermove':
				case 'MSPointerMove':
				case 'mousemove':
					this._move(e);
					break;
				case 'touchend':
				case 'pointerup':
				case 'MSPointerUp':
				case 'mouseup':
				case 'touchcancel':
				case 'pointercancel':
				case 'MSPointerCancel':
				case 'mousecancel':
					this._end(e);
					break;
				case 'orientationchange':
				case 'resize':
					this._resize();
					break;
				case 'transitionend':
				case 'webkitTransitionEnd':
				case 'oTransitionEnd':
				case 'MSTransitionEnd':
					this._transitionEnd(e);
					break;
				case 'wheel':
				case 'DOMMouseScroll':
				case 'mousewheel':
					this._wheel(e);
					break;
				case 'keydown':
					this._key(e);
					break;
				case 'click':
					if (this.enabled && !e._constructed) {
						e.preventDefault();
						e.stopPropagation();
					}
					break;
			}
		}
	};
	function createDefaultScrollbar(direction, interactive, type) {
		var scrollbar = document.createElement('div'),
		    indicator = document.createElement('div');

		if (type === true) {
			scrollbar.style.cssText = 'position:absolute;z-index:9999';
			indicator.style.cssText = '-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;position:absolute;background:rgba(0,0,0,0.5);border:1px solid rgba(255,255,255,0.9);border-radius:3px';
		}

		indicator.className = 'iScrollIndicator';

		if (direction == 'h') {
			if (type === true) {
				scrollbar.style.cssText += ';height:7px;left:2px;right:2px;bottom:0';
				indicator.style.height = '100%';
			}
			scrollbar.className = 'iScrollHorizontalScrollbar';
		} else {
			if (type === true) {
				scrollbar.style.cssText += ';width:7px;bottom:2px;top:2px;right:1px';
				indicator.style.width = '100%';
			}
			scrollbar.className = 'iScrollVerticalScrollbar';
		}

		scrollbar.style.cssText += ';overflow:hidden';

		if (!interactive) {
			scrollbar.style.pointerEvents = 'none';
		}

		scrollbar.appendChild(indicator);

		return scrollbar;
	}

	function Indicator(scroller, options) {
		this.wrapper = typeof options.el == 'string' ? document.querySelector(options.el) : options.el;
		this.wrapperStyle = this.wrapper.style;
		this.indicator = this.wrapper.children[0];
		this.indicatorStyle = this.indicator.style;
		this.scroller = scroller;

		this.options = {
			listenX: true,
			listenY: true,
			interactive: false,
			resize: true,
			defaultScrollbars: false,
			shrink: false,
			fade: false,
			speedRatioX: 0,
			speedRatioY: 0
		};

		for (var i in options) {
			this.options[i] = options[i];
		}

		this.sizeRatioX = 1;
		this.sizeRatioY = 1;
		this.maxPosX = 0;
		this.maxPosY = 0;

		if (this.options.interactive) {
			if (!this.options.disableTouch) {
				utils.addEvent(this.indicator, 'touchstart', this);
				utils.addEvent(window, 'touchend', this);
			}
			if (!this.options.disablePointer) {
				utils.addEvent(this.indicator, utils.prefixPointerEvent('pointerdown'), this);
				utils.addEvent(window, utils.prefixPointerEvent('pointerup'), this);
			}
			if (!this.options.disableMouse) {
				utils.addEvent(this.indicator, 'mousedown', this);
				utils.addEvent(window, 'mouseup', this);
			}
		}

		if (this.options.fade) {
			this.wrapperStyle[utils.style.transform] = this.scroller.translateZ;
			var durationProp = utils.style.transitionDuration;
			this.wrapperStyle[durationProp] = utils.isBadAndroid ? '0.0001ms' : '0ms';
			// remove 0.0001ms
			var self = this;
			if (utils.isBadAndroid) {
				rAF(function () {
					if (self.wrapperStyle[durationProp] === '0.0001ms') {
						self.wrapperStyle[durationProp] = '0s';
					}
				});
			}
			this.wrapperStyle.opacity = '0';
		}
	}

	Indicator.prototype = {
		handleEvent: function handleEvent(e) {
			switch (e.type) {
				case 'touchstart':
				case 'pointerdown':
				case 'MSPointerDown':
				case 'mousedown':
					this._start(e);
					break;
				case 'touchmove':
				case 'pointermove':
				case 'MSPointerMove':
				case 'mousemove':
					this._move(e);
					break;
				case 'touchend':
				case 'pointerup':
				case 'MSPointerUp':
				case 'mouseup':
				case 'touchcancel':
				case 'pointercancel':
				case 'MSPointerCancel':
				case 'mousecancel':
					this._end(e);
					break;
			}
		},

		destroy: function destroy() {
			if (this.options.fadeScrollbars) {
				clearTimeout(this.fadeTimeout);
				this.fadeTimeout = null;
			}
			if (this.options.interactive) {
				utils.removeEvent(this.indicator, 'touchstart', this);
				utils.removeEvent(this.indicator, utils.prefixPointerEvent('pointerdown'), this);
				utils.removeEvent(this.indicator, 'mousedown', this);

				utils.removeEvent(window, 'touchmove', this);
				utils.removeEvent(window, utils.prefixPointerEvent('pointermove'), this);
				utils.removeEvent(window, 'mousemove', this);

				utils.removeEvent(window, 'touchend', this);
				utils.removeEvent(window, utils.prefixPointerEvent('pointerup'), this);
				utils.removeEvent(window, 'mouseup', this);
			}

			if (this.options.defaultScrollbars) {
				this.wrapper.parentNode.removeChild(this.wrapper);
			}
		},

		_start: function _start(e) {
			var point = e.touches ? e.touches[0] : e;

			e.preventDefault();
			e.stopPropagation();

			this.transitionTime();

			this.initiated = true;
			this.moved = false;
			this.lastPointX = point.pageX;
			this.lastPointY = point.pageY;

			this.startTime = utils.getTime();

			if (!this.options.disableTouch) {
				utils.addEvent(window, 'touchmove', this);
			}
			if (!this.options.disablePointer) {
				utils.addEvent(window, utils.prefixPointerEvent('pointermove'), this);
			}
			if (!this.options.disableMouse) {
				utils.addEvent(window, 'mousemove', this);
			}

			this.scroller._execEvent('beforeScrollStart');
		},

		_move: function _move(e) {
			var point = e.touches ? e.touches[0] : e,
			    deltaX,
			    deltaY,
			    newX,
			    newY,
			    timestamp = utils.getTime();

			if (!this.moved) {
				this.scroller._execEvent('scrollStart');
			}

			this.moved = true;

			deltaX = point.pageX - this.lastPointX;
			this.lastPointX = point.pageX;

			deltaY = point.pageY - this.lastPointY;
			this.lastPointY = point.pageY;

			newX = this.x + deltaX;
			newY = this.y + deltaY;

			this._pos(newX, newY);

			if (this.scroller.options.probeType == 1 && timestamp - this.startTime > 300) {
				this.startTime = timestamp;
				this.scroller._execEvent('scroll');
			} else if (this.scroller.options.probeType > 1) {
				this.scroller._execEvent('scroll');
			}

			// INSERT POINT: indicator._move

			e.preventDefault();
			e.stopPropagation();
		},

		_end: function _end(e) {
			if (!this.initiated) {
				return;
			}

			this.initiated = false;

			e.preventDefault();
			e.stopPropagation();

			utils.removeEvent(window, 'touchmove', this);
			utils.removeEvent(window, utils.prefixPointerEvent('pointermove'), this);
			utils.removeEvent(window, 'mousemove', this);

			if (this.scroller.options.snap) {
				var snap = this.scroller._nearestSnap(this.scroller.x, this.scroller.y);

				var time = this.options.snapSpeed || Math.max(Math.max(Math.min(Math.abs(this.scroller.x - snap.x), 1000), Math.min(Math.abs(this.scroller.y - snap.y), 1000)), 300);

				if (this.scroller.x != snap.x || this.scroller.y != snap.y) {
					this.scroller.directionX = 0;
					this.scroller.directionY = 0;
					this.scroller.currentPage = snap;
					this.scroller.scrollTo(snap.x, snap.y, time, this.scroller.options.bounceEasing);
				}
			}

			if (this.moved) {
				this.scroller._execEvent('scrollEnd');
			}
		},

		transitionTime: function transitionTime(time) {
			time = time || 0;
			var durationProp = utils.style.transitionDuration;
			this.indicatorStyle[durationProp] = time + 'ms';

			if (!time && utils.isBadAndroid) {
				this.indicatorStyle[durationProp] = '0.0001ms';
				// remove 0.0001ms
				var self = this;
				rAF(function () {
					if (self.indicatorStyle[durationProp] === '0.0001ms') {
						self.indicatorStyle[durationProp] = '0s';
					}
				});
			}
		},

		transitionTimingFunction: function transitionTimingFunction(easing) {
			this.indicatorStyle[utils.style.transitionTimingFunction] = easing;
		},

		refresh: function refresh() {
			this.transitionTime();

			if (this.options.listenX && !this.options.listenY) {
				this.indicatorStyle.display = this.scroller.hasHorizontalScroll ? 'block' : 'none';
			} else if (this.options.listenY && !this.options.listenX) {
				this.indicatorStyle.display = this.scroller.hasVerticalScroll ? 'block' : 'none';
			} else {
				this.indicatorStyle.display = this.scroller.hasHorizontalScroll || this.scroller.hasVerticalScroll ? 'block' : 'none';
			}

			if (this.scroller.hasHorizontalScroll && this.scroller.hasVerticalScroll) {
				utils.addClass(this.wrapper, 'iScrollBothScrollbars');
				utils.removeClass(this.wrapper, 'iScrollLoneScrollbar');

				if (this.options.defaultScrollbars && this.options.customStyle) {
					if (this.options.listenX) {
						this.wrapper.style.right = '8px';
					} else {
						this.wrapper.style.bottom = '8px';
					}
				}
			} else {
				utils.removeClass(this.wrapper, 'iScrollBothScrollbars');
				utils.addClass(this.wrapper, 'iScrollLoneScrollbar');

				if (this.options.defaultScrollbars && this.options.customStyle) {
					if (this.options.listenX) {
						this.wrapper.style.right = '2px';
					} else {
						this.wrapper.style.bottom = '2px';
					}
				}
			}

			var r = this.wrapper.offsetHeight; // force refresh

			if (this.options.listenX) {
				this.wrapperWidth = this.wrapper.clientWidth;
				if (this.options.resize) {
					this.indicatorWidth = Math.max(Math.round(this.wrapperWidth * this.wrapperWidth / (this.scroller.scrollerWidth || this.wrapperWidth || 1)), 8);
					this.indicatorStyle.width = this.indicatorWidth + 'px';
				} else {
					this.indicatorWidth = this.indicator.clientWidth;
				}

				this.maxPosX = this.wrapperWidth - this.indicatorWidth;

				if (this.options.shrink == 'clip') {
					this.minBoundaryX = -this.indicatorWidth + 8;
					this.maxBoundaryX = this.wrapperWidth - 8;
				} else {
					this.minBoundaryX = 0;
					this.maxBoundaryX = this.maxPosX;
				}

				this.sizeRatioX = this.options.speedRatioX || this.scroller.maxScrollX && this.maxPosX / this.scroller.maxScrollX;
			}

			if (this.options.listenY) {
				this.wrapperHeight = this.wrapper.clientHeight;
				if (this.options.resize) {
					this.indicatorHeight = Math.max(Math.round(this.wrapperHeight * this.wrapperHeight / (this.scroller.scrollerHeight || this.wrapperHeight || 1)), 8);
					this.indicatorStyle.height = this.indicatorHeight + 'px';
				} else {
					this.indicatorHeight = this.indicator.clientHeight;
				}

				this.maxPosY = this.wrapperHeight - this.indicatorHeight;

				if (this.options.shrink == 'clip') {
					this.minBoundaryY = -this.indicatorHeight + 8;
					this.maxBoundaryY = this.wrapperHeight - 8;
				} else {
					this.minBoundaryY = 0;
					this.maxBoundaryY = this.maxPosY;
				}

				this.maxPosY = this.wrapperHeight - this.indicatorHeight;
				this.sizeRatioY = this.options.speedRatioY || this.scroller.maxScrollY && this.maxPosY / this.scroller.maxScrollY;
			}

			this.updatePosition();
		},

		updatePosition: function updatePosition() {
			var x = this.options.listenX && Math.round(this.sizeRatioX * this.scroller.x) || 0,
			    y = this.options.listenY && Math.round(this.sizeRatioY * this.scroller.y) || 0;

			if (!this.options.ignoreBoundaries) {
				if (x < this.minBoundaryX) {
					if (this.options.shrink == 'scale') {
						this.width = Math.max(this.indicatorWidth + x, 8);
						this.indicatorStyle.width = this.width + 'px';
					}
					x = this.minBoundaryX;
				} else if (x > this.maxBoundaryX) {
					if (this.options.shrink == 'scale') {
						this.width = Math.max(this.indicatorWidth - (x - this.maxPosX), 8);
						this.indicatorStyle.width = this.width + 'px';
						x = this.maxPosX + this.indicatorWidth - this.width;
					} else {
						x = this.maxBoundaryX;
					}
				} else if (this.options.shrink == 'scale' && this.width != this.indicatorWidth) {
					this.width = this.indicatorWidth;
					this.indicatorStyle.width = this.width + 'px';
				}

				if (y < this.minBoundaryY) {
					if (this.options.shrink == 'scale') {
						this.height = Math.max(this.indicatorHeight + y * 3, 8);
						this.indicatorStyle.height = this.height + 'px';
					}
					y = this.minBoundaryY;
				} else if (y > this.maxBoundaryY) {
					if (this.options.shrink == 'scale') {
						this.height = Math.max(this.indicatorHeight - (y - this.maxPosY) * 3, 8);
						this.indicatorStyle.height = this.height + 'px';
						y = this.maxPosY + this.indicatorHeight - this.height;
					} else {
						y = this.maxBoundaryY;
					}
				} else if (this.options.shrink == 'scale' && this.height != this.indicatorHeight) {
					this.height = this.indicatorHeight;
					this.indicatorStyle.height = this.height + 'px';
				}
			}

			this.x = x;
			this.y = y;

			if (this.scroller.options.useTransform) {
				this.indicatorStyle[utils.style.transform] = 'translate(' + x + 'px,' + y + 'px)' + this.scroller.translateZ;
			} else {
				this.indicatorStyle.left = x + 'px';
				this.indicatorStyle.top = y + 'px';
			}
		},

		_pos: function _pos(x, y) {
			if (x < 0) {
				x = 0;
			} else if (x > this.maxPosX) {
				x = this.maxPosX;
			}

			if (y < 0) {
				y = 0;
			} else if (y > this.maxPosY) {
				y = this.maxPosY;
			}

			x = this.options.listenX ? Math.round(x / this.sizeRatioX) : this.scroller.x;
			y = this.options.listenY ? Math.round(y / this.sizeRatioY) : this.scroller.y;

			this.scroller.scrollTo(x, y);
		},

		fade: function fade(val, hold) {
			if (hold && !this.visible) {
				return;
			}

			clearTimeout(this.fadeTimeout);
			this.fadeTimeout = null;

			var time = val ? 250 : 500,
			    delay = val ? 0 : 300;

			val = val ? '1' : '0';

			this.wrapperStyle[utils.style.transitionDuration] = time + 'ms';

			this.fadeTimeout = setTimeout(function (val) {
				this.wrapperStyle.opacity = val;
				this.visible = +val;
			}.bind(this, val), delay);
		}
	};

	IScroll.utils = utils;

	if (typeof module != 'undefined' && module.exports) {
		module.exports = IScroll;
	} else if (typeof define == 'function' && define.amd) {
		define(function () {
			return IScroll;
		});
	} else {
		window.IScroll = IScroll;
	}
})(window, document, Math);

},{}],55:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*! iScroll v5.2.0 ~ (c) 2008-2016 Matteo Spinelli ~ http://cubiq.org/license */
(function (window, document, Math) {
	var rAF = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) {
		window.setTimeout(callback, 1000 / 60);
	};

	var utils = function () {
		var me = {};

		var _elementStyle = document.createElement('div').style;
		var _vendor = function () {
			var vendors = ['t', 'webkitT', 'MozT', 'msT', 'OT'],
			    transform,
			    i = 0,
			    l = vendors.length;

			for (; i < l; i++) {
				transform = vendors[i] + 'ransform';
				if (transform in _elementStyle) return vendors[i].substr(0, vendors[i].length - 1);
			}

			return false;
		}();

		function _prefixStyle(style) {
			if (_vendor === false) return false;
			if (_vendor === '') return style;
			return _vendor + style.charAt(0).toUpperCase() + style.substr(1);
		}

		me.getTime = Date.now || function getTime() {
			return new Date().getTime();
		};

		me.extend = function (target, obj) {
			for (var i in obj) {
				target[i] = obj[i];
			}
		};

		me.addEvent = function (el, type, fn, capture) {
			el.addEventListener(type, fn, !!capture);
		};

		me.removeEvent = function (el, type, fn, capture) {
			el.removeEventListener(type, fn, !!capture);
		};

		me.prefixPointerEvent = function (pointerEvent) {
			return window.MSPointerEvent ? 'MSPointer' + pointerEvent.charAt(7).toUpperCase() + pointerEvent.substr(8) : pointerEvent;
		};

		me.momentum = function (current, start, time, lowerMargin, wrapperSize, deceleration) {
			var distance = current - start,
			    speed = Math.abs(distance) / time,
			    destination,
			    duration;

			deceleration = deceleration === undefined ? 0.0006 : deceleration;

			destination = current + speed * speed / (2 * deceleration) * (distance < 0 ? -1 : 1);
			duration = speed / deceleration;

			if (destination < lowerMargin) {
				destination = wrapperSize ? lowerMargin - wrapperSize / 2.5 * (speed / 8) : lowerMargin;
				distance = Math.abs(destination - current);
				duration = distance / speed;
			} else if (destination > 0) {
				destination = wrapperSize ? wrapperSize / 2.5 * (speed / 8) : 0;
				distance = Math.abs(current) + destination;
				duration = distance / speed;
			}

			return {
				destination: Math.round(destination),
				duration: duration
			};
		};

		var _transform = _prefixStyle('transform');

		me.extend(me, {
			hasTransform: _transform !== false,
			hasPerspective: _prefixStyle('perspective') in _elementStyle,
			hasTouch: 'ontouchstart' in window,
			hasPointer: !!(window.PointerEvent || window.MSPointerEvent), // IE10 is prefixed
			hasTransition: _prefixStyle('transition') in _elementStyle
		});

		/*
  This should find all Android browsers lower than build 535.19 (both stock browser and webview)
  - galaxy S2 is ok
     - 2.3.6 : `AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1`
     - 4.0.4 : `AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30`
    - galaxy S3 is badAndroid (stock brower, webview)
      `AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30`
    - galaxy S4 is badAndroid (stock brower, webview)
      `AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30`
    - galaxy S5 is OK
      `AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Mobile Safari/537.36 (Chrome/)`
    - galaxy S6 is OK
      `AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Mobile Safari/537.36 (Chrome/)`
   */
		me.isBadAndroid = function () {
			var appVersion = window.navigator.appVersion;
			// Android browser is not a chrome browser.
			if (/Android/.test(appVersion) && !/Chrome\/\d/.test(appVersion)) {
				var safariVersion = appVersion.match(/Safari\/(\d+.\d)/);
				if (safariVersion && (typeof safariVersion === 'undefined' ? 'undefined' : _typeof(safariVersion)) === "object" && safariVersion.length >= 2) {
					return parseFloat(safariVersion[1]) < 535.19;
				} else {
					return true;
				}
			} else {
				return false;
			}
		}();

		me.extend(me.style = {}, {
			transform: _transform,
			transitionTimingFunction: _prefixStyle('transitionTimingFunction'),
			transitionDuration: _prefixStyle('transitionDuration'),
			transitionDelay: _prefixStyle('transitionDelay'),
			transformOrigin: _prefixStyle('transformOrigin')
		});

		me.hasClass = function (e, c) {
			var re = new RegExp("(^|\\s)" + c + "(\\s|$)");
			return re.test(e.className);
		};

		me.addClass = function (e, c) {
			if (me.hasClass(e, c)) {
				return;
			}

			var newclass = e.className.split(' ');
			newclass.push(c);
			e.className = newclass.join(' ');
		};

		me.removeClass = function (e, c) {
			if (!me.hasClass(e, c)) {
				return;
			}

			var re = new RegExp("(^|\\s)" + c + "(\\s|$)", 'g');
			e.className = e.className.replace(re, ' ');
		};

		me.offset = function (el) {
			var left = -el.offsetLeft,
			    top = -el.offsetTop;

			// jshint -W084
			while (el = el.offsetParent) {
				left -= el.offsetLeft;
				top -= el.offsetTop;
			}
			// jshint +W084

			return {
				left: left,
				top: top
			};
		};

		me.preventDefaultException = function (el, exceptions) {
			for (var i in exceptions) {
				if (exceptions[i].test(el[i])) {
					return true;
				}
			}

			return false;
		};

		me.extend(me.eventType = {}, {
			touchstart: 1,
			touchmove: 1,
			touchend: 1,

			mousedown: 2,
			mousemove: 2,
			mouseup: 2,

			pointerdown: 3,
			pointermove: 3,
			pointerup: 3,

			MSPointerDown: 3,
			MSPointerMove: 3,
			MSPointerUp: 3
		});

		me.extend(me.ease = {}, {
			quadratic: {
				style: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)',
				fn: function fn(k) {
					return k * (2 - k);
				}
			},
			circular: {
				style: 'cubic-bezier(0.1, 0.57, 0.1, 1)', // Not properly "circular" but this looks better, it should be (0.075, 0.82, 0.165, 1)
				fn: function fn(k) {
					return Math.sqrt(1 - --k * k);
				}
			},
			back: {
				style: 'cubic-bezier(0.175, 0.885, 0.32, 1.275)',
				fn: function fn(k) {
					var b = 4;
					return (k = k - 1) * k * ((b + 1) * k + b) + 1;
				}
			},
			bounce: {
				style: '',
				fn: function fn(k) {
					if ((k /= 1) < 1 / 2.75) {
						return 7.5625 * k * k;
					} else if (k < 2 / 2.75) {
						return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;
					} else if (k < 2.5 / 2.75) {
						return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;
					} else {
						return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;
					}
				}
			},
			elastic: {
				style: '',
				fn: function fn(k) {
					var f = 0.22,
					    e = 0.4;

					if (k === 0) {
						return 0;
					}
					if (k == 1) {
						return 1;
					}

					return e * Math.pow(2, -10 * k) * Math.sin((k - f / 4) * (2 * Math.PI) / f) + 1;
				}
			}
		});

		me.tap = function (e, eventName) {
			var ev = document.createEvent('Event');
			ev.initEvent(eventName, true, true);
			ev.pageX = e.pageX;
			ev.pageY = e.pageY;
			e.target.dispatchEvent(ev);
		};

		me.click = function (e) {
			var target = e.target,
			    ev;

			if (!/(SELECT|INPUT|TEXTAREA)/i.test(target.tagName)) {
				ev = document.createEvent('MouseEvents');
				ev.initMouseEvent('click', true, true, e.view, 1, target.screenX, target.screenY, target.clientX, target.clientY, e.ctrlKey, e.altKey, e.shiftKey, e.metaKey, 0, null);

				ev._constructed = true;
				target.dispatchEvent(ev);
			}
		};

		return me;
	}();
	function IScroll(el, options) {
		this.wrapper = typeof el == 'string' ? document.querySelector(el) : el;
		this.scroller = this.wrapper.children[0];
		this.scrollerStyle = this.scroller.style; // cache style for better performance

		this.options = {

			resizeScrollbars: true,

			mouseWheelSpeed: 20,

			snapThreshold: 0.334,

			// INSERT POINT: OPTIONS
			disablePointer: !utils.hasPointer,
			disableTouch: utils.hasPointer || !utils.hasTouch,
			disableMouse: utils.hasPointer || utils.hasTouch,
			startX: 0,
			startY: 0,
			scrollY: true,
			directionLockThreshold: 5,
			momentum: true,

			bounce: true,
			bounceTime: 600,
			bounceEasing: '',

			preventDefault: true,
			preventDefaultException: { tagName: /^(INPUT|TEXTAREA|BUTTON|SELECT)$/ },

			HWCompositing: true,
			useTransition: true,
			useTransform: true,
			bindToWrapper: typeof window.onmousedown === "undefined"
		};

		for (var i in options) {
			this.options[i] = options[i];
		}

		// Normalize options
		this.translateZ = this.options.HWCompositing && utils.hasPerspective ? ' translateZ(0)' : '';

		this.options.useTransition = utils.hasTransition && this.options.useTransition;
		this.options.useTransform = utils.hasTransform && this.options.useTransform;

		this.options.eventPassthrough = this.options.eventPassthrough === true ? 'vertical' : this.options.eventPassthrough;
		this.options.preventDefault = !this.options.eventPassthrough && this.options.preventDefault;

		// If you want eventPassthrough I have to lock one of the axes
		this.options.scrollY = this.options.eventPassthrough == 'vertical' ? false : this.options.scrollY;
		this.options.scrollX = this.options.eventPassthrough == 'horizontal' ? false : this.options.scrollX;

		// With eventPassthrough we also need lockDirection mechanism
		this.options.freeScroll = this.options.freeScroll && !this.options.eventPassthrough;
		this.options.directionLockThreshold = this.options.eventPassthrough ? 0 : this.options.directionLockThreshold;

		this.options.bounceEasing = typeof this.options.bounceEasing == 'string' ? utils.ease[this.options.bounceEasing] || utils.ease.circular : this.options.bounceEasing;

		this.options.resizePolling = this.options.resizePolling === undefined ? 60 : this.options.resizePolling;

		if (this.options.tap === true) {
			this.options.tap = 'tap';
		}

		if (this.options.shrinkScrollbars == 'scale') {
			this.options.useTransition = false;
		}

		this.options.invertWheelDirection = this.options.invertWheelDirection ? -1 : 1;

		// INSERT POINT: NORMALIZATION

		// Some defaults
		this.x = 0;
		this.y = 0;
		this.directionX = 0;
		this.directionY = 0;
		this._events = {};

		// INSERT POINT: DEFAULTS

		this._init();
		this.refresh();

		this.scrollTo(this.options.startX, this.options.startY);
		this.enable();
	}

	IScroll.prototype = {
		version: '5.2.0',

		_init: function _init() {
			this._initEvents();

			if (this.options.scrollbars || this.options.indicators) {
				this._initIndicators();
			}

			if (this.options.mouseWheel) {
				this._initWheel();
			}

			if (this.options.snap) {
				this._initSnap();
			}

			if (this.options.keyBindings) {
				this._initKeys();
			}

			// INSERT POINT: _init
		},

		destroy: function destroy() {
			this._initEvents(true);
			clearTimeout(this.resizeTimeout);
			this.resizeTimeout = null;
			this._execEvent('destroy');
		},

		_transitionEnd: function _transitionEnd(e) {
			if (e.target != this.scroller || !this.isInTransition) {
				return;
			}

			this._transitionTime();
			if (!this.resetPosition(this.options.bounceTime)) {
				this.isInTransition = false;
				this._execEvent('scrollEnd');
			}
		},

		_start: function _start(e) {
			// React to left mouse button only
			if (utils.eventType[e.type] != 1) {
				// for button property
				// http://unixpapa.com/js/mouse.html
				var button;
				if (!e.which) {
					/* IE case */
					button = e.button < 2 ? 0 : e.button == 4 ? 1 : 2;
				} else {
					/* All others */
					button = e.button;
				}
				if (button !== 0) {
					return;
				}
			}

			if (!this.enabled || this.initiated && utils.eventType[e.type] !== this.initiated) {
				return;
			}

			if (this.options.preventDefault && !utils.isBadAndroid && !utils.preventDefaultException(e.target, this.options.preventDefaultException)) {
				e.preventDefault();
			}

			var point = e.touches ? e.touches[0] : e,
			    pos;

			this.initiated = utils.eventType[e.type];
			this.moved = false;
			this.distX = 0;
			this.distY = 0;
			this.directionX = 0;
			this.directionY = 0;
			this.directionLocked = 0;

			this.startTime = utils.getTime();

			if (this.options.useTransition && this.isInTransition) {
				this._transitionTime();
				this.isInTransition = false;
				pos = this.getComputedPosition();
				this._translate(Math.round(pos.x), Math.round(pos.y));
				this._execEvent('scrollEnd');
			} else if (!this.options.useTransition && this.isAnimating) {
				this.isAnimating = false;
				this._execEvent('scrollEnd');
			}

			this.startX = this.x;
			this.startY = this.y;
			this.absStartX = this.x;
			this.absStartY = this.y;
			this.pointX = point.pageX;
			this.pointY = point.pageY;

			this._execEvent('beforeScrollStart');
		},

		_move: function _move(e) {
			if (!this.enabled || utils.eventType[e.type] !== this.initiated) {
				return;
			}

			if (this.options.preventDefault) {
				// increases performance on Android? TODO: check!
				e.preventDefault();
			}

			var point = e.touches ? e.touches[0] : e,
			    deltaX = point.pageX - this.pointX,
			    deltaY = point.pageY - this.pointY,
			    timestamp = utils.getTime(),
			    newX,
			    newY,
			    absDistX,
			    absDistY;

			this.pointX = point.pageX;
			this.pointY = point.pageY;

			this.distX += deltaX;
			this.distY += deltaY;
			absDistX = Math.abs(this.distX);
			absDistY = Math.abs(this.distY);

			// We need to move at least 10 pixels for the scrolling to initiate
			if (timestamp - this.endTime > 300 && absDistX < 10 && absDistY < 10) {
				return;
			}

			// If you are scrolling in one direction lock the other
			if (!this.directionLocked && !this.options.freeScroll) {
				if (absDistX > absDistY + this.options.directionLockThreshold) {
					this.directionLocked = 'h'; // lock horizontally
				} else if (absDistY >= absDistX + this.options.directionLockThreshold) {
					this.directionLocked = 'v'; // lock vertically
				} else {
					this.directionLocked = 'n'; // no lock
				}
			}

			if (this.directionLocked == 'h') {
				if (this.options.eventPassthrough == 'vertical') {
					e.preventDefault();
				} else if (this.options.eventPassthrough == 'horizontal') {
					this.initiated = false;
					return;
				}

				deltaY = 0;
			} else if (this.directionLocked == 'v') {
				if (this.options.eventPassthrough == 'horizontal') {
					e.preventDefault();
				} else if (this.options.eventPassthrough == 'vertical') {
					this.initiated = false;
					return;
				}

				deltaX = 0;
			}

			deltaX = this.hasHorizontalScroll ? deltaX : 0;
			deltaY = this.hasVerticalScroll ? deltaY : 0;

			newX = this.x + deltaX;
			newY = this.y + deltaY;

			// Slow down if outside of the boundaries
			if (newX > 0 || newX < this.maxScrollX) {
				newX = this.options.bounce ? this.x + deltaX / 3 : newX > 0 ? 0 : this.maxScrollX;
			}
			if (newY > 0 || newY < this.maxScrollY) {
				newY = this.options.bounce ? this.y + deltaY / 3 : newY > 0 ? 0 : this.maxScrollY;
			}

			this.directionX = deltaX > 0 ? -1 : deltaX < 0 ? 1 : 0;
			this.directionY = deltaY > 0 ? -1 : deltaY < 0 ? 1 : 0;

			if (!this.moved) {
				this._execEvent('scrollStart');
			}

			this.moved = true;

			this._translate(newX, newY);

			/* REPLACE START: _move */

			if (timestamp - this.startTime > 300) {
				this.startTime = timestamp;
				this.startX = this.x;
				this.startY = this.y;
			}

			/* REPLACE END: _move */
		},

		_end: function _end(e) {
			if (!this.enabled || utils.eventType[e.type] !== this.initiated) {
				return;
			}

			if (this.options.preventDefault && !utils.preventDefaultException(e.target, this.options.preventDefaultException)) {
				e.preventDefault();
			}

			var point = e.changedTouches ? e.changedTouches[0] : e,
			    momentumX,
			    momentumY,
			    duration = utils.getTime() - this.startTime,
			    newX = Math.round(this.x),
			    newY = Math.round(this.y),
			    distanceX = Math.abs(newX - this.startX),
			    distanceY = Math.abs(newY - this.startY),
			    time = 0,
			    easing = '';

			this.isInTransition = 0;
			this.initiated = 0;
			this.endTime = utils.getTime();

			// reset if we are outside of the boundaries
			if (this.resetPosition(this.options.bounceTime)) {
				return;
			}

			this.scrollTo(newX, newY); // ensures that the last position is rounded

			// we scrolled less than 10 pixels
			if (!this.moved) {
				if (this.options.tap) {
					utils.tap(e, this.options.tap);
				}

				if (this.options.click) {
					utils.click(e);
				}

				this._execEvent('scrollCancel');
				return;
			}

			if (this._events.flick && duration < 200 && distanceX < 100 && distanceY < 100) {
				this._execEvent('flick');
				return;
			}

			// start momentum animation if needed
			if (this.options.momentum && duration < 300) {
				momentumX = this.hasHorizontalScroll ? utils.momentum(this.x, this.startX, duration, this.maxScrollX, this.options.bounce ? this.wrapperWidth : 0, this.options.deceleration) : { destination: newX, duration: 0 };
				momentumY = this.hasVerticalScroll ? utils.momentum(this.y, this.startY, duration, this.maxScrollY, this.options.bounce ? this.wrapperHeight : 0, this.options.deceleration) : { destination: newY, duration: 0 };
				newX = momentumX.destination;
				newY = momentumY.destination;
				time = Math.max(momentumX.duration, momentumY.duration);
				this.isInTransition = 1;
			}

			if (this.options.snap) {
				var snap = this._nearestSnap(newX, newY);
				this.currentPage = snap;
				time = this.options.snapSpeed || Math.max(Math.max(Math.min(Math.abs(newX - snap.x), 1000), Math.min(Math.abs(newY - snap.y), 1000)), 300);
				newX = snap.x;
				newY = snap.y;

				this.directionX = 0;
				this.directionY = 0;
				easing = this.options.bounceEasing;
			}

			// INSERT POINT: _end

			if (newX != this.x || newY != this.y) {
				// change easing function when scroller goes out of the boundaries
				if (newX > 0 || newX < this.maxScrollX || newY > 0 || newY < this.maxScrollY) {
					easing = utils.ease.quadratic;
				}

				this.scrollTo(newX, newY, time, easing);
				return;
			}

			this._execEvent('scrollEnd');
		},

		_resize: function _resize() {
			var that = this;

			clearTimeout(this.resizeTimeout);

			this.resizeTimeout = setTimeout(function () {
				that.refresh();
			}, this.options.resizePolling);
		},

		resetPosition: function resetPosition(time) {
			var x = this.x,
			    y = this.y;

			time = time || 0;

			if (!this.hasHorizontalScroll || this.x > 0) {
				x = 0;
			} else if (this.x < this.maxScrollX) {
				x = this.maxScrollX;
			}

			if (!this.hasVerticalScroll || this.y > 0) {
				y = 0;
			} else if (this.y < this.maxScrollY) {
				y = this.maxScrollY;
			}

			if (x == this.x && y == this.y) {
				return false;
			}

			this.scrollTo(x, y, time, this.options.bounceEasing);

			return true;
		},

		disable: function disable() {
			this.enabled = false;
		},

		enable: function enable() {
			this.enabled = true;
		},

		refresh: function refresh() {
			var rf = this.wrapper.offsetHeight; // Force reflow

			this.wrapperWidth = this.wrapper.clientWidth;
			this.wrapperHeight = this.wrapper.clientHeight;

			/* REPLACE START: refresh */

			this.scrollerWidth = this.scroller.offsetWidth;
			this.scrollerHeight = this.scroller.offsetHeight;

			this.maxScrollX = this.wrapperWidth - this.scrollerWidth;
			this.maxScrollY = this.wrapperHeight - this.scrollerHeight;

			/* REPLACE END: refresh */

			this.hasHorizontalScroll = this.options.scrollX && this.maxScrollX < 0;
			this.hasVerticalScroll = this.options.scrollY && this.maxScrollY < 0;

			if (!this.hasHorizontalScroll) {
				this.maxScrollX = 0;
				this.scrollerWidth = this.wrapperWidth;
			}

			if (!this.hasVerticalScroll) {
				this.maxScrollY = 0;
				this.scrollerHeight = this.wrapperHeight;
			}

			this.endTime = 0;
			this.directionX = 0;
			this.directionY = 0;

			this.wrapperOffset = utils.offset(this.wrapper);

			this._execEvent('refresh');

			this.resetPosition();

			// INSERT POINT: _refresh
		},

		on: function on(type, fn) {
			if (!this._events[type]) {
				this._events[type] = [];
			}

			this._events[type].push(fn);
		},

		off: function off(type, fn) {
			if (!this._events[type]) {
				return;
			}

			var index = this._events[type].indexOf(fn);

			if (index > -1) {
				this._events[type].splice(index, 1);
			}
		},

		_execEvent: function _execEvent(type) {
			if (!this._events[type]) {
				return;
			}

			var i = 0,
			    l = this._events[type].length;

			if (!l) {
				return;
			}

			for (; i < l; i++) {
				this._events[type][i].apply(this, [].slice.call(arguments, 1));
			}
		},

		scrollBy: function scrollBy(x, y, time, easing) {
			x = this.x + x;
			y = this.y + y;
			time = time || 0;

			this.scrollTo(x, y, time, easing);
		},

		scrollTo: function scrollTo(x, y, time, easing) {
			easing = easing || utils.ease.circular;

			this.isInTransition = this.options.useTransition && time > 0;
			var transitionType = this.options.useTransition && easing.style;
			if (!time || transitionType) {
				if (transitionType) {
					this._transitionTimingFunction(easing.style);
					this._transitionTime(time);
				}
				this._translate(x, y);
			} else {
				this._animate(x, y, time, easing.fn);
			}
		},

		scrollToElement: function scrollToElement(el, time, offsetX, offsetY, easing) {
			el = el.nodeType ? el : this.scroller.querySelector(el);

			if (!el) {
				return;
			}

			var pos = utils.offset(el);

			pos.left -= this.wrapperOffset.left;
			pos.top -= this.wrapperOffset.top;

			// if offsetX/Y are true we center the element to the screen
			if (offsetX === true) {
				offsetX = Math.round(el.offsetWidth / 2 - this.wrapper.offsetWidth / 2);
			}
			if (offsetY === true) {
				offsetY = Math.round(el.offsetHeight / 2 - this.wrapper.offsetHeight / 2);
			}

			pos.left -= offsetX || 0;
			pos.top -= offsetY || 0;

			pos.left = pos.left > 0 ? 0 : pos.left < this.maxScrollX ? this.maxScrollX : pos.left;
			pos.top = pos.top > 0 ? 0 : pos.top < this.maxScrollY ? this.maxScrollY : pos.top;

			time = time === undefined || time === null || time === 'auto' ? Math.max(Math.abs(this.x - pos.left), Math.abs(this.y - pos.top)) : time;

			this.scrollTo(pos.left, pos.top, time, easing);
		},

		_transitionTime: function _transitionTime(time) {
			time = time || 0;

			var durationProp = utils.style.transitionDuration;
			this.scrollerStyle[durationProp] = time + 'ms';

			if (!time && utils.isBadAndroid) {
				this.scrollerStyle[durationProp] = '0.0001ms';
				// remove 0.0001ms
				var self = this;
				rAF(function () {
					if (self.scrollerStyle[durationProp] === '0.0001ms') {
						self.scrollerStyle[durationProp] = '0s';
					}
				});
			}

			if (this.indicators) {
				for (var i = this.indicators.length; i--;) {
					this.indicators[i].transitionTime(time);
				}
			}

			// INSERT POINT: _transitionTime
		},

		_transitionTimingFunction: function _transitionTimingFunction(easing) {
			this.scrollerStyle[utils.style.transitionTimingFunction] = easing;

			if (this.indicators) {
				for (var i = this.indicators.length; i--;) {
					this.indicators[i].transitionTimingFunction(easing);
				}
			}

			// INSERT POINT: _transitionTimingFunction
		},

		_translate: function _translate(x, y) {
			if (this.options.useTransform) {

				/* REPLACE START: _translate */

				this.scrollerStyle[utils.style.transform] = 'translate(' + x + 'px,' + y + 'px)' + this.translateZ;

				/* REPLACE END: _translate */
			} else {
				x = Math.round(x);
				y = Math.round(y);
				this.scrollerStyle.left = x + 'px';
				this.scrollerStyle.top = y + 'px';
			}

			this.x = x;
			this.y = y;

			if (this.indicators) {
				for (var i = this.indicators.length; i--;) {
					this.indicators[i].updatePosition();
				}
			}

			// INSERT POINT: _translate
		},

		_initEvents: function _initEvents(remove) {
			var eventType = remove ? utils.removeEvent : utils.addEvent,
			    target = this.options.bindToWrapper ? this.wrapper : window;

			eventType(window, 'orientationchange', this);
			eventType(window, 'resize', this);

			if (this.options.click) {
				eventType(this.wrapper, 'click', this, true);
			}

			if (!this.options.disableMouse) {
				eventType(this.wrapper, 'mousedown', this);
				eventType(target, 'mousemove', this);
				eventType(target, 'mousecancel', this);
				eventType(target, 'mouseup', this);
			}

			if (utils.hasPointer && !this.options.disablePointer) {
				eventType(this.wrapper, utils.prefixPointerEvent('pointerdown'), this);
				eventType(target, utils.prefixPointerEvent('pointermove'), this);
				eventType(target, utils.prefixPointerEvent('pointercancel'), this);
				eventType(target, utils.prefixPointerEvent('pointerup'), this);
			}

			if (utils.hasTouch && !this.options.disableTouch) {
				eventType(this.wrapper, 'touchstart', this);
				eventType(target, 'touchmove', this);
				eventType(target, 'touchcancel', this);
				eventType(target, 'touchend', this);
			}

			eventType(this.scroller, 'transitionend', this);
			eventType(this.scroller, 'webkitTransitionEnd', this);
			eventType(this.scroller, 'oTransitionEnd', this);
			eventType(this.scroller, 'MSTransitionEnd', this);
		},

		getComputedPosition: function getComputedPosition() {
			var matrix = window.getComputedStyle(this.scroller, null),
			    x,
			    y;

			if (this.options.useTransform) {
				matrix = matrix[utils.style.transform].split(')')[0].split(', ');
				x = +(matrix[12] || matrix[4]);
				y = +(matrix[13] || matrix[5]);
			} else {
				x = +matrix.left.replace(/[^-\d.]/g, '');
				y = +matrix.top.replace(/[^-\d.]/g, '');
			}

			return { x: x, y: y };
		},
		_initIndicators: function _initIndicators() {
			var interactive = this.options.interactiveScrollbars,
			    customStyle = typeof this.options.scrollbars != 'string',
			    indicators = [],
			    indicator;

			var that = this;

			this.indicators = [];

			if (this.options.scrollbars) {
				// Vertical scrollbar
				if (this.options.scrollY) {
					indicator = {
						el: createDefaultScrollbar('v', interactive, this.options.scrollbars),
						interactive: interactive,
						defaultScrollbars: true,
						customStyle: customStyle,
						resize: this.options.resizeScrollbars,
						shrink: this.options.shrinkScrollbars,
						fade: this.options.fadeScrollbars,
						listenX: false
					};

					this.wrapper.appendChild(indicator.el);
					indicators.push(indicator);
				}

				// Horizontal scrollbar
				if (this.options.scrollX) {
					indicator = {
						el: createDefaultScrollbar('h', interactive, this.options.scrollbars),
						interactive: interactive,
						defaultScrollbars: true,
						customStyle: customStyle,
						resize: this.options.resizeScrollbars,
						shrink: this.options.shrinkScrollbars,
						fade: this.options.fadeScrollbars,
						listenY: false
					};

					this.wrapper.appendChild(indicator.el);
					indicators.push(indicator);
				}
			}

			if (this.options.indicators) {
				// TODO: check concat compatibility
				indicators = indicators.concat(this.options.indicators);
			}

			for (var i = indicators.length; i--;) {
				this.indicators.push(new Indicator(this, indicators[i]));
			}

			// TODO: check if we can use array.map (wide compatibility and performance issues)
			function _indicatorsMap(fn) {
				if (that.indicators) {
					for (var i = that.indicators.length; i--;) {
						fn.call(that.indicators[i]);
					}
				}
			}

			if (this.options.fadeScrollbars) {
				this.on('scrollEnd', function () {
					_indicatorsMap(function () {
						this.fade();
					});
				});

				this.on('scrollCancel', function () {
					_indicatorsMap(function () {
						this.fade();
					});
				});

				this.on('scrollStart', function () {
					_indicatorsMap(function () {
						this.fade(1);
					});
				});

				this.on('beforeScrollStart', function () {
					_indicatorsMap(function () {
						this.fade(1, true);
					});
				});
			}

			this.on('refresh', function () {
				_indicatorsMap(function () {
					this.refresh();
				});
			});

			this.on('destroy', function () {
				_indicatorsMap(function () {
					this.destroy();
				});

				delete this.indicators;
			});
		},

		_initWheel: function _initWheel() {
			utils.addEvent(this.wrapper, 'wheel', this);
			utils.addEvent(this.wrapper, 'mousewheel', this);
			utils.addEvent(this.wrapper, 'DOMMouseScroll', this);

			this.on('destroy', function () {
				clearTimeout(this.wheelTimeout);
				this.wheelTimeout = null;
				utils.removeEvent(this.wrapper, 'wheel', this);
				utils.removeEvent(this.wrapper, 'mousewheel', this);
				utils.removeEvent(this.wrapper, 'DOMMouseScroll', this);
			});
		},

		_wheel: function _wheel(e) {
			if (!this.enabled) {
				return;
			}

			e.preventDefault();

			var wheelDeltaX,
			    wheelDeltaY,
			    newX,
			    newY,
			    that = this;

			if (this.wheelTimeout === undefined) {
				that._execEvent('scrollStart');
			}

			// Execute the scrollEnd event after 400ms the wheel stopped scrolling
			clearTimeout(this.wheelTimeout);
			this.wheelTimeout = setTimeout(function () {
				if (!that.options.snap) {
					that._execEvent('scrollEnd');
				}
				that.wheelTimeout = undefined;
			}, 400);

			if ('deltaX' in e) {
				if (e.deltaMode === 1) {
					wheelDeltaX = -e.deltaX * this.options.mouseWheelSpeed;
					wheelDeltaY = -e.deltaY * this.options.mouseWheelSpeed;
				} else {
					wheelDeltaX = -e.deltaX;
					wheelDeltaY = -e.deltaY;
				}
			} else if ('wheelDeltaX' in e) {
				wheelDeltaX = e.wheelDeltaX / 120 * this.options.mouseWheelSpeed;
				wheelDeltaY = e.wheelDeltaY / 120 * this.options.mouseWheelSpeed;
			} else if ('wheelDelta' in e) {
				wheelDeltaX = wheelDeltaY = e.wheelDelta / 120 * this.options.mouseWheelSpeed;
			} else if ('detail' in e) {
				wheelDeltaX = wheelDeltaY = -e.detail / 3 * this.options.mouseWheelSpeed;
			} else {
				return;
			}

			wheelDeltaX *= this.options.invertWheelDirection;
			wheelDeltaY *= this.options.invertWheelDirection;

			if (!this.hasVerticalScroll) {
				wheelDeltaX = wheelDeltaY;
				wheelDeltaY = 0;
			}

			if (this.options.snap) {
				newX = this.currentPage.pageX;
				newY = this.currentPage.pageY;

				if (wheelDeltaX > 0) {
					newX--;
				} else if (wheelDeltaX < 0) {
					newX++;
				}

				if (wheelDeltaY > 0) {
					newY--;
				} else if (wheelDeltaY < 0) {
					newY++;
				}

				this.goToPage(newX, newY);

				return;
			}

			newX = this.x + Math.round(this.hasHorizontalScroll ? wheelDeltaX : 0);
			newY = this.y + Math.round(this.hasVerticalScroll ? wheelDeltaY : 0);

			this.directionX = wheelDeltaX > 0 ? -1 : wheelDeltaX < 0 ? 1 : 0;
			this.directionY = wheelDeltaY > 0 ? -1 : wheelDeltaY < 0 ? 1 : 0;

			if (newX > 0) {
				newX = 0;
			} else if (newX < this.maxScrollX) {
				newX = this.maxScrollX;
			}

			if (newY > 0) {
				newY = 0;
			} else if (newY < this.maxScrollY) {
				newY = this.maxScrollY;
			}

			this.scrollTo(newX, newY, 0);

			// INSERT POINT: _wheel
		},

		_initSnap: function _initSnap() {
			this.currentPage = {};

			if (typeof this.options.snap == 'string') {
				this.options.snap = this.scroller.querySelectorAll(this.options.snap);
			}

			this.on('refresh', function () {
				var i = 0,
				    l,
				    m = 0,
				    n,
				    cx,
				    cy,
				    x = 0,
				    y,
				    stepX = this.options.snapStepX || this.wrapperWidth,
				    stepY = this.options.snapStepY || this.wrapperHeight,
				    el;

				this.pages = [];

				if (!this.wrapperWidth || !this.wrapperHeight || !this.scrollerWidth || !this.scrollerHeight) {
					return;
				}

				if (this.options.snap === true) {
					cx = Math.round(stepX / 2);
					cy = Math.round(stepY / 2);

					while (x > -this.scrollerWidth) {
						this.pages[i] = [];
						l = 0;
						y = 0;

						while (y > -this.scrollerHeight) {
							this.pages[i][l] = {
								x: Math.max(x, this.maxScrollX),
								y: Math.max(y, this.maxScrollY),
								width: stepX,
								height: stepY,
								cx: x - cx,
								cy: y - cy
							};

							y -= stepY;
							l++;
						}

						x -= stepX;
						i++;
					}
				} else {
					el = this.options.snap;
					l = el.length;
					n = -1;

					for (; i < l; i++) {
						if (i === 0 || el[i].offsetLeft <= el[i - 1].offsetLeft) {
							m = 0;
							n++;
						}

						if (!this.pages[m]) {
							this.pages[m] = [];
						}

						x = Math.max(-el[i].offsetLeft, this.maxScrollX);
						y = Math.max(-el[i].offsetTop, this.maxScrollY);
						cx = x - Math.round(el[i].offsetWidth / 2);
						cy = y - Math.round(el[i].offsetHeight / 2);

						this.pages[m][n] = {
							x: x,
							y: y,
							width: el[i].offsetWidth,
							height: el[i].offsetHeight,
							cx: cx,
							cy: cy
						};

						if (x > this.maxScrollX) {
							m++;
						}
					}
				}

				this.goToPage(this.currentPage.pageX || 0, this.currentPage.pageY || 0, 0);

				// Update snap threshold if needed
				if (this.options.snapThreshold % 1 === 0) {
					this.snapThresholdX = this.options.snapThreshold;
					this.snapThresholdY = this.options.snapThreshold;
				} else {
					this.snapThresholdX = Math.round(this.pages[this.currentPage.pageX][this.currentPage.pageY].width * this.options.snapThreshold);
					this.snapThresholdY = Math.round(this.pages[this.currentPage.pageX][this.currentPage.pageY].height * this.options.snapThreshold);
				}
			});

			this.on('flick', function () {
				var time = this.options.snapSpeed || Math.max(Math.max(Math.min(Math.abs(this.x - this.startX), 1000), Math.min(Math.abs(this.y - this.startY), 1000)), 300);

				this.goToPage(this.currentPage.pageX + this.directionX, this.currentPage.pageY + this.directionY, time);
			});
		},

		_nearestSnap: function _nearestSnap(x, y) {
			if (!this.pages.length) {
				return { x: 0, y: 0, pageX: 0, pageY: 0 };
			}

			var i = 0,
			    l = this.pages.length,
			    m = 0;

			// Check if we exceeded the snap threshold
			if (Math.abs(x - this.absStartX) < this.snapThresholdX && Math.abs(y - this.absStartY) < this.snapThresholdY) {
				return this.currentPage;
			}

			if (x > 0) {
				x = 0;
			} else if (x < this.maxScrollX) {
				x = this.maxScrollX;
			}

			if (y > 0) {
				y = 0;
			} else if (y < this.maxScrollY) {
				y = this.maxScrollY;
			}

			for (; i < l; i++) {
				if (x >= this.pages[i][0].cx) {
					x = this.pages[i][0].x;
					break;
				}
			}

			l = this.pages[i].length;

			for (; m < l; m++) {
				if (y >= this.pages[0][m].cy) {
					y = this.pages[0][m].y;
					break;
				}
			}

			if (i == this.currentPage.pageX) {
				i += this.directionX;

				if (i < 0) {
					i = 0;
				} else if (i >= this.pages.length) {
					i = this.pages.length - 1;
				}

				x = this.pages[i][0].x;
			}

			if (m == this.currentPage.pageY) {
				m += this.directionY;

				if (m < 0) {
					m = 0;
				} else if (m >= this.pages[0].length) {
					m = this.pages[0].length - 1;
				}

				y = this.pages[0][m].y;
			}

			return {
				x: x,
				y: y,
				pageX: i,
				pageY: m
			};
		},

		goToPage: function goToPage(x, y, time, easing) {
			easing = easing || this.options.bounceEasing;

			if (x >= this.pages.length) {
				x = this.pages.length - 1;
			} else if (x < 0) {
				x = 0;
			}

			if (y >= this.pages[x].length) {
				y = this.pages[x].length - 1;
			} else if (y < 0) {
				y = 0;
			}

			var posX = this.pages[x][y].x,
			    posY = this.pages[x][y].y;

			time = time === undefined ? this.options.snapSpeed || Math.max(Math.max(Math.min(Math.abs(posX - this.x), 1000), Math.min(Math.abs(posY - this.y), 1000)), 300) : time;

			this.currentPage = {
				x: posX,
				y: posY,
				pageX: x,
				pageY: y
			};

			this.scrollTo(posX, posY, time, easing);
		},

		next: function next(time, easing) {
			var x = this.currentPage.pageX,
			    y = this.currentPage.pageY;

			x++;

			if (x >= this.pages.length && this.hasVerticalScroll) {
				x = 0;
				y++;
			}

			this.goToPage(x, y, time, easing);
		},

		prev: function prev(time, easing) {
			var x = this.currentPage.pageX,
			    y = this.currentPage.pageY;

			x--;

			if (x < 0 && this.hasVerticalScroll) {
				x = 0;
				y--;
			}

			this.goToPage(x, y, time, easing);
		},

		_initKeys: function _initKeys(e) {
			// default key bindings
			var keys = {
				pageUp: 33,
				pageDown: 34,
				end: 35,
				home: 36,
				left: 37,
				up: 38,
				right: 39,
				down: 40
			};
			var i;

			// if you give me characters I give you keycode
			if (_typeof(this.options.keyBindings) == 'object') {
				for (i in this.options.keyBindings) {
					if (typeof this.options.keyBindings[i] == 'string') {
						this.options.keyBindings[i] = this.options.keyBindings[i].toUpperCase().charCodeAt(0);
					}
				}
			} else {
				this.options.keyBindings = {};
			}

			for (i in keys) {
				this.options.keyBindings[i] = this.options.keyBindings[i] || keys[i];
			}

			utils.addEvent(window, 'keydown', this);

			this.on('destroy', function () {
				utils.removeEvent(window, 'keydown', this);
			});
		},

		_key: function _key(e) {
			if (!this.enabled) {
				return;
			}

			var snap = this.options.snap,
			    // we are using this alot, better to cache it
			newX = snap ? this.currentPage.pageX : this.x,
			    newY = snap ? this.currentPage.pageY : this.y,
			    now = utils.getTime(),
			    prevTime = this.keyTime || 0,
			    acceleration = 0.250,
			    pos;

			if (this.options.useTransition && this.isInTransition) {
				pos = this.getComputedPosition();

				this._translate(Math.round(pos.x), Math.round(pos.y));
				this.isInTransition = false;
			}

			this.keyAcceleration = now - prevTime < 200 ? Math.min(this.keyAcceleration + acceleration, 50) : 0;

			switch (e.keyCode) {
				case this.options.keyBindings.pageUp:
					if (this.hasHorizontalScroll && !this.hasVerticalScroll) {
						newX += snap ? 1 : this.wrapperWidth;
					} else {
						newY += snap ? 1 : this.wrapperHeight;
					}
					break;
				case this.options.keyBindings.pageDown:
					if (this.hasHorizontalScroll && !this.hasVerticalScroll) {
						newX -= snap ? 1 : this.wrapperWidth;
					} else {
						newY -= snap ? 1 : this.wrapperHeight;
					}
					break;
				case this.options.keyBindings.end:
					newX = snap ? this.pages.length - 1 : this.maxScrollX;
					newY = snap ? this.pages[0].length - 1 : this.maxScrollY;
					break;
				case this.options.keyBindings.home:
					newX = 0;
					newY = 0;
					break;
				case this.options.keyBindings.left:
					newX += snap ? -1 : 5 + this.keyAcceleration >> 0;
					break;
				case this.options.keyBindings.up:
					newY += snap ? 1 : 5 + this.keyAcceleration >> 0;
					break;
				case this.options.keyBindings.right:
					newX -= snap ? -1 : 5 + this.keyAcceleration >> 0;
					break;
				case this.options.keyBindings.down:
					newY -= snap ? 1 : 5 + this.keyAcceleration >> 0;
					break;
				default:
					return;
			}

			if (snap) {
				this.goToPage(newX, newY);
				return;
			}

			if (newX > 0) {
				newX = 0;
				this.keyAcceleration = 0;
			} else if (newX < this.maxScrollX) {
				newX = this.maxScrollX;
				this.keyAcceleration = 0;
			}

			if (newY > 0) {
				newY = 0;
				this.keyAcceleration = 0;
			} else if (newY < this.maxScrollY) {
				newY = this.maxScrollY;
				this.keyAcceleration = 0;
			}

			this.scrollTo(newX, newY, 0);

			this.keyTime = now;
		},

		_animate: function _animate(destX, destY, duration, easingFn) {
			var that = this,
			    startX = this.x,
			    startY = this.y,
			    startTime = utils.getTime(),
			    destTime = startTime + duration;

			function step() {
				var now = utils.getTime(),
				    newX,
				    newY,
				    easing;

				if (now >= destTime) {
					that.isAnimating = false;
					that._translate(destX, destY);

					if (!that.resetPosition(that.options.bounceTime)) {
						that._execEvent('scrollEnd');
					}

					return;
				}

				now = (now - startTime) / duration;
				easing = easingFn(now);
				newX = (destX - startX) * easing + startX;
				newY = (destY - startY) * easing + startY;
				that._translate(newX, newY);

				if (that.isAnimating) {
					rAF(step);
				}
			}

			this.isAnimating = true;
			step();
		},
		handleEvent: function handleEvent(e) {
			switch (e.type) {
				case 'touchstart':
				case 'pointerdown':
				case 'MSPointerDown':
				case 'mousedown':
					this._start(e);
					break;
				case 'touchmove':
				case 'pointermove':
				case 'MSPointerMove':
				case 'mousemove':
					this._move(e);
					break;
				case 'touchend':
				case 'pointerup':
				case 'MSPointerUp':
				case 'mouseup':
				case 'touchcancel':
				case 'pointercancel':
				case 'MSPointerCancel':
				case 'mousecancel':
					this._end(e);
					break;
				case 'orientationchange':
				case 'resize':
					this._resize();
					break;
				case 'transitionend':
				case 'webkitTransitionEnd':
				case 'oTransitionEnd':
				case 'MSTransitionEnd':
					this._transitionEnd(e);
					break;
				case 'wheel':
				case 'DOMMouseScroll':
				case 'mousewheel':
					this._wheel(e);
					break;
				case 'keydown':
					this._key(e);
					break;
				case 'click':
					if (this.enabled && !e._constructed) {
						e.preventDefault();
						e.stopPropagation();
					}
					break;
			}
		}
	};
	function createDefaultScrollbar(direction, interactive, type) {
		var scrollbar = document.createElement('div'),
		    indicator = document.createElement('div');

		if (type === true) {
			scrollbar.style.cssText = 'position:absolute;z-index:9999';
			indicator.style.cssText = '-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;position:absolute;background:rgba(0,0,0,0.5);border:1px solid rgba(255,255,255,0.9);border-radius:3px';
		}

		indicator.className = 'iScrollIndicator';

		if (direction == 'h') {
			if (type === true) {
				scrollbar.style.cssText += ';height:7px;left:2px;right:2px;bottom:0';
				indicator.style.height = '100%';
			}
			scrollbar.className = 'iScrollHorizontalScrollbar';
		} else {
			if (type === true) {
				scrollbar.style.cssText += ';width:7px;bottom:2px;top:2px;right:1px';
				indicator.style.width = '100%';
			}
			scrollbar.className = 'iScrollVerticalScrollbar';
		}

		scrollbar.style.cssText += ';overflow:hidden';

		if (!interactive) {
			scrollbar.style.pointerEvents = 'none';
		}

		scrollbar.appendChild(indicator);

		return scrollbar;
	}

	function Indicator(scroller, options) {
		this.wrapper = typeof options.el == 'string' ? document.querySelector(options.el) : options.el;
		this.wrapperStyle = this.wrapper.style;
		this.indicator = this.wrapper.children[0];
		this.indicatorStyle = this.indicator.style;
		this.scroller = scroller;

		this.options = {
			listenX: true,
			listenY: true,
			interactive: false,
			resize: true,
			defaultScrollbars: false,
			shrink: false,
			fade: false,
			speedRatioX: 0,
			speedRatioY: 0
		};

		for (var i in options) {
			this.options[i] = options[i];
		}

		this.sizeRatioX = 1;
		this.sizeRatioY = 1;
		this.maxPosX = 0;
		this.maxPosY = 0;

		if (this.options.interactive) {
			if (!this.options.disableTouch) {
				utils.addEvent(this.indicator, 'touchstart', this);
				utils.addEvent(window, 'touchend', this);
			}
			if (!this.options.disablePointer) {
				utils.addEvent(this.indicator, utils.prefixPointerEvent('pointerdown'), this);
				utils.addEvent(window, utils.prefixPointerEvent('pointerup'), this);
			}
			if (!this.options.disableMouse) {
				utils.addEvent(this.indicator, 'mousedown', this);
				utils.addEvent(window, 'mouseup', this);
			}
		}

		if (this.options.fade) {
			this.wrapperStyle[utils.style.transform] = this.scroller.translateZ;
			var durationProp = utils.style.transitionDuration;
			this.wrapperStyle[durationProp] = utils.isBadAndroid ? '0.0001ms' : '0ms';
			// remove 0.0001ms
			var self = this;
			if (utils.isBadAndroid) {
				rAF(function () {
					if (self.wrapperStyle[durationProp] === '0.0001ms') {
						self.wrapperStyle[durationProp] = '0s';
					}
				});
			}
			this.wrapperStyle.opacity = '0';
		}
	}

	Indicator.prototype = {
		handleEvent: function handleEvent(e) {
			switch (e.type) {
				case 'touchstart':
				case 'pointerdown':
				case 'MSPointerDown':
				case 'mousedown':
					this._start(e);
					break;
				case 'touchmove':
				case 'pointermove':
				case 'MSPointerMove':
				case 'mousemove':
					this._move(e);
					break;
				case 'touchend':
				case 'pointerup':
				case 'MSPointerUp':
				case 'mouseup':
				case 'touchcancel':
				case 'pointercancel':
				case 'MSPointerCancel':
				case 'mousecancel':
					this._end(e);
					break;
			}
		},

		destroy: function destroy() {
			if (this.options.fadeScrollbars) {
				clearTimeout(this.fadeTimeout);
				this.fadeTimeout = null;
			}
			if (this.options.interactive) {
				utils.removeEvent(this.indicator, 'touchstart', this);
				utils.removeEvent(this.indicator, utils.prefixPointerEvent('pointerdown'), this);
				utils.removeEvent(this.indicator, 'mousedown', this);

				utils.removeEvent(window, 'touchmove', this);
				utils.removeEvent(window, utils.prefixPointerEvent('pointermove'), this);
				utils.removeEvent(window, 'mousemove', this);

				utils.removeEvent(window, 'touchend', this);
				utils.removeEvent(window, utils.prefixPointerEvent('pointerup'), this);
				utils.removeEvent(window, 'mouseup', this);
			}

			if (this.options.defaultScrollbars) {
				this.wrapper.parentNode.removeChild(this.wrapper);
			}
		},

		_start: function _start(e) {
			var point = e.touches ? e.touches[0] : e;

			e.preventDefault();
			e.stopPropagation();

			this.transitionTime();

			this.initiated = true;
			this.moved = false;
			this.lastPointX = point.pageX;
			this.lastPointY = point.pageY;

			this.startTime = utils.getTime();

			if (!this.options.disableTouch) {
				utils.addEvent(window, 'touchmove', this);
			}
			if (!this.options.disablePointer) {
				utils.addEvent(window, utils.prefixPointerEvent('pointermove'), this);
			}
			if (!this.options.disableMouse) {
				utils.addEvent(window, 'mousemove', this);
			}

			this.scroller._execEvent('beforeScrollStart');
		},

		_move: function _move(e) {
			var point = e.touches ? e.touches[0] : e,
			    deltaX,
			    deltaY,
			    newX,
			    newY,
			    timestamp = utils.getTime();

			if (!this.moved) {
				this.scroller._execEvent('scrollStart');
			}

			this.moved = true;

			deltaX = point.pageX - this.lastPointX;
			this.lastPointX = point.pageX;

			deltaY = point.pageY - this.lastPointY;
			this.lastPointY = point.pageY;

			newX = this.x + deltaX;
			newY = this.y + deltaY;

			this._pos(newX, newY);

			// INSERT POINT: indicator._move

			e.preventDefault();
			e.stopPropagation();
		},

		_end: function _end(e) {
			if (!this.initiated) {
				return;
			}

			this.initiated = false;

			e.preventDefault();
			e.stopPropagation();

			utils.removeEvent(window, 'touchmove', this);
			utils.removeEvent(window, utils.prefixPointerEvent('pointermove'), this);
			utils.removeEvent(window, 'mousemove', this);

			if (this.scroller.options.snap) {
				var snap = this.scroller._nearestSnap(this.scroller.x, this.scroller.y);

				var time = this.options.snapSpeed || Math.max(Math.max(Math.min(Math.abs(this.scroller.x - snap.x), 1000), Math.min(Math.abs(this.scroller.y - snap.y), 1000)), 300);

				if (this.scroller.x != snap.x || this.scroller.y != snap.y) {
					this.scroller.directionX = 0;
					this.scroller.directionY = 0;
					this.scroller.currentPage = snap;
					this.scroller.scrollTo(snap.x, snap.y, time, this.scroller.options.bounceEasing);
				}
			}

			if (this.moved) {
				this.scroller._execEvent('scrollEnd');
			}
		},

		transitionTime: function transitionTime(time) {
			time = time || 0;
			var durationProp = utils.style.transitionDuration;
			this.indicatorStyle[durationProp] = time + 'ms';

			if (!time && utils.isBadAndroid) {
				this.indicatorStyle[durationProp] = '0.0001ms';
				// remove 0.0001ms
				var self = this;
				rAF(function () {
					if (self.indicatorStyle[durationProp] === '0.0001ms') {
						self.indicatorStyle[durationProp] = '0s';
					}
				});
			}
		},

		transitionTimingFunction: function transitionTimingFunction(easing) {
			this.indicatorStyle[utils.style.transitionTimingFunction] = easing;
		},

		refresh: function refresh() {
			this.transitionTime();

			if (this.options.listenX && !this.options.listenY) {
				this.indicatorStyle.display = this.scroller.hasHorizontalScroll ? 'block' : 'none';
			} else if (this.options.listenY && !this.options.listenX) {
				this.indicatorStyle.display = this.scroller.hasVerticalScroll ? 'block' : 'none';
			} else {
				this.indicatorStyle.display = this.scroller.hasHorizontalScroll || this.scroller.hasVerticalScroll ? 'block' : 'none';
			}

			if (this.scroller.hasHorizontalScroll && this.scroller.hasVerticalScroll) {
				utils.addClass(this.wrapper, 'iScrollBothScrollbars');
				utils.removeClass(this.wrapper, 'iScrollLoneScrollbar');

				if (this.options.defaultScrollbars && this.options.customStyle) {
					if (this.options.listenX) {
						this.wrapper.style.right = '8px';
					} else {
						this.wrapper.style.bottom = '8px';
					}
				}
			} else {
				utils.removeClass(this.wrapper, 'iScrollBothScrollbars');
				utils.addClass(this.wrapper, 'iScrollLoneScrollbar');

				if (this.options.defaultScrollbars && this.options.customStyle) {
					if (this.options.listenX) {
						this.wrapper.style.right = '2px';
					} else {
						this.wrapper.style.bottom = '2px';
					}
				}
			}

			var r = this.wrapper.offsetHeight; // force refresh

			if (this.options.listenX) {
				this.wrapperWidth = this.wrapper.clientWidth;
				if (this.options.resize) {
					this.indicatorWidth = Math.max(Math.round(this.wrapperWidth * this.wrapperWidth / (this.scroller.scrollerWidth || this.wrapperWidth || 1)), 8);
					this.indicatorStyle.width = this.indicatorWidth + 'px';
				} else {
					this.indicatorWidth = this.indicator.clientWidth;
				}

				this.maxPosX = this.wrapperWidth - this.indicatorWidth;

				if (this.options.shrink == 'clip') {
					this.minBoundaryX = -this.indicatorWidth + 8;
					this.maxBoundaryX = this.wrapperWidth - 8;
				} else {
					this.minBoundaryX = 0;
					this.maxBoundaryX = this.maxPosX;
				}

				this.sizeRatioX = this.options.speedRatioX || this.scroller.maxScrollX && this.maxPosX / this.scroller.maxScrollX;
			}

			if (this.options.listenY) {
				this.wrapperHeight = this.wrapper.clientHeight;
				if (this.options.resize) {
					this.indicatorHeight = Math.max(Math.round(this.wrapperHeight * this.wrapperHeight / (this.scroller.scrollerHeight || this.wrapperHeight || 1)), 8);
					this.indicatorStyle.height = this.indicatorHeight + 'px';
				} else {
					this.indicatorHeight = this.indicator.clientHeight;
				}

				this.maxPosY = this.wrapperHeight - this.indicatorHeight;

				if (this.options.shrink == 'clip') {
					this.minBoundaryY = -this.indicatorHeight + 8;
					this.maxBoundaryY = this.wrapperHeight - 8;
				} else {
					this.minBoundaryY = 0;
					this.maxBoundaryY = this.maxPosY;
				}

				this.maxPosY = this.wrapperHeight - this.indicatorHeight;
				this.sizeRatioY = this.options.speedRatioY || this.scroller.maxScrollY && this.maxPosY / this.scroller.maxScrollY;
			}

			this.updatePosition();
		},

		updatePosition: function updatePosition() {
			var x = this.options.listenX && Math.round(this.sizeRatioX * this.scroller.x) || 0,
			    y = this.options.listenY && Math.round(this.sizeRatioY * this.scroller.y) || 0;

			if (!this.options.ignoreBoundaries) {
				if (x < this.minBoundaryX) {
					if (this.options.shrink == 'scale') {
						this.width = Math.max(this.indicatorWidth + x, 8);
						this.indicatorStyle.width = this.width + 'px';
					}
					x = this.minBoundaryX;
				} else if (x > this.maxBoundaryX) {
					if (this.options.shrink == 'scale') {
						this.width = Math.max(this.indicatorWidth - (x - this.maxPosX), 8);
						this.indicatorStyle.width = this.width + 'px';
						x = this.maxPosX + this.indicatorWidth - this.width;
					} else {
						x = this.maxBoundaryX;
					}
				} else if (this.options.shrink == 'scale' && this.width != this.indicatorWidth) {
					this.width = this.indicatorWidth;
					this.indicatorStyle.width = this.width + 'px';
				}

				if (y < this.minBoundaryY) {
					if (this.options.shrink == 'scale') {
						this.height = Math.max(this.indicatorHeight + y * 3, 8);
						this.indicatorStyle.height = this.height + 'px';
					}
					y = this.minBoundaryY;
				} else if (y > this.maxBoundaryY) {
					if (this.options.shrink == 'scale') {
						this.height = Math.max(this.indicatorHeight - (y - this.maxPosY) * 3, 8);
						this.indicatorStyle.height = this.height + 'px';
						y = this.maxPosY + this.indicatorHeight - this.height;
					} else {
						y = this.maxBoundaryY;
					}
				} else if (this.options.shrink == 'scale' && this.height != this.indicatorHeight) {
					this.height = this.indicatorHeight;
					this.indicatorStyle.height = this.height + 'px';
				}
			}

			this.x = x;
			this.y = y;

			if (this.scroller.options.useTransform) {
				this.indicatorStyle[utils.style.transform] = 'translate(' + x + 'px,' + y + 'px)' + this.scroller.translateZ;
			} else {
				this.indicatorStyle.left = x + 'px';
				this.indicatorStyle.top = y + 'px';
			}
		},

		_pos: function _pos(x, y) {
			if (x < 0) {
				x = 0;
			} else if (x > this.maxPosX) {
				x = this.maxPosX;
			}

			if (y < 0) {
				y = 0;
			} else if (y > this.maxPosY) {
				y = this.maxPosY;
			}

			x = this.options.listenX ? Math.round(x / this.sizeRatioX) : this.scroller.x;
			y = this.options.listenY ? Math.round(y / this.sizeRatioY) : this.scroller.y;

			this.scroller.scrollTo(x, y);
		},

		fade: function fade(val, hold) {
			if (hold && !this.visible) {
				return;
			}

			clearTimeout(this.fadeTimeout);
			this.fadeTimeout = null;

			var time = val ? 250 : 500,
			    delay = val ? 0 : 300;

			val = val ? '1' : '0';

			this.wrapperStyle[utils.style.transitionDuration] = time + 'ms';

			this.fadeTimeout = setTimeout(function (val) {
				this.wrapperStyle.opacity = val;
				this.visible = +val;
			}.bind(this, val), delay);
		}
	};

	IScroll.utils = utils;

	if (typeof module != 'undefined' && module.exports) {
		module.exports = IScroll;
	} else if (typeof define == 'function' && define.amd) {
		define(function () {
			return IScroll;
		});
	} else {
		window.IScroll = IScroll;
	}
})(window, document, Math);

},{}],56:[function(require,module,exports){
'use strict';

var TextableComponent = require('./src/js/TextableComponent.js');

module.exports = TextableComponent;

},{"./src/js/TextableComponent.js":57}],57:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.TextableComponent = undefined;

var _component = require('component');

var _translate = require('translate');

var _translate2 = _interopRequireDefault(_translate);

var _utils = require('utils');

var _utils2 = _interopRequireDefault(_utils);

var _sightglass = require('sightglass');

var _sightglass2 = _interopRequireDefault(_sightglass);

var _rivets = require('rivets');

var _rivets2 = _interopRequireDefault(_rivets);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var textProperties = [Text, 'Text'];

var TextableComponent = exports.TextableComponent = function (_Component) {
	_inherits(TextableComponent, _Component);

	function TextableComponent() {
		_classCallCheck(this, TextableComponent);

		var _this = _possibleConstructorReturn(this, (TextableComponent.__proto__ || Object.getPrototypeOf(TextableComponent)).apply(this, arguments));

		_this.t = _translate2.default.getCurrentLocalization();

		_translate2.default.onLanguageChange(function (localization) {
			_utils2.default.mixin(_this.t, localization);
		});

		setTextObservation(_this, _this.defaults, co.scope.t);
		return _this;
	}

	return TextableComponent;
}(_component.Component);

function setTextObservation(component, defaultProperties, model) {
	var defaults = _utils2.default.toCamelCaseObject(defaultProperties);

	var isTextRefresh = function isTextRefresh(property) {
		return isRefreshableProperty(defaults, property) && isTextProperty(defaults, property);
	};

	Object.keys(defaults).filter(isTextRefresh).forEach(function (property) {
		var value = component[property];
		if (typeof value === "string") {
			var key = _utils2.default.startsWith(value, 't.') && value.split(/t.(.+)?/)[1];

			if (key) {
				configureSightglass();
				(0, _sightglass2.default)(model, key, function () {
					component.refresh(property);
				});
			}
		}
	});
}

function isRefreshableProperty(defaultProperties, property) {
	return !!defaultProperties[property].refresh;
}

function isTextProperty(defaultProperties, property) {
	var type = defaultProperties[property].type;
	return textProperties.indexOf(type) !== -1;
}

function configureSightglass() {
	_sightglass2.default.adapters = _rivets2.default.adapters;
	_sightglass2.default.root = _rivets2.default.rootInterface;
}

},{"component":48,"rivets":"rivets","sightglass":"sightglass","translate":"translate","utils":"utils"}],58:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.Tabs = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _component = require('component');

var _utils = require('utils');

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Tabs = exports.Tabs = function (_Component) {
	_inherits(Tabs, _Component);

	function Tabs() {
		_classCallCheck(this, Tabs);

		var _this = _possibleConstructorReturn(this, (Tabs.__proto__ || Object.getPrototypeOf(Tabs)).apply(this, arguments));

		_this.scrollerModel = {
			scrollbars: 'custom'
		};
		return _this;
	}

	_createClass(Tabs, [{
		key: 'ready',
		value: function ready() {
			this.buttons = this.getButtonsData();
			this.contentCollection = this.getContentCollection();
			this.navCollection = this.getNavCollection();
		}
	}, {
		key: 'getButtonsData',
		value: function getButtonsData() {
			return [].concat(_toConsumableArray(this.content));
		}
	}, {
		key: 'getNavCollection',
		value: function getNavCollection() {
			return this.getCollection('navigation-menu-buttons');
		}
	}, {
		key: 'getContentCollection',
		value: function getContentCollection() {
			return this.getCollection('tabs');
		}
	}, {
		key: 'getCollection',
		value: function getCollection(classWrapper) {
			var wrapper = this.element.getElementsByClassName(classWrapper)[0];
			var collection = void 0;
			if (wrapper) {
				collection = wrapper.getElementsByTagName('co-collection')[0];
			}
			if (collection) {
				return collection;
			}
			throw new Error("Can't find co-collection");
		}
	}, {
		key: 'template',
		value: function template() {
			return require('../template.html');
		}
	}, {
		key: 'refresh',
		value: function refresh(attrName) {
			switch (attrName) {
				case 'buttons':
					this.updateData(this.contentCollection, this.content, this.buttons);
					break;
				case 'content':
					this.updateData(this.navCollection, this.buttons, this.content);
					break;
			}
		}
	}, {
		key: 'updateData',
		value: function updateData(collection, target, opposite) {
			var isInsert = isMore(opposite, target);
			var isRemove = isLess(opposite, target);

			if (isInsert) {
				this.insert(collection, opposite, target);
			}

			if (isRemove) {
				this.remove(collection, target, opposite);
			}
		}
	}, {
		key: 'insert',
		value: function insert(target, content, comparedContent) {
			processContent(content, comparedContent, function (index, chunkOfContent) {
				return target.model.insert((0, _utils.mixin)({}, chunkOfContent), index);
			});
		}
	}, {
		key: 'remove',
		value: function remove(target, content, comparedContent) {
			processContent(content, comparedContent, function (index) {
				return target.model.remove(index);
			});
		}
	}, {
		key: 'defaults',
		get: function get() {
			return {
				'orientation': {
					type: String,
					value: 'horizontal',
					values: ['horizontal', 'vertical'],
					refresh: true
				},
				'buttons': {
					type: Array,
					sealed: true,
					value: [{}],
					refresh: true
				},
				'content': {
					type: Array,
					sealed: true,
					value: [{
						'navHeaderActive': { 'html': '<b>Tab 1</b>' },
						'navHeaderInactive': { 'html': '<b>Tab 1</b>' },
						'image': {},
						'headerText': { 'html': 'Lorem ipsum dolor sit amet' },
						'text': { 'html': 'Tab 1 -- Consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur.' }
					}, {
						'navHeaderActive': { 'html': '<b>Tab 2</b>' },
						'navHeaderInactive': { 'html': '<b>Tab 2</b>' },
						'image': {},
						'headerText': { 'html': 'Lorem ipsum dolor sit amet' },
						'text': { 'html': 'Tab 2 -- Consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur.' }
					}, {
						'navHeaderActive': { 'html': '<b>Tab 3</b>' },
						'navHeaderInactive': { 'html': '<b>Tab 3</b>' },
						'image': {},
						'headerText': { 'html': 'Lorem ipsum dolor sit amet' },
						'text': { 'html': 'Tab 3 -- Consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur.' }
					}, {
						'navHeaderActive': { 'html': '<b>Tab 4</b>' },
						'navHeaderInactive': { 'html': '<b>Tab 4</b>' },
						'image': {},
						'headerText': { 'html': 'Lorem ipsum dolor sit amet' },
						'text': { 'html': 'Consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur.' }
					}],
					refresh: true
				}
			};
		}
	}]);

	return Tabs;
}(_component.Component);

function processContent(content, comparedContent, cb) {
	content.forEach(function (chunkOfContent, index) {
		if (!isEqualObj(chunkOfContent, comparedContent[index])) {
			cb(index, chunkOfContent);
		}
	});
}

function isEqualObj(base, compared) {
	var isEqual = !isEmpty(base, compared);

	if (!isEqual) {
		return isEqual;
	}

	var baseKeys = Object.keys(base);
	var comparedKeys = Object.keys(compared);

	isEqual = isEqualLength(baseKeys, comparedKeys);
	if (!isEqual) {
		return isEqual;
	}

	return baseKeys.every(function (key) {
		return base[key] === compared[key];
	});
}

function isEmpty(base, compared) {
	return !(base && compared);
}

function isEqualLength(base, compared) {
	return base.length === compared.length;
}

function isMore(base, compared) {
	return base.length > compared.length;
}

function isLess(base, compared) {
	return base.length < compared.length;
}

},{"../template.html":59,"component":48,"utils":"utils"}],59:[function(require,module,exports){
module.exports = '<co-tab-group class="default" model="model" sealed co-tabs><div class="tab-group-buttons" co-tabs><co-collection class="nav-tabs" items="buttons" as="item" fixed dynamic="true" co-tabs><co-collection-item fixed co-tabs><co-container co-tabs><co-option class="tab-btn" sealed co-tabs><co-container class="active" fixed user-label="Active tab" co-tabs><co-text model="item.navHeaderActive" fixed="position, size" co-tabs></co-text></co-container><co-container class="passive" fixed user-label="Inactive tab" co-tabs><co-text model="item.navHeaderInactive" fixed="position, size" co-tabs></co-text></co-container></co-option></co-container></co-collection-item></co-collection></div><div class="tabs" fixed co-tabs><co-collection items="content" as="item" fixed co-tabs><co-collection-item fixed co-tabs><div co-tabs><co-iscroll model="scrollerModel" sealed co-tabs><co-text class="h4" model="item.headerText" fixed="position, size" co-tabs></co-text><co-text model="item.text" fixed="position, size" co-tabs></co-text></co-iscroll></div><co-image class="image" model="item.image" position="imgPosition" size="imgSize" co-tabs></co-image></co-collection-item></co-collection></div></co-tab-group><content co-tabs></content>'
},{}]},{},[1]);
