exports.mixin = function (target, source, args) {
  var keys = args instanceof Array ? args : Object.keys(source)

  keys.forEach(function (key) {
    if (source.hasOwnProperty(key)) {
      target[key] = source[key]
    }
  })

  return target
}

exports.template = function (string, data) {
  return string.replace(/\{([^\}]+)\}/g, function (match, key) {
    return data[key.trim()]
  })
}

exports.dispathEvent = function (target, event, options) {
  options = exports.mixin({ bubbles: true, cancelable: false }, options || {})
  target.dispatchEvent(new CustomEvent(event, options))
}

exports.dispatchEvent = exports.dispathEvent

exports.rangeValue = function (value, min, max) {
  if (value < min) {
    return min
  }

  if (value > max) {
    return max
  }

  return value
}

exports.load = function (url, callback, async) {
  var request = new XMLHttpRequest()

  request.onload = callback

  request.open('GET', url, !!async)
  request.send()

  return request
}

exports.loadAsync = function (url, useCache) {
  return new Promise(function (resolve, reject) {
    var request;

    request = new XMLHttpRequest();

    request.open('GET', modifyUrlByCacheDepend(url, useCache), true);

    request.onload = function () {
      if (request.status === 200 || checkApplicationStatus(request.readyState)) {
        resolve(request.response);
      } else {
        reject(Error(request.statusText));
      }
    };

    request.onerror = function () {
      reject(Error('Network Error'));
    };

    request.send();
  });
};

exports.getTimeStamp = function () {
  return (new Date()).getTime()
}

function modifyUrlByCacheDepend(url, useCache){
  if(useCache){
    return url;
  }

  return url + getUrlSeparator(url) + exports.getTimeStamp();
}

function getUrlSeparator(url) {
  var conditionToSeparate  =  /\?/;

  if(conditionToSeparate.test(url)){
    return '&';
  }

  return '?'
}

function checkApplicationStatus (state) {
  var DONE = 4
  return !document.domain && state === DONE
}

// mapToArray :: Object -> Array
// Convert Object properties to Array's item and extending them with property's key
exports.mapToArray = function (map) {
  return Object.keys(map).map(function (id) {
    var item = map[id],
      obj = Object.create(item)
    obj.id = id
    return obj
  })
}

// toObject :: Array -> Array -> Object
exports.toObject = function (keys, values) {
  var object = {}

  keys.forEach(function (key, index) {
    object[key] = values[index]
  })

  return object
}

// HTMLCollection -> Array
exports.toArray = function (collection) {
  return Array.prototype.slice.call(collection, 0)
}

exports.revive = function (str) {
  try {
    return JSON.parse(str)
  } catch (e) {
    return str
  }
}

exports.once = function (element, event, callback, isOnCapturing) {
  var func

  element.addEventListener(event, func = function () {
    callback.apply(this, arguments)

    element.removeEventListener(event, func, isOnCapturing)
  }, isOnCapturing)
}

exports.inherits = function (ctor, superCtor) {
  ctor.super_ = superCtor
  ctor.prototype = Object.create(superCtor.prototype, {
    constructor: {
      value: ctor,
      enumerable: false,
      writable: true,
      configurable: true
    }
  })
}

// TODO document the function
exports.contains = function (haystack, needle) {
  var isObject = Object.prototype.toString.call(haystack) === '[object Object]'
  var searchInItem = isObject ? Object.keys(haystack) : haystack

  return searchInItem.indexOf(needle) > -1
}

exports.toCamelCaseObject = function (obj) {
  return Object.keys(obj).reduce(function (accum, property) {
    accum[exports.toCamelCase(property)] = obj[property]
    return accum
  }, {})
}

exports.toCamelCase = function (string) {
  return string.replace(/-([a-z])/g, function (delimiter) {
    return delimiter[1].toUpperCase()
  })
}

exports.startsWith = function (string, symbol) {
  return string.indexOf(symbol) === 0
}

exports.reviveByType = function (value, type) {
  if (type === Number || type === Boolean) {
    return exports.revive(value)
  }

  return value
}

exports.deepMixin = function (target, source) {
  if (exports.isObject(target) && exports.isObject(source)) {
    Object.keys(source)
			.forEach(function (property) {
  if (!target[property]) {
    target[property] = source[property]
  }
  if (exports.isObject(target[property]) && exports.isObject(source[property])) {
    exports.deepMixin(target[property], source[property])
  } else if (exports.isArray(target[property]) && exports.isArray(source[property])) {
    exports.mixinArrays(target[property], source[property])
  } else {
    target[property] = source[property]
  }
})
  }
  return target
}

exports.mixinArrays = function (target, source) {
  source.forEach(function (item, index) {
    if (!defined(target[index])) {
      target.push(source[index])
    }
    if (exports.isObject(target[index]) && exports.isObject(source[index])) {
      exports.deepMixin(target[index], source[index])
    } else if (exports.isArray(target[index]) && exports.isArray(source[index])) {
      exports.mixinArrays(target[index], source[index])
    } else {
      target[index] = source[index]
    }
  })

  if (target.length > source.length) {
    var diff = target.length - source.length
    target.splice(source.length, diff)
  }
}

exports.debounce = function (fn, throttle) {
  var timer = null
  return function () {
    var context = this,
      args = arguments
    clearTimeout(timer)
    timer = setTimeout(function () {
      fn.apply(context, args)
    }, throttle)
  }
}

exports.isArray = function (array) {
  return Array.isArray(array)
}

exports.isObject = function (obj) {
  return obj && typeof obj === 'object' && !exports.isArray(obj)
}

exports.parse = function (obj) {
  return JSON.parse(JSON.stringify(obj))
}

exports.isUnique = function (item, index, array) {
  return array.indexOf(item) === index
}

exports.prependChild = function (parent, child) {
  const firstChild = parent.children[0]

  if (firstChild) {
    parent.insertBefore(child, firstChild)
  } else {
    parent.appendChild(child)
  }
}

exports.flattenArray = function (array) {
  return array.reduce(function (acc, next) {
    return acc.concat(next)
  }, [])
}

exports.jsonOrText = function (str) {
  var res

  try {
    res = JSON.parse(str)
  } catch (e) {
    res = str
  }

  return res
}

function defined (value) {
  return value !== undefined && value !== null
}

exports.difference = require('./src/diff.js')
exports.isEquals = require('./src/is-equals.js')
exports.Observer = require('./src/observer.js')
